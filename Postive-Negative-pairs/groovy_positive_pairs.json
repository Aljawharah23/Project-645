[
    [
        "GROOVY-20",
        "GROOVY-19",
        "allow 'package' to be optional The package statement should be optional, defaulting the class to the root package if not specified.",
        "package should be optional in a Groovy class Right now the package statement is mandatory. We should make it optional.\n\nIt might be handy to allow the compiler to default the package name from the relative directory structure when compiling stuff"
    ],
    [
        "GROOVY-211",
        "GROOVY-131",
        "Cand have a closure over the parameters of another closure c = { x |\n\t\tc1 = {\n\t\t\tprintln x[0]\n\t\t}\n\t\t\n\t\tc1()\n\t}\n\t\nc([1])\n\nproduces a null pointer exception\n\n\nc = { x |\n\t\txx = x\n\t\tc1 = {\n\t\t\tprintln xx[0]\n\t\t}\n\t\t\n\t\tc1()\n\t}\n\t\nc([1])\n\nworks",
        "Variable visibility issue within nested closures There is a nested closures variable scope visibility issue.\n(var a; closure-one(\"a is visible\" closure-two(\"a is not visible\"))\n\nI've attached a test case which illustrate that better : \nClosureInClosureBug.groovy\n\nDon't forget to uncomment the commented line to see the issue.\nOtherwise the test will pass of course !\n\nHere is the stacktrace I caught with this test case:\n\nCaught: groovy.lang.MissingPropertyException: No such property: text for class: ClosureInClosureBug$2\ngroovy.lang.MissingPropertyException: No such property: text for class: ClosureInClosureBug$2\n\tat groovy.lang.MetaClass.getProperty(MetaClass.java:398)\n\tat groovy.lang.Closure.getProperty(Closure.java:89)\n\tat org.codehaus.groovy.runtime.Invoker.getProperty(Invoker.java:437)\n\tat org.codehaus.groovy.runtime.InvokerHelper.getProperty(InvokerHelper.java:139)\n\tat ClosureInClosureBug$2.doCall(D:\\groovy\\samples\\ClosureInClosureBug.groovy)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n\tat java.lang.reflect.Method.invoke(Method.java:324)\n\tat groovy.lang.MetaClass.doMethodInvoke(MetaClass.java:758)\n\tat groovy.lang.MetaClass.invokeMethod(MetaClass.java:214)\n\tat groovy.lang.MetaClass.invokeMethod(MetaClass.java:188)\n\tat groovy.lang.Closure.invokeMethod(Closure.java:69)\n\tat org.codehaus.groovy.runtime.Invoker.invokeMethod(Invoker.java:114)\n\tat org.codehaus.groovy.runtime.InvokerHelper.invokeMethod(InvokerHelper.java:92)\n\tat groovy.lang.Closure.call(Closure.java:145)\n\tat org.codehaus.groovy.runtime.DefaultGroovyMethods.each(DefaultGroovyMethods.java:256)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n\tat java.lang.reflect.Method.invoke(Method.java:324)\n\tat groovy.lang.MetaClass.doMethodInvoke(MetaClass.java:758)\n\tat groovy.lang.MetaClass.invokeMethod(MetaClass.java:236)\n\tat org.codehaus.groovy.runtime.Invoker.invokeMethod(Invoker.java:127)\n\tat org.codehaus.groovy.runtime.InvokerHelper.invokeMethod(InvokerHelper.java:92)\n\tat ClosureInClosureBug$1.doCall(D:\\groovy\\samples\\ClosureInClosureBug.groovy:21)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n\tat java.lang.reflect.Method.invoke(Method.java:324)\n\tat groovy.lang.MetaClass.doMethodInvoke(MetaClass.java:758)\n\tat groovy.lang.MetaClass.invokeMethod(MetaClass.java:214)\n\tat groovy.lang.MetaClass.invokeMethod(MetaClass.java:188)\n\tat groovy.lang.Closure.invokeMethod(Closure.java:69)\n\tat org.codehaus.groovy.runtime.Invoker.invokeMethod(Invoker.java:114)\n\tat org.codehaus.groovy.runtime.InvokerHelper.invokeMethod(InvokerHelper.java:92)\n\tat groovy.lang.Closure.call(Closure.java:145)\n\tat org.codehaus.groovy.runtime.DefaultGroovyMethods.each(DefaultGroovyMethods.java:256)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n\tat java.lang.reflect.Method.invoke(Method.java:324)\n\tat groovy.lang.MetaClass.doMethodInvoke(MetaClass.java:758)\n\tat groovy.lang.MetaClass.invokeMethod(MetaClass.java:236)\n\tat org.codehaus.groovy.runtime.Invoker.invokeMethod(Invoker.java:127)\n\tat org.codehaus.groovy.runtime.InvokerHelper.invokeMethod(InvokerHelper.java:92)\n\tat ClosureInClosureBug.testInvisibleVariable(D:\\groovy\\samples\\ClosureInClosureBug.groovy:18)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n\tat java.lang.reflect.Method.invoke(Method.java:324)\n\tat groovy.lang.MetaClass.doMethodInvoke(MetaClass.java:758)\n\tat groovy.lang.MetaClass.invokeMethod(MetaClass.java:214)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n\tat java.lang.reflect.Method.invoke(Method.java:324)\n\tat groovy.lang.MetaClass.doMethodInvoke(MetaClass.java:758)\n\tat groovy.lang.MetaClass.invokeMethod(MetaClass.java:214)\n\tat org.codehaus.groovy.runtime.Invoker.invokeMethod(Invoker.java:127)\n\tat org.codehaus.groovy.runtime.InvokerHelper.invokeMethod(InvokerHelper.java:92)\n\tat ClosureInClosureBug.invokeMethod(D:\\groovy\\samples\\ClosureInClosureBug.groovy)\n\tat org.codehaus.groovy.runtime.Invoker.invokeMethod(Invoker.java:114)\n\tat org.codehaus.groovy.runtime.InvokerHelper.invokeMethod(InvokerHelper.java:92)\n\tat ClosureInClosureBug.main(D:\\groovy\\samples\\ClosureInClosureBug.groovy:31)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n\tat java.lang.reflect.Method.invoke(Method.java:324)\n\tat groovy.lang.MetaClass.doMethodInvoke(MetaClass.java:758)\n\tat groovy.lang.MetaClass.invokeStaticMethod(MetaClass.java:273)\n\tat org.codehaus.groovy.runtime.Invoker.invokeMethod(Invoker.java:121)\n\tat org.codehaus.groovy.runtime.InvokerHelper.invokeMethod(InvokerHelper.java:92)\n\tat groovy.lang.GroovyShell.run(GroovyShell.java:171)\n\tat groovy.lang.GroovyShell.main(GroovyShell.java:85)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n\tat java.lang.reflect.Method.invoke(Method.java:324)\n\tat org.codehaus.classworlds.Launcher.launchStandard(Launcher.java:410)\n\tat org.codehaus.classworlds.Launcher.launch(Launcher.java:344)\n\tat org.codehaus.classworlds.Launcher.main(Launcher.java:474)"
    ],
    [
        "GROOVY-211",
        "GROOVY-192",
        "Cand have a closure over the parameters of another closure c = { x |\n\t\tc1 = {\n\t\t\tprintln x[0]\n\t\t}\n\t\t\n\t\tc1()\n\t}\n\t\nc([1])\n\nproduces a null pointer exception\n\n\nc = { x |\n\t\txx = x\n\t\tc1 = {\n\t\t\tprintln xx[0]\n\t\t}\n\t\t\n\t\tc1()\n\t}\n\t\nc([1])\n\nworks",
        "AntBuilder should be able to access properties defined outside of its closures Here's an example:\n\npath = [ \"C:/dev\", \"C:/java\" ]\n\nant = new AntBuilder();\nant.echo(path);\n\nant.javac(srcdir:\"src\",\n          destdir:\"classes\") {\n  classpath {\n    for (p in path) {\n      pathelement(location:p)\n    }\n  }\n}\n\nWhat I'm trying to do is create a generic build script where I'm passing variables in from Java code, but executing the code gives me a error saying that the method 'classpath' does not exist (which isn't true, the actual error is that the property 'path' doesn't exist).\n\nAs a workaround, I subclassed AntBuilder and override getProperty() to return values from the script object.  This solution doesn't seem to work in the current CVS version."
    ],
    [
        "GROOVY-214",
        "GROOVY-131",
        "nested closures seem to have a problem with variable passing The following doesn't seem to work...\n\nx = 123\nnew File(\"output.txt\").withWriter { out |\n    new File(\"input.txt\").eachLine { line |\n\tout.write(line)\n\tout.write(x)\n\tout.newline()\n    }\n}",
        "Variable visibility issue within nested closures There is a nested closures variable scope visibility issue.\n(var a; closure-one(\"a is visible\" closure-two(\"a is not visible\"))\n\nI've attached a test case which illustrate that better : \nClosureInClosureBug.groovy\n\nDon't forget to uncomment the commented line to see the issue.\nOtherwise the test will pass of course !\n\nHere is the stacktrace I caught with this test case:\n\nCaught: groovy.lang.MissingPropertyException: No such property: text for class: ClosureInClosureBug$2\ngroovy.lang.MissingPropertyException: No such property: text for class: ClosureInClosureBug$2\n\tat groovy.lang.MetaClass.getProperty(MetaClass.java:398)\n\tat groovy.lang.Closure.getProperty(Closure.java:89)\n\tat org.codehaus.groovy.runtime.Invoker.getProperty(Invoker.java:437)\n\tat org.codehaus.groovy.runtime.InvokerHelper.getProperty(InvokerHelper.java:139)\n\tat ClosureInClosureBug$2.doCall(D:\\groovy\\samples\\ClosureInClosureBug.groovy)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n\tat java.lang.reflect.Method.invoke(Method.java:324)\n\tat groovy.lang.MetaClass.doMethodInvoke(MetaClass.java:758)\n\tat groovy.lang.MetaClass.invokeMethod(MetaClass.java:214)\n\tat groovy.lang.MetaClass.invokeMethod(MetaClass.java:188)\n\tat groovy.lang.Closure.invokeMethod(Closure.java:69)\n\tat org.codehaus.groovy.runtime.Invoker.invokeMethod(Invoker.java:114)\n\tat org.codehaus.groovy.runtime.InvokerHelper.invokeMethod(InvokerHelper.java:92)\n\tat groovy.lang.Closure.call(Closure.java:145)\n\tat org.codehaus.groovy.runtime.DefaultGroovyMethods.each(DefaultGroovyMethods.java:256)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n\tat java.lang.reflect.Method.invoke(Method.java:324)\n\tat groovy.lang.MetaClass.doMethodInvoke(MetaClass.java:758)\n\tat groovy.lang.MetaClass.invokeMethod(MetaClass.java:236)\n\tat org.codehaus.groovy.runtime.Invoker.invokeMethod(Invoker.java:127)\n\tat org.codehaus.groovy.runtime.InvokerHelper.invokeMethod(InvokerHelper.java:92)\n\tat ClosureInClosureBug$1.doCall(D:\\groovy\\samples\\ClosureInClosureBug.groovy:21)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n\tat java.lang.reflect.Method.invoke(Method.java:324)\n\tat groovy.lang.MetaClass.doMethodInvoke(MetaClass.java:758)\n\tat groovy.lang.MetaClass.invokeMethod(MetaClass.java:214)\n\tat groovy.lang.MetaClass.invokeMethod(MetaClass.java:188)\n\tat groovy.lang.Closure.invokeMethod(Closure.java:69)\n\tat org.codehaus.groovy.runtime.Invoker.invokeMethod(Invoker.java:114)\n\tat org.codehaus.groovy.runtime.InvokerHelper.invokeMethod(InvokerHelper.java:92)\n\tat groovy.lang.Closure.call(Closure.java:145)\n\tat org.codehaus.groovy.runtime.DefaultGroovyMethods.each(DefaultGroovyMethods.java:256)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n\tat java.lang.reflect.Method.invoke(Method.java:324)\n\tat groovy.lang.MetaClass.doMethodInvoke(MetaClass.java:758)\n\tat groovy.lang.MetaClass.invokeMethod(MetaClass.java:236)\n\tat org.codehaus.groovy.runtime.Invoker.invokeMethod(Invoker.java:127)\n\tat org.codehaus.groovy.runtime.InvokerHelper.invokeMethod(InvokerHelper.java:92)\n\tat ClosureInClosureBug.testInvisibleVariable(D:\\groovy\\samples\\ClosureInClosureBug.groovy:18)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n\tat java.lang.reflect.Method.invoke(Method.java:324)\n\tat groovy.lang.MetaClass.doMethodInvoke(MetaClass.java:758)\n\tat groovy.lang.MetaClass.invokeMethod(MetaClass.java:214)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n\tat java.lang.reflect.Method.invoke(Method.java:324)\n\tat groovy.lang.MetaClass.doMethodInvoke(MetaClass.java:758)\n\tat groovy.lang.MetaClass.invokeMethod(MetaClass.java:214)\n\tat org.codehaus.groovy.runtime.Invoker.invokeMethod(Invoker.java:127)\n\tat org.codehaus.groovy.runtime.InvokerHelper.invokeMethod(InvokerHelper.java:92)\n\tat ClosureInClosureBug.invokeMethod(D:\\groovy\\samples\\ClosureInClosureBug.groovy)\n\tat org.codehaus.groovy.runtime.Invoker.invokeMethod(Invoker.java:114)\n\tat org.codehaus.groovy.runtime.InvokerHelper.invokeMethod(InvokerHelper.java:92)\n\tat ClosureInClosureBug.main(D:\\groovy\\samples\\ClosureInClosureBug.groovy:31)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n\tat java.lang.reflect.Method.invoke(Method.java:324)\n\tat groovy.lang.MetaClass.doMethodInvoke(MetaClass.java:758)\n\tat groovy.lang.MetaClass.invokeStaticMethod(MetaClass.java:273)\n\tat org.codehaus.groovy.runtime.Invoker.invokeMethod(Invoker.java:121)\n\tat org.codehaus.groovy.runtime.InvokerHelper.invokeMethod(InvokerHelper.java:92)\n\tat groovy.lang.GroovyShell.run(GroovyShell.java:171)\n\tat groovy.lang.GroovyShell.main(GroovyShell.java:85)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n\tat java.lang.reflect.Method.invoke(Method.java:324)\n\tat org.codehaus.classworlds.Launcher.launchStandard(Launcher.java:410)\n\tat org.codehaus.classworlds.Launcher.launch(Launcher.java:344)\n\tat org.codehaus.classworlds.Launcher.main(Launcher.java:474)"
    ],
    [
        "GROOVY-214",
        "GROOVY-192",
        "nested closures seem to have a problem with variable passing The following doesn't seem to work...\n\nx = 123\nnew File(\"output.txt\").withWriter { out |\n    new File(\"input.txt\").eachLine { line |\n\tout.write(line)\n\tout.write(x)\n\tout.newline()\n    }\n}",
        "AntBuilder should be able to access properties defined outside of its closures Here's an example:\n\npath = [ \"C:/dev\", \"C:/java\" ]\n\nant = new AntBuilder();\nant.echo(path);\n\nant.javac(srcdir:\"src\",\n          destdir:\"classes\") {\n  classpath {\n    for (p in path) {\n      pathelement(location:p)\n    }\n  }\n}\n\nWhat I'm trying to do is create a generic build script where I'm passing variables in from Java code, but executing the code gives me a error saying that the method 'classpath' does not exist (which isn't true, the actual error is that the property 'path' doesn't exist).\n\nAs a workaround, I subclassed AntBuilder and override getProperty() to return values from the script object.  This solution doesn't seem to work in the current CVS version."
    ],
    [
        "GROOVY-214",
        "GROOVY-211",
        "nested closures seem to have a problem with variable passing The following doesn't seem to work...\n\nx = 123\nnew File(\"output.txt\").withWriter { out |\n    new File(\"input.txt\").eachLine { line |\n\tout.write(line)\n\tout.write(x)\n\tout.newline()\n    }\n}",
        "Cand have a closure over the parameters of another closure c = { x |\n\t\tc1 = {\n\t\t\tprintln x[0]\n\t\t}\n\t\t\n\t\tc1()\n\t}\n\t\nc([1])\n\nproduces a null pointer exception\n\n\nc = { x |\n\t\txx = x\n\t\tc1 = {\n\t\t\tprintln xx[0]\n\t\t}\n\t\t\n\t\tc1()\n\t}\n\t\nc([1])\n\nworks"
    ],
    [
        "GROOVY-233",
        "GROOVY-175",
        "super call in invokeMethod causes a VerifyError this fails on the last line: 'new C().duh()'\n\n=== here is the file ===\n\nclass A {\n        invokeMethod(String name, Object args) {\n                try {\n                        metaClass.invokeMethod(this, name, args)\n                } catch(MissingMethodException e) {\n                        println \"Missing method: ${name}\"\n                }\n        }\n}\nclass B extends A {\n        invokeMethod(String name, Object args) {\n                try {\n                        metaClass.invokeMethod(this, name, args)\n                } catch(MissingMethodException e) {\n                        println \"Missing method: ${name}\"\n                }\n        }\n}\nclass C extends A {\n        invokeMethod(String name, Object args) {\n                super.invokeMethod(name, args)\n        }\n}\n\nnew A().duh()\nnew B().duh()\nnew C().duh()\n\n=== here is the error === \n\nException in thread \"main\" java.lang.VerifyError: (class: C, method: invokeMethod signature: (Ljava/lang/String;Ljava/lang/Object;)Ljava/lang/Object;) Expecting to find unitialized object on stack\n        at java.lang.Class.forName0(Native Method)\n        at java.lang.Class.forName(Class.java:141)\n        at b.class$(b.groovy)\n        at b.run(b.groovy:26)\n        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n        at java.lang.reflect.Method.invoke(Method.java:324)\n        at groovy.lang.MetaClass.doMethodInvoke(MetaClass.java:765)\n        at groovy.lang.MetaClass.invokeMethod(MetaClass.java:214)\n        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n        at java.lang.reflect.Method.invoke(Method.java:324)\n        at groovy.lang.MetaClass.doMethodInvoke(MetaClass.java:765)\n        at groovy.lang.MetaClass.invokeMethod(MetaClass.java:214)\n        at org.codehaus.groovy.runtime.Invoker.invokeMethod(Invoker.java:130)\n        at org.codehaus.groovy.runtime.InvokerHelper.invokeMethod(InvokerHelper.java:98)\n        at b.invokeMethod(b.groovy)\n        at org.codehaus.groovy.runtime.Invoker.invokeMethod(Invoker.java:117)\n        at org.codehaus.groovy.runtime.InvokerHelper.invokeMethod(InvokerHelper.java:98)\n        at org.codehaus.groovy.runtime.InvokerHelper.runScript(InvokerHelper.java:311)\n        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n        at java.lang.reflect.Method.invoke(Method.java:324)\n        at groovy.lang.MetaClass.doMethodInvoke(MetaClass.java:765)\n        at groovy.lang.MetaClass.invokeStaticMethod(MetaClass.java:279)\n        at org.codehaus.groovy.runtime.Invoker.invokeMethod(Invoker.java:124)\n        at org.codehaus.groovy.runtime.InvokerHelper.invokeMethod(InvokerHelper.java:98)\n        at b.main(b.groovy)\n        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n        at java.lang.reflect.Method.invoke(Method.java:324)\n        at groovy.lang.MetaClass.doMethodInvoke(MetaClass.java:765)\n        at groovy.lang.MetaClass.invokeStaticMethod(MetaClass.java:279)\n        at org.codehaus.groovy.runtime.Invoker.invokeMethod(Invoker.java:124)\n        at org.codehaus.groovy.runtime.InvokerHelper.invokeMethod(InvokerHelper.java:98)\n        at groovy.lang.GroovyShell.run(GroovyShell.java:171)\n        at groovy.lang.GroovyShell.main(GroovyShell.java:85)\n        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n        at java.lang.reflect.Method.invoke(Method.java:324)\n        at org.codehaus.classworlds.Launcher.launchStandard(Launcher.java:410)\n        at org.codehaus.classworlds.Launcher.launch(Launcher.java:344)\n        at org.codehaus.classworlds.Launcher.main(Launcher.java:461)",
        "super-constructor calling bug Jason Thomas spotted this...\n\n\nI'm getting errors when over-riding a java constructor in a groovy \nclass:\n\nTestBase.java:\n\npublic class TestBase {\n    public TestBase(String s) {\n        System.out.println(\"calling TestBase constructor\");\n    }\n\n    public static void main(String[] args) {\n        new Test(\"string\");\n    }\n}\n\nTest.groovy:\n\nclass Test extends TestBase {\n    Test(String message) {\n        super(message)\n    }\n}\n\n\n\njava.lang.NoSuchMethodError: TestBase.<init>(Ljava/lang/Object;)V\n\tat Test.<init>(C:\\benchmark\\groovy\\Test.groovy:3)\n\tat TestBase.main(TestBase.java:7)\nException in thread \"main\""
    ],
    [
        "GROOVY-343",
        "GROOVY-293",
        "VerifyError (InconsistentStackHeight) on assignment to external variable from a scope nested inside a closure Running the attached script dies with with the following stack trace.  It works if I remove \"f.eachLine()\" and the following closure...\n\nException in thread \"main\" java.lang.VerifyError: (class: perry$3, method: doCal\nl signature: (Ljava/lang/Object;)Ljava/lang/Object;) Inconsistent stack height 1\n!= 0\n       at perry.run(perry.groovy:12)\n       at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n       [snip]\n\n-- \nC\u00e9dric\nhttp://beust.com/weblog\n\n\n\n\n\n\n\nimport java.io.File\nimport java.util.regex.*\n\ndir = new File(\"d:/public_html/cedric/perry/endless-armada\")\nout = new File(\"d:/t/endless-armada\")\n\nfor (i in 1100..1103) {\n  print \"${i} =====\\n\"\n  n = 2\n  prev = true\n  f = new File(dir, \"${i}.html\")\n  f.eachLine { line |\n    newLine = \"\"\n    p = Pattern.compile(\"11@\")\n    m = p.matcher(line)\n    if (line =~ \"11@\") {\n      if (prev) {\n        newLine = m.replaceAll(new Integer(i - 1).toString())\n      }\n      else {\n        newLine = m.replaceAll(new Integer(i + 1).toString())\n      }\n      prev = ! prev\n      print newLine + \"\\n\"\n    }\n  }\n}",
        "Exception thrown when assigning value to variable outside closure def isInRange(value)\n{\n   range = 0..3\n   result = false\n   range.each {e| if(e == value) result = true}\n   return result\n}\n\nprintln isInRange(3)\nprintln isInRange(4)\n------------\n\nThrows this exception:\n\n   Exception in thread \"main\" java.lang.VerifyError: (class: bug$1, method: doCall signature: (Ljava/lang/Object;)Ljava/lang/Object;)        Inconsistent stack height 1 != 0"
    ],
    [
        "GROOVY-359",
        "GROOVY-339",
        "Problems with numeric types (for example, 2.0D) 1> print 2.0D\n2> go\n20D\n\n1> print Math.sin(2.0D)\n2> go\n20D\n\n1> print Math.sin(2.0D.doubleValue())\n2> go\n20D\n\n1> print Math.sin(2.0.doubleValue())\n2> go\n0.9092974268256817\n\n\n\nAnother issue, but related.  If BigDecimal could be automatically coerced to double, float, etc., I wouldn't have the problems above.\n\n1> print Math.sin(2.0)\n2> go\nNo such method: sin for class: java.lang.Math with arguments: [2.0]",
        "Problem coercing 7/3 to double 1> println( Math.sin(7/3) )\n2> go\nNo such method: sin for class: java.lang.Math with arguments: [2.3333333333]\n\n1> println( Math.sin(2.3333333333) )\n2> go\n0.7230858817613498"
    ],
    [
        "GROOVY-362",
        "GROOVY-247",
        "synchronized keyword class Syn {\n\tpr() {\n\t \tsynchronized(this) {println 'hello'}\n\t}\n}\nnew Syn().pr()\n\n\nproduced:\n\njava.lang.VerifyError: (class: Syn, method: pr signature: ()Ljava/lang/Object;) Unable to pop operand off an empty stack",
        "support synchronized blocks synchronize (expression) {\n  ...\n}"
    ],
    [
        "GROOVY-404",
        "GROOVY-366",
        "MissingMethodException for rightShift on Integer println 1 >> 6\n\nresults in:\n\nCaught: groovy.lang.MissingMethodException: No such method: rightShift for class: java.lang.Integer with arguments: [6]\ngroovy.lang.MissingMethodException: No such method: rightShift for class: java.lang.Integer with arguments: [6]\n        at groovy.lang.MetaClass.invokeMethod(MetaClass.java:307)\n        at org.codehaus.groovy.runtime.Invoker.invokeMethod(Invoker.java:130)\n        at org.codehaus.groovy.runtime.InvokerHelper.invokeMethod(InvokerHelper.java:106)\n        at test6.run(test6.groovy)",
        "65 << 2 gets No such method: leftShift for class: java.lang.Integer with arguments: [2] >> is similarly afflicted"
    ],
    [
        "GROOVY-405",
        "GROOVY-387",
        "Can't generate bytecode for void return class VoidReturnTest { public void test() { return } }\n\nresults in:\n\nCaught: org.codehaus.groovy.classgen.ClassGeneratorException: Cannot generate bytecode for constant: class java.lang.Void of type: java.lang.Class",
        "can't return from void method I cannot return from a void method/function. For example:\n\ndef void testme() {\n   if(1==1)\n      return\n   else\n      println \"hi\"\n}\n\ntestme()\n\nThis will fail with this stack trace:\n\nCaught: org.codehaus.groovy.classgen.ClassGeneratorException: Cannot generate bytecode for constant: class java.lang.Void of type: java.lang.Class\norg.codehaus.groovy.classgen.ClassGeneratorException: Cannot generate bytecode for constant: class java.lang.Void of type: java.lang.Class\n        at org.codehaus.groovy.classgen.ClassGenerator.visitConstantExpression(ClassGenerator.java:1315)\n        at org.codehaus.groovy.ast.expr.ConstantExpression.visit(ConstantExpression.java:75)\n        at org.codehaus.groovy.classgen.ClassGenerator.visitAndAutobox(ClassGenerator.java:2639)\n        at org.codehaus.groovy.classgen.ClassGenerator.evaluateExpression(ClassGenerator.java:971)\n        at org.codehaus.groovy.classgen.ClassGenerator.visitReturnStatement(ClassGenerator.java:903)\n        at org.codehaus.groovy.ast.stmt.ReturnStatement.visit(ReturnStatement.java:70)\n        at org.codehaus.groovy.ast.CodeVisitorSupport.visitBlockStatement(CodeVisitorSupport.java:108)\n        at org.codehaus.groovy.ast.stmt.BlockStatement.visit(BlockStatement.java:79)\n        at org.codehaus.groovy.classgen.ClassGenerator.visitIfElse(ClassGenerator.java:545)\n        at org.codehaus.groovy.ast.stmt.IfStatement.visit(IfStatement.java:71)\n        at org.codehaus.groovy.ast.CodeVisitorSupport.visitBlockStatement(CodeVisitorSupport.java:108)\n        at org.codehaus.groovy.ast.stmt.BlockStatement.visit(BlockStatement.java:79)\n        at org.codehaus.groovy.classgen.ClassGenerator.visitMethod(ClassGenerator.java:346)\n        at org.codehaus.groovy.ast.ClassNode.visitContents(ClassNode.java:699)\n        at org.codehaus.groovy.classgen.ClassGenerator.visitClass(ClassGenerator.java:273)\n        at org.codehaus.groovy.classgen.CompilerFacade.generateClass(CompilerFacade.java:114)\n        at org.codehaus.groovy.classgen.CompilerFacade.parseClass(CompilerFacade.java:153)\n        at org.codehaus.groovy.classgen.CompilerFacade.parseClass(CompilerFacade.java:83)\n        at groovy.lang.GroovyClassLoader.parseClass(GroovyClassLoader.java:154)\n        at groovy.lang.GroovyClassLoader.parseClass(GroovyClassLoader.java:108)\n        at groovy.lang.GroovyShell.run(GroovyShell.java:182)\n        at groovy.lang.GroovyShell.main(GroovyShell.java:88)\n        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n        at java.lang.reflect.Method.invoke(Method.java:324)\n        at org.codehaus.classworlds.Launcher.launchStandard(Launcher.java:410)\n        at org.codehaus.classworlds.Launcher.launch(Launcher.java:344)\n        at org.codehaus.classworlds.Launcher.main(Launcher.java:474)"
    ],
    [
        "GROOVY-410",
        "GROOVY-309",
        "GroovyShell.evaluate p = [1,2,3]\npp = '' + p\nobj = new GroovyShell().evaluate(pp)\nprint obj\n\n-- the above works\n\np = [1,2,3]\nobj = new GroovyShell().evaluate(\"${p}\")\nprint obj\n\n-- produces argument mismatch exception. \n\nThe reason seems to be that the evaluate() takes a String, rather than GString. The Strange thing is that it somehow still prints the value, in spite of the exception.",
        "GString is not always converted to String when calling a Java method import org.xml.sax.helpers.AttributesImpl\n\nkey = \"a\"\nattributes = new AttributesImpl()\n\nattributes.addAttribute(\"\", \"\", \"${key}\", \"\", \"\")\n\n\nthrows:\n\njava.lang.IllegalArgumentException: argument type mismatch\n\n\nattributes.addAttribute(\"\", \"\", \"${key}\".toString(), \"\", \"\")\n\nworks"
    ],
    [
        "GROOVY-420",
        "GROOVY-353",
        "IncompatibleClassChangeError when accessing an undefined variable running \n\n\nclass C {\n\tstatic main(args) {\n\t\tprintln a\n\t}\n}\n\ngives\n\nException in thread \"main\" java.lang.IncompatibleClassChangeError\n\tat org.codehaus.groovy.runtime.InvokerHelper.getGroovyObjectProperty(InvokerHelper.java:197)\n\tat C.main(test.groovy)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n\tat java.lang.reflect.Method.invoke(Method.java:324)\n\tat org.codehaus.groovy.runtime.ReflectionMetaMethod.invoke(ReflectionMetaMethod.java:63)\n\tat groovy.lang.MetaClass.doMethodInvoke(MetaClass.java:996)\n\tat groovy.lang.MetaClass.invokeStaticMethod(MetaClass.java:365)\n\tat org.codehaus.groovy.runtime.Invoker.invokeMethod(Invoker.java:124)\n\tat org.codehaus.groovy.runtime.InvokerHelper.invokeMethod(InvokerHelper.java:106)\n\tat groovy.lang.GroovyShell.run(GroovyShell.java:222)\n\tat groovy.lang.GroovyShell.main(GroovyShell.java:92)",
        "IncompatibleClassChangeError on wrong variable name class A {\n  static main(args) {\n    blah = [5,6]\n \n    println(blahs.min())\n  }\n}\n\n\ngives\n\nException in thread \"main\" java.lang.IncompatibleClassChangeError\n        at A.main(test1.groovy:3)\n        at groovy.lang.GroovyShell.run(GroovyShell.java:173)\n        at groovy.lang.GroovyShell.run(GroovyShell.java:142)\n        at groovy.ui.GroovyMain.processOnce(GroovyMain.java:321)\n        at groovy.ui.GroovyMain.run(GroovyMain.java:211)\n        at groovy.ui.GroovyMain.process(GroovyMain.java:197)\n        at groovy.ui.GroovyMain.main(GroovyMain.java:120)"
    ],
    [
        "GROOVY-432",
        "GROOVY-210",
        "Groovy Reflection problem for unknown classes Groovy can't reflect classes which are unknown to the its ClassLoader when using MetaClass.setUseReflection(false) even if it could cast to a known interface.\n\nFor example Tomcat will replace System.out with a custom PrintStream instead of the default and when you try to use System.out and setUseReflection is set to false every call to System.out will fail with:\n\njava.lang.NoClassDefFoundError: org/apache/tomcat/util/log/SystemLogHandler\n\tgjdk.org.apache.tomcat.util.log.SystemLogHandler_GroovyReflector.invoke(SystemLogHandler_GroovyReflector.java)\n\tgroovy.lang.MetaMethod.invoke(MetaMethod.java:110)\n\tgroovy.lang.MetaClass.doMethodInvoke(MetaClass.java:996)\n\nI packaged a complete war file to show the behaviour.\n\nIt can be found at http://home.mx4k.com/test.war\n\nYou should be able to call: http://yourhost/test/test.groovy to see the problem. If you use the default groovy.servlet.GroovyServlet the example works but I couldn't come up with an \"easier\" test to show this behaviour.",
        "System.out and classloader issues under Tomcat I'm seeing what seems to be a regression between Groovy-1.0-beta-3 and Groovy-1.0-beta-4-SNAPSHOT (built off the absolute latest CVS).  I'm using a Groovy script to assemble a Picocontainer under the Nanocontainer servlet setup in web.xml ( See... http://docs.codehaus.org/display/NANO/NanoContainer+Servlet ).  Configuring as described in that doc works fine under both beta3 and beta4-snapshot except when trying to do a System.out.println(\"I got here\") debugging statement.  With beta3, I see the debugging output just fine under Tomcat.  With beta4-snapshot, I get the following exception which appears to be some classloading issue.  Hopefully this will be enough info for the Groovy developers to determine the cause and fix the issue....\n\n\n2004-02-20 01:18:11 StandardWrapperValve[jsp]: Servlet.service() for servlet jsp threw exception\njava.lang.NoClassDefFoundError: org/apache/tomcat/util/log/SystemLogHandler\n\tat org.apache.tomcat.util.log.SystemLogHandler$GroovyReflector.invoke(SystemLogHandler$GroovyReflector.java)\n\tat groovy.lang.MetaMethod.invoke(MetaMethod.java:84)\n\tat groovy.lang.MetaClass.doMethodInvoke(MetaClass.java:830)\n\tat groovy.lang.MetaClass.invokeMethod(MetaClass.java:242)\n\tat org.codehaus.groovy.runtime.Invoker.invokeMethod(Invoker.java:130)\n\tat org.codehaus.groovy.runtime.InvokerHelper.invokeMethod(InvokerHelper.java:101)\n\tat nanocontainer.run(nanocontainer.groovy:15)\n\tat org.nanocontainer.script.groovy.GroovyContainerBuilder.createContainerFromScript(GroovyContainerBuilder.java:57)\n\tat org.nanocontainer.script.ScriptedContainerBuilder.createContainer(ScriptedContainerBuilder.java:37)\n\tat org.nanocontainer.integrationkit.LifecycleContainerBuilder.buildContainer(LifecycleContainerBuilder.java:24)\n\tat org.nanocontainer.servlet.ServletRequestContainerLauncher.startContainer(ServletRequestContainerLauncher.java:48)\n\tat org.nanocontainer.servlet.ServletRequestContainerFilter.doFilter(ServletRequestContainerFilter.java:36)\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:233)\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:204)\n\tat org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:257)\n\tat org.apache.catalina.core.StandardValveContext.invokeNext(StandardValveContext.java:151)\n\tat org.apache.catalina.core.StandardPipeline.invoke(StandardPipeline.java:564)\n\tat org.apache.catalina.core.StandardContextValve.invokeInternal(StandardContextValve.java:245)\n\tat org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:199)\n\tat org.apache.catalina.core.StandardValveContext.invokeNext(StandardValveContext.java:151)\n\tat org.apache.catalina.core.StandardPipeline.invoke(StandardPipeline.java:564)\n\tat org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:195)\n\tat org.apache.catalina.core.StandardValveContext.invokeNext(StandardValveContext.java:151)\n\tat org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:164)\n\tat org.apache.catalina.core.StandardValveContext.invokeNext(StandardValveContext.java:149)\n\tat org.apache.catalina.core.StandardPipeline.invoke(StandardPipeline.java:564)\n\tat org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:156)\n\tat org.apache.catalina.core.StandardValveContext.invokeNext(StandardValveContext.java:151)\n\tat org.apache.catalina.core.StandardPipeline.invoke(StandardPipeline.java:564)\n\tat org.apache.catalina.core.ContainerBase.invoke(ContainerBase.java:972)\n\tat org.apache.coyote.tomcat5.CoyoteAdapter.service(CoyoteAdapter.java:206)\n\tat org.apache.coyote.http11.Http11Processor.process(Http11Processor.java:828)\n\tat org.apache.coyote.http11.Http11Protocol$Http11ConnectionHandler.processConnection(Http11Protocol.java:700)\n\tat org.apache.tomcat.util.net.TcpWorkerThread.runIt(PoolTcpEndpoint.java:584)\n\tat org.apache.tomcat.util.threads.ThreadPool$ControlRunnable.run(ThreadPool.java:683)\n\tat java.lang.Thread.run(Thread.java:534)\n\n\nJake"
    ],
    [
        "GROOVY-489",
        "GROOVY-413",
        "Fix bin/groovy shell script The shell script is broken.\n\nE.g. if you run groovy without an argument you get shell errors.\n\nThe fix is to change:\n\nif [ $1 = \"-cp\" ] || [ $1 = \"-classpath\" ]; then\n\nto (add the quotes)\n\nif [ \"$1\" = \"-cp\" ] || [ \"$1\" = \"-classpath\" ]; then\n\nThen can also change:\n\nif [ \"x$GROOVY_HOME\" = \"x\" ]; then\n\nto:\n\nif [ \"$GROOVY_HOME\" = \"\" ]; then\n\n(also used in other places)\n\nDion\n\nps. the weird thing is that most of the groovy guys are on PowerBooks. How come you aren't running into this? :)",
        "groovy shell script error messages when no args Typing just \"groovy\" on the command line with no arguments spews the following error messages:\n\n/usr/local/projects/Java/groovy/bin/groovy: line 45: [: =: unary operator expected\n/usr/local/projects/Java/groovy/bin/groovy: line 45: [: =: unary operator expected\nUsage: Groovy groovyScript [arguments]\n\nThe script should not barf on line 45 :-)"
    ],
    [
        "GROOVY-517",
        "GROOVY-516",
        "Groovy editor and builder do not work in post-M7 Post-M7 builds of Eclipse include a variety of minor API changes. As a result of\nthese changes, both the Groovy editor and the Groovy builder from the Eclipse plugin\ndo not work in post-M7. Since M7 was a bit of a disaster of a release for Eclipse, \nhaving the plugin only work in M7 is a serious problem.",
        "Groovy editor and builder do not work in post-M7 "
    ],
    [
        "GROOVY-669",
        "GROOVY-564",
        "groovyc creates class files that does not verify (java.lang.VerifyError) I run \n  groovy DoesNotVerify.groovy\nwhere the file DoesNotVerify.groovy has the following contents:\n\n----\npublic class DoesNotVerify {\n    public void method(double a, double b) {}\n    public static void main(String[] args) {\n        println \"Does not run with JVM 1.4\";\n    }\n}\n----\n\nThe command:\n  java DoesNotVerify\ngives the output:\n  Exception in thread \"main\" java.lang.VerifyError: (class:  \n  DoesNotVerify, method: method signature: (\n  DD)V) Register pair 2/3 contains wrong type",
        "Verify error with polymorphic functions class MyClass {\n\tf(String s, int i1, int i2) {\n\t\tprintln \"int\"\n\t}\n\t\n\tf(String s, long l1, long l2) {\n\t\tprintln \"long\"\n\t}\n\n\tstatic main(args) {\n\t\tf(\"hello\", 1, 2)\n\t}\n}\n\nproduces:\n\nException in thread \"main\" java.lang.VerifyError: (class: MyClass, method: f signature: (Ljava/lang/String;JJ)Ljava/lang/Object;) Register pair 3/4 contains wrong type"
    ],
    [
        "GROOVY-704",
        "GROOVY-564",
        "Primitive function arguments cause VerifyError The following code:\n\ndef foo(double x,  y) {\n   println \"x: \"+x\n   println \"y: \"+y\n}\n\nfoo(10.0d, 0)\n\ncauses Groovy to complain that the value passed to y is the wrong type.  Making foo a member function of a class (in another file), and giving it three arguments, the function runs but y is null and the value that should go to y, goes to the third arg.  At one point I had it triggering an internal error in the JVM.\n\nChanging double to Double fixes the problem.",
        "Verify error with polymorphic functions class MyClass {\n\tf(String s, int i1, int i2) {\n\t\tprintln \"int\"\n\t}\n\t\n\tf(String s, long l1, long l2) {\n\t\tprintln \"long\"\n\t}\n\n\tstatic main(args) {\n\t\tf(\"hello\", 1, 2)\n\t}\n}\n\nproduces:\n\nException in thread \"main\" java.lang.VerifyError: (class: MyClass, method: f signature: (Ljava/lang/String;JJ)Ljava/lang/Object;) Register pair 3/4 contains wrong type"
    ],
    [
        "GROOVY-704",
        "GROOVY-669",
        "Primitive function arguments cause VerifyError The following code:\n\ndef foo(double x,  y) {\n   println \"x: \"+x\n   println \"y: \"+y\n}\n\nfoo(10.0d, 0)\n\ncauses Groovy to complain that the value passed to y is the wrong type.  Making foo a member function of a class (in another file), and giving it three arguments, the function runs but y is null and the value that should go to y, goes to the third arg.  At one point I had it triggering an internal error in the JVM.\n\nChanging double to Double fixes the problem.",
        "groovyc creates class files that does not verify (java.lang.VerifyError) I run \n  groovy DoesNotVerify.groovy\nwhere the file DoesNotVerify.groovy has the following contents:\n\n----\npublic class DoesNotVerify {\n    public void method(double a, double b) {}\n    public static void main(String[] args) {\n        println \"Does not run with JVM 1.4\";\n    }\n}\n----\n\nThe command:\n  java DoesNotVerify\ngives the output:\n  Exception in thread \"main\" java.lang.VerifyError: (class:  \n  DoesNotVerify, method: method signature: (\n  DD)V) Register pair 2/3 contains wrong type"
    ],
    [
        "GROOVY-800",
        "GROOVY-247",
        "VerifyError with synchronized The following code:\n\nbubbles = new Object()\n\nsynchronized (bubbles ) {\n}\n\nProduces:\n\nCaught: java.lang.VerifyError: (class: bug, method: run signature: ()Ljava/lang/Object;) Unable to pop operand off an empty stack\n\nIf synchronized isn't implemented yet, it should give a \"Not Implemented\" error.  Basically, we should never get a VerifyError, since that's an internal inconsistency.\n\n",
        "support synchronized blocks synchronize (expression) {\n  ...\n}"
    ],
    [
        "GROOVY-800",
        "GROOVY-362",
        "VerifyError with synchronized The following code:\n\nbubbles = new Object()\n\nsynchronized (bubbles ) {\n}\n\nProduces:\n\nCaught: java.lang.VerifyError: (class: bug, method: run signature: ()Ljava/lang/Object;) Unable to pop operand off an empty stack\n\nIf synchronized isn't implemented yet, it should give a \"Not Implemented\" error.  Basically, we should never get a VerifyError, since that's an internal inconsistency.\n\n",
        "synchronized keyword class Syn {\n\tpr() {\n\t \tsynchronized(this) {println 'hello'}\n\t}\n}\nnew Syn().pr()\n\n\nproduced:\n\njava.lang.VerifyError: (class: Syn, method: pr signature: ()Ljava/lang/Object;) Unable to pop operand off an empty stack"
    ],
    [
        "GROOVY-881",
        "GROOVY-638",
        "can't call this(string) in constructor // demo.groovy, below file is OK\nclass B {\n\tpublic B(String s) { println s }\n\tpublic void communicate(){println \"hello\"}\n}\n\nb = new B(\"SSSS\");\nb.communicate();\n//end of demo.groovy\n\n//another demo.groovy, below file is invalid\nclass B {\n\tpublic B() {this(\"default\")}\n\tpublic B(String s) { println s }\n\tpublic void communicate(){println \"hello\"}\n}\n\nb = new B(\"SSSS\");\nb.communicate();\n//end of demo.groovy\n\n\n//below is the exception\ne:\\groovy\\demo.groovy: -1: PARSER BUG: Tried to configure org.codehaus.groovy.ast.expr.ArgumentListExpression with null Node. File: e:\\groovy\\demo.groovy @ line -1, column -1.org.codehaus.groovy.antlr.ASTParserException: PARSER BUG: Tried to configure org.codehaus.groovy.ast.expr.ArgumentListExpression with null Node. File: e:\\groovy\\demo.groovy @ line -1, column -1.\n\tat org.codehaus.groovy.antlr.AntlrParserPlugin.buildAST(AntlrParserPlugin.java:129)\n\tat org.codehaus.groovy.control.SourceUnit.convert(SourceUnit.java:315)\n\tat org.codehaus.groovy.control.CompilationUnit$2.call(CompilationUnit.java:544)\n\tat org.codehaus.groovy.control.CompilationUnit.applyToSourceUnits(CompilationUnit.java:800)\n\tat org.codehaus.groovy.control.CompilationUnit.convert(CompilationUnit.java:531)\n\tat org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:460)\n\tat groovy.lang.GroovyClassLoader.parseClass(GroovyClassLoader.java:244)\n\tat groovy.lang.GroovyClassLoader.parseClass(GroovyClassLoader.java:209)\n\tat groovy.lang.GroovyClassLoader.parseClass(GroovyClassLoader.java:159)\n\tat groovy.lang.GroovyShell$1.run(GroovyShell.java:260)\n\tat java.security.AccessController.doPrivileged(Native Method)\n\tat groovy.lang.GroovyShell.run(GroovyShell.java:258)\n\tat groovy.lang.GroovyShell.run(GroovyShell.java:202)\n\tat groovy.ui.GroovyMain.processOnce(GroovyMain.java:416)\n\tat groovy.ui.GroovyMain.run(GroovyMain.java:249)\n\tat groovy.ui.GroovyMain.process(GroovyMain.java:235)\n\tat groovy.ui.GroovyMain.main(GroovyMain.java:138)\n\tat org.codehaus.groovy.tools.GroovyStarter.main(GroovyStarter.java:92)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n\tat java.lang.reflect.Method.invoke(Method.java:324)\n\tat org.codehaus.classworlds.Launcher.launchEnhanced(Launcher.java:315)\n\tat org.codehaus.classworlds.Launcher.launch(Launcher.java:255)\n\tat org.codehaus.classworlds.Launcher.mainWithExitCode(Launcher.java:429)\n\tat org.codehaus.classworlds.Launcher.main(Launcher.java:375)\nCaused by: org.codehaus.groovy.antlr.ASTRuntimeException: PARSER BUG: Tried to configure org.codehaus.groovy.ast.expr.ArgumentListExpression with null Node\n\tat org.codehaus.groovy.antlr.AntlrParserPlugin.configureAST(AntlrParserPlugin.java:2015)\n\tat org.codehaus.groovy.antlr.AntlrParserPlugin.arguments(AntlrParserPlugin.java:1710)\n\tat org.codehaus.groovy.antlr.AntlrParserPlugin.constructorCallExpression(AntlrParserPlugin.java:1662)\n\tat org.codehaus.groovy.antlr.AntlrParserPlugin.expressionSwitch(AntlrParserPlugin.java:1017)\n\tat org.codehaus.groovy.antlr.AntlrParserPlugin.expression(AntlrParserPlugin.java:987)\n\tat org.codehaus.groovy.antlr.AntlrParserPlugin.statement(AntlrParserPlugin.java:705)\n\tat org.codehaus.groovy.antlr.AntlrParserPlugin.statementListNoChild(AntlrParserPlugin.java:721)\n\tat org.codehaus.groovy.antlr.AntlrParserPlugin.statementList(AntlrParserPlugin.java:714)\n\tat org.codehaus.groovy.antlr.AntlrParserPlugin.constructorDef(AntlrParserPlugin.java:385)\n\tat org.codehaus.groovy.antlr.AntlrParserPlugin.objectBlock(AntlrParserPlugin.java:306)\n\tat org.codehaus.groovy.antlr.AntlrParserPlugin.classDef(AntlrParserPlugin.java:288)\n\tat org.codehaus.groovy.antlr.AntlrParserPlugin.convertGroovy(AntlrParserPlugin.java:150)\n\tat org.codehaus.groovy.antlr.AntlrParserPlugin.buildAST(AntlrParserPlugin.java:126)\n\t... 25 more\n\n1 Error\n\n",
        "MissingMethodException while using 'this(aString)' Java construct. I am having the following when trying to run a program:\n\nX-----------------------------------------------------\ngroovy.lang.MissingMethodException: No signature of method com.svihar.groovy.A.doCall() is applicable for argument types: (java.lang.String) values: []\nat groovy.lang.MetaClass.invokeMethod(MetaClass.java:318)\n-----------------------------------------------------X\n\nI have isolated the problem into the following snippet:\nX-----------------------------------------------------\npackage com.svihar.groovy\npublic class A {\n\tpublic A() {this(\"\");}\n\tpublic A(String a) {}\n\tpublic void communicate() {\n\t\tSystem.out.println(\"Communicate\");\n\t}\n}\nclass B {\n\tpublic B() {this('')}\n\tpublic B(String a) {}\n\tcommunicate(){println \"heelo\"}\n}\n\na = new A()\na.communicate();\n\nb = new B();\nb.communicate();\n-----------------------------------------------------X\n\nClass A represents a valid Java class and class B represents\nits Groovy equivalent. Both classes have problem in executing.\n\nClass A works as expected in standard JVM."
    ],
    [
        "GROOVY-886",
        "GROOVY-584",
        "each(){} throws NPE when called on a Java Object[], that contains String[]'s with null entries Say you have a Java Class like\n\npublic class SomeClass {\n    public Object[] anArrayOfStringArraysWorkaround(){\n        return new Object[]{ new String[]{\"whatever\",null}};\n    }\n}\n\nthen the following Groovy code fails with NPE\n\npublic class MultiDimArraysTest extends GroovyTestCase {\n    void testCallTwoDimStringArrayWorkaroundWithNull(){\n        def someArrayOfStringArrays =  new SomeClass().anArrayOfStringArraysWorkaround()\n        assert 1 == someArrayOfStringArrays.size()\n        assert \"whatever\" == someArrayOfStringArrays[0][0]\n        someArrayOfStringArrays.each(){ assert it}                // throws NPE !!\n    }\n}\n\nwhile the iteration with \"for\" works:\n\npublic class MultiDimArraysTest extends GroovyTestCase {\n    void testCallTwoDimStringArrayWorkaround(){\n        def someArrayOfStringArrays =  new SomeClass().anArrayOfStringArraysWorkaround()\n        assert 1 == someArrayOfStringArrays.size()\n        assert \"whatever\" == someArrayOfStringArrays[0][0]\n        for (i in 0..<someArrayOfStringArrays.size()) {\n            assert someArrayOfStringArrays[i]\n        }\n    }\n}\n\nThe above TestCase will be committed.",
        "Exception passing array into Closure (from the mailing list):\n\nI wrote:\n\n-- script --\nc1 = new Class[] { Exception.class, Throwable.class }\nc2 = new Class[] { IllegalStateException.class }\nprintln (c1)\nprintln (c2)\n[c1, c2].each {println(it)}\n\n-- output --\n[Ljava.lang.Class;@14da8f4\n[Ljava.lang.Class;@fd68b1\nIncorrect arguments to closure: CommandLine4$_run_closure1@10a2d64.\nExpected: [class java.lang.Object], actual: [class java.lang.Exception,\nclass java.lang.Throwable]\n\n\nJohn Wilson responded:\n\nIt's a bug :)\n\nThe closure code is getting confused into thinking that you are calling it with Exception.class, Throwable.class as parameters."
    ],
    [
        "GROOVY-888",
        "GROOVY-584",
        "Object[] vs int[] // This works fine.\nint[] n1 = [1, 2, 3]\nint[] n2 = [100, 200]\ndef n = [n1, n2]\nn.each { println( it ) }\n\n\n// But, this geneates an NPE.\nObject[] n1 = [1, 2, 3]\nObject[] n2 = [100, 200]\ndef n = [n1, n2]\nn.each { println( it ) }\n\n\nCaught: java.lang.NullPointerException\njava.lang.NullPointerException\n        at groovy.ui.GroovyMain.run(GroovyMain.java:267)\n        at groovy.ui.GroovyMain.process(GroovyMain.java:235)\n        at groovy.ui.GroovyMain.main(GroovyMain.java:138)\n        at org.codehaus.groovy.tools.GroovyStarter.main(GroovyStarter.java:92)\n        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n        at java.lang.reflect.Method.invoke(Method.java:324)\n        at org.codehaus.classworlds.Launcher.launchEnhanced(Launcher.java:315)\n        at org.codehaus.classworlds.Launcher.launch(Launcher.java:255)\n        at org.codehaus.classworlds.Launcher.mainWithExitCode(Launcher.java:429)\n        at org.codehaus.classworlds.Launcher.main(Launcher.java:375)\n",
        "Exception passing array into Closure (from the mailing list):\n\nI wrote:\n\n-- script --\nc1 = new Class[] { Exception.class, Throwable.class }\nc2 = new Class[] { IllegalStateException.class }\nprintln (c1)\nprintln (c2)\n[c1, c2].each {println(it)}\n\n-- output --\n[Ljava.lang.Class;@14da8f4\n[Ljava.lang.Class;@fd68b1\nIncorrect arguments to closure: CommandLine4$_run_closure1@10a2d64.\nExpected: [class java.lang.Object], actual: [class java.lang.Exception,\nclass java.lang.Throwable]\n\n\nJohn Wilson responded:\n\nIt's a bug :)\n\nThe closure code is getting confused into thinking that you are calling it with Exception.class, Throwable.class as parameters."
    ],
    [
        "GROOVY-888",
        "GROOVY-886",
        "Object[] vs int[] // This works fine.\nint[] n1 = [1, 2, 3]\nint[] n2 = [100, 200]\ndef n = [n1, n2]\nn.each { println( it ) }\n\n\n// But, this geneates an NPE.\nObject[] n1 = [1, 2, 3]\nObject[] n2 = [100, 200]\ndef n = [n1, n2]\nn.each { println( it ) }\n\n\nCaught: java.lang.NullPointerException\njava.lang.NullPointerException\n        at groovy.ui.GroovyMain.run(GroovyMain.java:267)\n        at groovy.ui.GroovyMain.process(GroovyMain.java:235)\n        at groovy.ui.GroovyMain.main(GroovyMain.java:138)\n        at org.codehaus.groovy.tools.GroovyStarter.main(GroovyStarter.java:92)\n        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n        at java.lang.reflect.Method.invoke(Method.java:324)\n        at org.codehaus.classworlds.Launcher.launchEnhanced(Launcher.java:315)\n        at org.codehaus.classworlds.Launcher.launch(Launcher.java:255)\n        at org.codehaus.classworlds.Launcher.mainWithExitCode(Launcher.java:429)\n        at org.codehaus.classworlds.Launcher.main(Launcher.java:375)\n",
        "each(){} throws NPE when called on a Java Object[], that contains String[]'s with null entries Say you have a Java Class like\n\npublic class SomeClass {\n    public Object[] anArrayOfStringArraysWorkaround(){\n        return new Object[]{ new String[]{\"whatever\",null}};\n    }\n}\n\nthen the following Groovy code fails with NPE\n\npublic class MultiDimArraysTest extends GroovyTestCase {\n    void testCallTwoDimStringArrayWorkaroundWithNull(){\n        def someArrayOfStringArrays =  new SomeClass().anArrayOfStringArraysWorkaround()\n        assert 1 == someArrayOfStringArrays.size()\n        assert \"whatever\" == someArrayOfStringArrays[0][0]\n        someArrayOfStringArrays.each(){ assert it}                // throws NPE !!\n    }\n}\n\nwhile the iteration with \"for\" works:\n\npublic class MultiDimArraysTest extends GroovyTestCase {\n    void testCallTwoDimStringArrayWorkaround(){\n        def someArrayOfStringArrays =  new SomeClass().anArrayOfStringArraysWorkaround()\n        assert 1 == someArrayOfStringArrays.size()\n        assert \"whatever\" == someArrayOfStringArrays[0][0]\n        for (i in 0..<someArrayOfStringArrays.size()) {\n            assert someArrayOfStringArrays[i]\n        }\n    }\n}\n\nThe above TestCase will be committed."
    ],
    [
        "GROOVY-918",
        "GROOVY-534",
        "Cannot set outside variables from within nested closures You cannot set variables more than one closure aware from their scope:\n\ndef t = 2;\n[1].each {\n     [1].each { \n           t = 1;\n     }\n}\nprintln t;\n\nThis currently prints 0.\n",
        "Nested closures - variable scope problem output = \"a\"\n[1,1,1].each {\n  output = output + \"b\"\n  [1,1,1].each {\n    output = output + \"c\"\n  }\n}\nprint output\n\nI expected \"abcccbcccbccc\" but I get \"abbb\""
    ],
    [
        "GROOVY-947",
        "GROOVY-247",
        "VerifyError with Runnable.run and synchronized wait()-notify see GroovyMethodsTest\n\nthe Runnable definition\n\nclass Interruptor implements Runnable{\n    @Property caller\n    void run(){\n        Thread.currentThread().sleep(100) // enforce yield\n        synchronized(caller){\n            caller.wait()\n            caller.notifyAll()\n        }\n    }\n}\n\nthrows the VerifyError when called as\n\n        new Thread(new Interruptor(caller:this)).start()\n\nplease also enable the disabled_test* methods after fixing.\n",
        "support synchronized blocks synchronize (expression) {\n  ...\n}"
    ],
    [
        "GROOVY-947",
        "GROOVY-362",
        "VerifyError with Runnable.run and synchronized wait()-notify see GroovyMethodsTest\n\nthe Runnable definition\n\nclass Interruptor implements Runnable{\n    @Property caller\n    void run(){\n        Thread.currentThread().sleep(100) // enforce yield\n        synchronized(caller){\n            caller.wait()\n            caller.notifyAll()\n        }\n    }\n}\n\nthrows the VerifyError when called as\n\n        new Thread(new Interruptor(caller:this)).start()\n\nplease also enable the disabled_test* methods after fixing.\n",
        "synchronized keyword class Syn {\n\tpr() {\n\t \tsynchronized(this) {println 'hello'}\n\t}\n}\nnew Syn().pr()\n\n\nproduced:\n\njava.lang.VerifyError: (class: Syn, method: pr signature: ()Ljava/lang/Object;) Unable to pop operand off an empty stack"
    ],
    [
        "GROOVY-947",
        "GROOVY-800",
        "VerifyError with Runnable.run and synchronized wait()-notify see GroovyMethodsTest\n\nthe Runnable definition\n\nclass Interruptor implements Runnable{\n    @Property caller\n    void run(){\n        Thread.currentThread().sleep(100) // enforce yield\n        synchronized(caller){\n            caller.wait()\n            caller.notifyAll()\n        }\n    }\n}\n\nthrows the VerifyError when called as\n\n        new Thread(new Interruptor(caller:this)).start()\n\nplease also enable the disabled_test* methods after fixing.\n",
        "VerifyError with synchronized The following code:\n\nbubbles = new Object()\n\nsynchronized (bubbles ) {\n}\n\nProduces:\n\nCaught: java.lang.VerifyError: (class: bug, method: run signature: ()Ljava/lang/Object;) Unable to pop operand off an empty stack\n\nIf synchronized isn't implemented yet, it should give a \"Not Implemented\" error.  Basically, we should never get a VerifyError, since that's an internal inconsistency.\n\n"
    ],
    [
        "GROOVY-966",
        "GROOVY-963",
        "StringBuffer getAt throws RuntimeError: Ambigous Method overloading x = '0123' <<''\nx[0..2]\nthrows RuntimeError: Ambigous Method overloading",
        "provide StringBuffer.putAt(Range) analogous to List.putAt(Range) list = [0,1,2,3]\nlist[0..2] = ['x']\n\nworks fine while\n\nx = '0123' <<''\nx[0..2] = 'x'\n\ndoesn't\n\nchange comment: sorry I started this issue with \"String\" it should have been \"StringBuffer\""
    ],
    [
        "GROOVY-994",
        "GROOVY-638",
        "PARSER BUG: Tried to configure ArgumentListExpression with null Node //demo.groovy \n\npublic class A { \npublic A() {this(\"\");} \npublic A(String a) {} \npublic void communicate() { \nSystem.out.println(\"Communicate\"); \n} \n} \nclass B { \npublic B() {this('')} \npublic B(String a) {} \nvoid communicate(){println \"heelo\"} \n} \n\na = new A() \na.communicate(); \n\nb = new B(); \nb.communicate(); \n\n//end of demo \n\nrun the file and get the following error: \n\ne:\\groovy\\demo.groovy: -1: PARSER BUG: Tried to configure org.codehaus.groovy.ast.expr.ArgumentListExpression with null Node. File: e:\\groovy\\demo.groovy @ line -1, column -1.org.codehaus.groovy.antlr.ASTParserException: PARSER BUG: Tried to configure org.codehaus.groovy.ast.expr.ArgumentListExpression with null Node. File: e:\\groovy\\demo.groovy @ line -1, column -1. \nat org.codehaus.groovy.antlr.AntlrParserPlugin.buildAST(AntlrParserPlugin.java:176) \nat org.codehaus.groovy.control.SourceUnit.convert(SourceUnit.java:315) \nat org.codehaus.groovy.control.CompilationUnit$2.call(CompilationUnit.java:536) \nat org.codehaus.groovy.control.CompilationUnit.applyToSourceUnits(CompilationUnit.java:792) \nat org.codehaus.groovy.control.CompilationUnit.convert(CompilationUnit.java:523) \nat org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:452) \nat groovy.lang.GroovyClassLoader.parseClass(GroovyClassLoader.java:258) \nat groovy.lang.GroovyClassLoader.parseClass(GroovyClassLoader.java:221) \nat groovy.lang.GroovyClassLoader.parseClass(GroovyClassLoader.java:171) \nat groovy.lang.GroovyShell$1.run(GroovyShell.java:266) \nat java.security.AccessController.doPrivileged(Native Method) \nat groovy.lang.GroovyShell.run(GroovyShell.java:264) \nat groovy.lang.GroovyShell.run(GroovyShell.java:208) \nat groovy.ui.GroovyMain.processOnce(GroovyMain.java:450) \nat groovy.ui.GroovyMain.run(GroovyMain.java:276) \nat groovy.ui.GroovyMain.process(GroovyMain.java:262) \nat groovy.ui.GroovyMain.main(GroovyMain.java:138) \nat org.codehaus.groovy.tools.GroovyStarter.main(GroovyStarter.java:101) \nat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) \nat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) \nat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) \nat java.lang.reflect.Method.invoke(Method.java:324) \nat org.codehaus.classworlds.Launcher.launchEnhanced(Launcher.java:315) \nat org.codehaus.classworlds.Launcher.launch(Launcher.java:255) \nat org.codehaus.classworlds.Launcher.mainWithExitCode(Launcher.java:429) \nat org.codehaus.classworlds.Launcher.main(Launcher.java:375) \nCaused by: org.codehaus.groovy.antlr.ASTRuntimeException: PARSER BUG: Tried to configure org.codehaus.groovy.ast.expr.ArgumentListExpression with null Node \nat org.codehaus.groovy.antlr.AntlrParserPlugin.configureAST(AntlrParserPlugin.java:2065) \nat org.codehaus.groovy.antlr.AntlrParserPlugin.arguments(AntlrParserPlugin.java:1760) \nat org.codehaus.groovy.antlr.AntlrParserPlugin.constructorCallExpression(AntlrParserPlugin.java:1712) \nat org.codehaus.groovy.antlr.AntlrParserPlugin.expressionSwitch(AntlrParserPlugin.java:1065) \nat org.codehaus.groovy.antlr.AntlrParserPlugin.expression(AntlrParserPlugin.java:1035) \nat org.codehaus.groovy.antlr.AntlrParserPlugin.statement(AntlrParserPlugin.java:753) \nat org.codehaus.groovy.antlr.AntlrParserPlugin.statementListNoChild(AntlrParserPlugin.java:769) \nat org.codehaus.groovy.antlr.AntlrParserPlugin.statementList(AntlrParserPlugin.java:762) \nat org.codehaus.groovy.antlr.AntlrParserPlugin.constructorDef(AntlrParserPlugin.java:432) \nat org.codehaus.groovy.antlr.AntlrParserPlugin.objectBlock(AntlrParserPlugin.java:353) \nat org.codehaus.groovy.antlr.AntlrParserPlugin.classDef(AntlrParserPlugin.java:335) \nat org.codehaus.groovy.antlr.AntlrParserPlugin.convertGroovy(AntlrParserPlugin.java:197) \nat org.codehaus.groovy.antlr.AntlrParserPlugin.buildAST(AntlrParserPlugin.java:173) \n... 25 more \n\n1 Error \n",
        "MissingMethodException while using 'this(aString)' Java construct. I am having the following when trying to run a program:\n\nX-----------------------------------------------------\ngroovy.lang.MissingMethodException: No signature of method com.svihar.groovy.A.doCall() is applicable for argument types: (java.lang.String) values: []\nat groovy.lang.MetaClass.invokeMethod(MetaClass.java:318)\n-----------------------------------------------------X\n\nI have isolated the problem into the following snippet:\nX-----------------------------------------------------\npackage com.svihar.groovy\npublic class A {\n\tpublic A() {this(\"\");}\n\tpublic A(String a) {}\n\tpublic void communicate() {\n\t\tSystem.out.println(\"Communicate\");\n\t}\n}\nclass B {\n\tpublic B() {this('')}\n\tpublic B(String a) {}\n\tcommunicate(){println \"heelo\"}\n}\n\na = new A()\na.communicate();\n\nb = new B();\nb.communicate();\n-----------------------------------------------------X\n\nClass A represents a valid Java class and class B represents\nits Groovy equivalent. Both classes have problem in executing.\n\nClass A works as expected in standard JVM."
    ],
    [
        "GROOVY-994",
        "GROOVY-881",
        "PARSER BUG: Tried to configure ArgumentListExpression with null Node //demo.groovy \n\npublic class A { \npublic A() {this(\"\");} \npublic A(String a) {} \npublic void communicate() { \nSystem.out.println(\"Communicate\"); \n} \n} \nclass B { \npublic B() {this('')} \npublic B(String a) {} \nvoid communicate(){println \"heelo\"} \n} \n\na = new A() \na.communicate(); \n\nb = new B(); \nb.communicate(); \n\n//end of demo \n\nrun the file and get the following error: \n\ne:\\groovy\\demo.groovy: -1: PARSER BUG: Tried to configure org.codehaus.groovy.ast.expr.ArgumentListExpression with null Node. File: e:\\groovy\\demo.groovy @ line -1, column -1.org.codehaus.groovy.antlr.ASTParserException: PARSER BUG: Tried to configure org.codehaus.groovy.ast.expr.ArgumentListExpression with null Node. File: e:\\groovy\\demo.groovy @ line -1, column -1. \nat org.codehaus.groovy.antlr.AntlrParserPlugin.buildAST(AntlrParserPlugin.java:176) \nat org.codehaus.groovy.control.SourceUnit.convert(SourceUnit.java:315) \nat org.codehaus.groovy.control.CompilationUnit$2.call(CompilationUnit.java:536) \nat org.codehaus.groovy.control.CompilationUnit.applyToSourceUnits(CompilationUnit.java:792) \nat org.codehaus.groovy.control.CompilationUnit.convert(CompilationUnit.java:523) \nat org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:452) \nat groovy.lang.GroovyClassLoader.parseClass(GroovyClassLoader.java:258) \nat groovy.lang.GroovyClassLoader.parseClass(GroovyClassLoader.java:221) \nat groovy.lang.GroovyClassLoader.parseClass(GroovyClassLoader.java:171) \nat groovy.lang.GroovyShell$1.run(GroovyShell.java:266) \nat java.security.AccessController.doPrivileged(Native Method) \nat groovy.lang.GroovyShell.run(GroovyShell.java:264) \nat groovy.lang.GroovyShell.run(GroovyShell.java:208) \nat groovy.ui.GroovyMain.processOnce(GroovyMain.java:450) \nat groovy.ui.GroovyMain.run(GroovyMain.java:276) \nat groovy.ui.GroovyMain.process(GroovyMain.java:262) \nat groovy.ui.GroovyMain.main(GroovyMain.java:138) \nat org.codehaus.groovy.tools.GroovyStarter.main(GroovyStarter.java:101) \nat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) \nat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) \nat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) \nat java.lang.reflect.Method.invoke(Method.java:324) \nat org.codehaus.classworlds.Launcher.launchEnhanced(Launcher.java:315) \nat org.codehaus.classworlds.Launcher.launch(Launcher.java:255) \nat org.codehaus.classworlds.Launcher.mainWithExitCode(Launcher.java:429) \nat org.codehaus.classworlds.Launcher.main(Launcher.java:375) \nCaused by: org.codehaus.groovy.antlr.ASTRuntimeException: PARSER BUG: Tried to configure org.codehaus.groovy.ast.expr.ArgumentListExpression with null Node \nat org.codehaus.groovy.antlr.AntlrParserPlugin.configureAST(AntlrParserPlugin.java:2065) \nat org.codehaus.groovy.antlr.AntlrParserPlugin.arguments(AntlrParserPlugin.java:1760) \nat org.codehaus.groovy.antlr.AntlrParserPlugin.constructorCallExpression(AntlrParserPlugin.java:1712) \nat org.codehaus.groovy.antlr.AntlrParserPlugin.expressionSwitch(AntlrParserPlugin.java:1065) \nat org.codehaus.groovy.antlr.AntlrParserPlugin.expression(AntlrParserPlugin.java:1035) \nat org.codehaus.groovy.antlr.AntlrParserPlugin.statement(AntlrParserPlugin.java:753) \nat org.codehaus.groovy.antlr.AntlrParserPlugin.statementListNoChild(AntlrParserPlugin.java:769) \nat org.codehaus.groovy.antlr.AntlrParserPlugin.statementList(AntlrParserPlugin.java:762) \nat org.codehaus.groovy.antlr.AntlrParserPlugin.constructorDef(AntlrParserPlugin.java:432) \nat org.codehaus.groovy.antlr.AntlrParserPlugin.objectBlock(AntlrParserPlugin.java:353) \nat org.codehaus.groovy.antlr.AntlrParserPlugin.classDef(AntlrParserPlugin.java:335) \nat org.codehaus.groovy.antlr.AntlrParserPlugin.convertGroovy(AntlrParserPlugin.java:197) \nat org.codehaus.groovy.antlr.AntlrParserPlugin.buildAST(AntlrParserPlugin.java:173) \n... 25 more \n\n1 Error \n",
        "can't call this(string) in constructor // demo.groovy, below file is OK\nclass B {\n\tpublic B(String s) { println s }\n\tpublic void communicate(){println \"hello\"}\n}\n\nb = new B(\"SSSS\");\nb.communicate();\n//end of demo.groovy\n\n//another demo.groovy, below file is invalid\nclass B {\n\tpublic B() {this(\"default\")}\n\tpublic B(String s) { println s }\n\tpublic void communicate(){println \"hello\"}\n}\n\nb = new B(\"SSSS\");\nb.communicate();\n//end of demo.groovy\n\n\n//below is the exception\ne:\\groovy\\demo.groovy: -1: PARSER BUG: Tried to configure org.codehaus.groovy.ast.expr.ArgumentListExpression with null Node. File: e:\\groovy\\demo.groovy @ line -1, column -1.org.codehaus.groovy.antlr.ASTParserException: PARSER BUG: Tried to configure org.codehaus.groovy.ast.expr.ArgumentListExpression with null Node. File: e:\\groovy\\demo.groovy @ line -1, column -1.\n\tat org.codehaus.groovy.antlr.AntlrParserPlugin.buildAST(AntlrParserPlugin.java:129)\n\tat org.codehaus.groovy.control.SourceUnit.convert(SourceUnit.java:315)\n\tat org.codehaus.groovy.control.CompilationUnit$2.call(CompilationUnit.java:544)\n\tat org.codehaus.groovy.control.CompilationUnit.applyToSourceUnits(CompilationUnit.java:800)\n\tat org.codehaus.groovy.control.CompilationUnit.convert(CompilationUnit.java:531)\n\tat org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:460)\n\tat groovy.lang.GroovyClassLoader.parseClass(GroovyClassLoader.java:244)\n\tat groovy.lang.GroovyClassLoader.parseClass(GroovyClassLoader.java:209)\n\tat groovy.lang.GroovyClassLoader.parseClass(GroovyClassLoader.java:159)\n\tat groovy.lang.GroovyShell$1.run(GroovyShell.java:260)\n\tat java.security.AccessController.doPrivileged(Native Method)\n\tat groovy.lang.GroovyShell.run(GroovyShell.java:258)\n\tat groovy.lang.GroovyShell.run(GroovyShell.java:202)\n\tat groovy.ui.GroovyMain.processOnce(GroovyMain.java:416)\n\tat groovy.ui.GroovyMain.run(GroovyMain.java:249)\n\tat groovy.ui.GroovyMain.process(GroovyMain.java:235)\n\tat groovy.ui.GroovyMain.main(GroovyMain.java:138)\n\tat org.codehaus.groovy.tools.GroovyStarter.main(GroovyStarter.java:92)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n\tat java.lang.reflect.Method.invoke(Method.java:324)\n\tat org.codehaus.classworlds.Launcher.launchEnhanced(Launcher.java:315)\n\tat org.codehaus.classworlds.Launcher.launch(Launcher.java:255)\n\tat org.codehaus.classworlds.Launcher.mainWithExitCode(Launcher.java:429)\n\tat org.codehaus.classworlds.Launcher.main(Launcher.java:375)\nCaused by: org.codehaus.groovy.antlr.ASTRuntimeException: PARSER BUG: Tried to configure org.codehaus.groovy.ast.expr.ArgumentListExpression with null Node\n\tat org.codehaus.groovy.antlr.AntlrParserPlugin.configureAST(AntlrParserPlugin.java:2015)\n\tat org.codehaus.groovy.antlr.AntlrParserPlugin.arguments(AntlrParserPlugin.java:1710)\n\tat org.codehaus.groovy.antlr.AntlrParserPlugin.constructorCallExpression(AntlrParserPlugin.java:1662)\n\tat org.codehaus.groovy.antlr.AntlrParserPlugin.expressionSwitch(AntlrParserPlugin.java:1017)\n\tat org.codehaus.groovy.antlr.AntlrParserPlugin.expression(AntlrParserPlugin.java:987)\n\tat org.codehaus.groovy.antlr.AntlrParserPlugin.statement(AntlrParserPlugin.java:705)\n\tat org.codehaus.groovy.antlr.AntlrParserPlugin.statementListNoChild(AntlrParserPlugin.java:721)\n\tat org.codehaus.groovy.antlr.AntlrParserPlugin.statementList(AntlrParserPlugin.java:714)\n\tat org.codehaus.groovy.antlr.AntlrParserPlugin.constructorDef(AntlrParserPlugin.java:385)\n\tat org.codehaus.groovy.antlr.AntlrParserPlugin.objectBlock(AntlrParserPlugin.java:306)\n\tat org.codehaus.groovy.antlr.AntlrParserPlugin.classDef(AntlrParserPlugin.java:288)\n\tat org.codehaus.groovy.antlr.AntlrParserPlugin.convertGroovy(AntlrParserPlugin.java:150)\n\tat org.codehaus.groovy.antlr.AntlrParserPlugin.buildAST(AntlrParserPlugin.java:126)\n\t... 25 more\n\n1 Error\n\n"
    ],
    [
        "GROOVY-1092",
        "GROOVY-896",
        "Multidimensional arrays are broken Multidimensional arrays are completely broken.  If I try to create one using the standard syntax\n\na = new Object[2][2];\n\nI get an error\n\nScript1.groovy: 1: Unknown type: ARRAY_DECLARATOR at line: 1 column: 15. File: Script1.groovy @ line 1, column 15.\n\nNor does there seem to be any other syntax for creating a multidimensional array.  Of course, I can do it by using reflection:\n\nimport java.lang.reflect.*;\na = Array.newInstance(Object.class, (int []) [2, 2]);\n\nThat successfully creates a multidimensional array, but as soon as I try to do anything with it, the parser dies.  For example, a simple reference to a.length produces the following exception:\n\njava.lang.ClassFormatError: gjdk/[Ljava/lang/Object;_GroovyReflectorArray (Illegal Class name \"gjdk/[Ljava/lang/Object;_GroovyReflectorArray\")\n\tat java.lang.ClassLoader.defineClass0(Native Method)\n\tat java.lang.ClassLoader.defineClass(ClassLoader.java:539)\n\tat groovy.lang.GroovyClassLoader.defineClass(GroovyClassLoader.java:481)\n\tat groovy.lang.MetaClassRegistry$3.run(MetaClassRegistry.java:169)\n\tat java.security.AccessController.doPrivileged(Native Method)\n\tat groovy.lang.MetaClassRegistry.loadClass(MetaClassRegistry.java:167)\n\tat groovy.lang.MetaClass.loadReflectorClass(MetaClass.java:2309)\n\tat groovy.lang.MetaClass.loadReflector(MetaClass.java:2291)\n\tat groovy.lang.MetaClass.generateReflector(MetaClass.java:2241)\n\tat groovy.lang.MetaClass.checkInitialised(MetaClass.java:2188)\n\tat groovy.lang.MetaClassRegistry.getMetaClass(MetaClassRegistry.java:124)\n\tat org.codehaus.groovy.runtime.Invoker.getProperty(Invoker.java:638)\n\tat org.codehaus.groovy.runtime.InvokerHelper.getProperty(InvokerHelper.java:175)\n\tat org.codehaus.groovy.runtime.ScriptBytecodeAdapter.getProperty(ScriptBytecodeAdapter.java:274)\n\tat Script1.run(Unknown Source)\n\tat groovy.lang.GroovyShell.evaluate(GroovyShell.java:500)\n\tat groovy.lang.GroovyShell.evaluate(GroovyShell.java:478)\n\nPassing the array as an argument to any method similarly produces an exception.  This makes Groovy completely incapable of invoking any method that takes a multidimensional array as an argument.",
        "Problem when accessing arrays of arrays from groovy If I create a Java class which contains a field declared as:\n\nint[][] x;\n\nthen pass an object to groovy and ask it to execute:\n\nprintln (the object).x[0]\n\nit throws:\n\nException in thread \"main\" java.lang.ClassFormatError: Illegal class name \"gjdk/[I_GroovyReflectorArray\" in class file gjdk/[I_GroovyReflectorArray\n\nPrinting just (the object).x works fine.\n\nThe full code which reproduces this error is:\n\nbug4.groovy:\nclass bug4 {\n   def bubbles(a) {\n      println a.x[0];\n   }\n}\n\nbug4j.java:\nimport groovy.lang.*;\n\nimport java.io.*;\n\nimport org.codehaus.groovy.control.CompilationFailedException;\n\npublic class bug4j {\n\tpublic int[][] x;\n\t\n\tvoid ricky()  throws CompilationFailedException, InstantiationException,\n\tIOException,  IllegalAccessException {\n\t\tx = new int[][] {new int[5], new int[4], new int[3]};\n\t\t\n\t\t// Create the groovy object\n\t\tClassLoader parent = getClass().getClassLoader();\n\t\tGroovyClassLoader loader = new GroovyClassLoader(parent);\n\t\tClass groovyClass = loader.parseClass(new File(\"bug4.groovy\"));\n\t\tGroovyObject bug4 = (GroovyObject) groovyClass.newInstance();\n\n\t\tObject[] args = {this};\n\t\tbug4.invokeMethod(\"bubbles\", args);\n\t}\n\n\tpublic static void main(String[] args) throws CompilationFailedException,\n\t\tInstantiationException, IOException,  IllegalAccessException  {\n\t\t(new bug4j()).ricky();\n\t}\n}\n\n"
    ],
    [
        "GROOVY-1564",
        "GROOVY-1210",
        "finally not called if try contains return From the original email:\n\n[Maurice]\n\nHi,\n\nif I compile and run this as a java class\n\n{noformat}\npublic class finallytest {\n     public static void main(String[] args) {\n       testit();\n   }\n     public static int testit() {\n       try {\n           System.out.println(\"try\");\n           return 1;\n       } finally {\n           System.out.println(\"finally\");\n       }\n   }\n}\n{noformat}\n\nI get\n\n{noformat}\ntry\nfiinally\n{noformat}\n\nIf I run in as a Groovy class I get\n\n{noformat}\ntry\n{noformat}\n\nIs this intentional? \n\n[John]\n\nNo it's a bug.\n\nWould you please riase a JIRA issue for this?\n",
        "complete Implementation of finally ensure that finally works as expected if a block is left by continue/break/return, check for chained finalliys."
    ],
    [
        "GROOVY-1566",
        "GROOVY-1539",
        "problems with if statements not returning correctly package groovy.runtime.metaclass.org.codehaus.groovy.antlr\n\nimport groovy.formatter.DefaultTraverser\nimport java.beans.IntrospectionException\n\nclass GroovySourceASTMetaClass extends MetaClassImpl {\n\n\tpublic GroovySourceASTMetaClass(MetaClassRegistry mcr, Class clazz) throws IntrospectionException {\n\t\tsuper(mcr, clazz)\n\t}\n\n        // version that exhibits the bug\n\tObject getProperty(final Object object, final String property) {\n\t\tif (property == \"children\") {\n\t\t\tnew ASTIterator(next:object.firstChild)\n\t\t} else {\n\t\t\tsuper.getProperty(object, property)\n\t\t}\n\t}\n\n        /* version that works \t\n\tObject getProperty(final Object object, final String property) {\n\t\tdef result = null\n\t\t\n\t\tif (property == \"children\") {\n\t\t\tresult = new ASTIterator(next:object.firstChild)\n\t\t} else {\n\t\t\tresult = super.getProperty(object, property)\n\t\t}\n\t\t\n\t\treturn result\n\t}\n        */\n\n}\n\nclass ASTIterator implements Iterator {\n\n\tObject next = null\n\n\tboolean hasNext() {\n\t\treturn next != null;\n\t}\n\n\tObject next() {\n\t\tdef prevNext = next\n\t\tnext = next.nextSibling\n\t\tprevNext\n\t}\n\n\tvoid remove() {\n\t\tthrow new RuntimeException(\"Removal of AST nodes is not implemented.\");\n\t}\n\t\n}\n\n\n// and here is some script that trips with an exception\nGroovyRecognizer parser = null\nUnicodeEscapingReader unicodeReader = new UnicodeEscapingReader(new StringReader (\"println 'Hello, there!'\"), null)\nGroovyLexer lexer = new GroovyLexer(unicodeReader)\nunicodeReader.setLexer(lexer)\nparser = GroovyRecognizer.make(lexer)\nparser.compilationUnit()\n\t    \nGroovySourceAST ast = (GroovySourceAST) parser.getAST()\nast.children.each { println it.text }\n\n\n// exception thrown is \n// Note: execution is not that of the snippet above.\n/*\nException in thread \"main\" java.lang.VerifyError: (class: groovy/runtime/metaclass/org/codehaus/groovy/antlr/GroovySourceASTMetaClass, method: getProperty signature: (Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Object;) Inconsistent stack height 1 != 0\n\tat java.lang.Class.forName0(Native Method)\n\tat java.lang.Class.forName(Class.java:164)\n\tat groovy.lang.MetaClassRegistry.getMetaClassFor(MetaClassRegistry.java:218)\n\tat groovy.lang.MetaClassRegistry.getMetaClass(MetaClassRegistry.java:142)\n\tat org.codehaus.groovy.runtime.Invoker.getProperty(Invoker.java:247)\n\tat org.codehaus.groovy.runtime.InvokerHelper.getProperty(InvokerHelper.java:213)\n\tat org.codehaus.groovy.runtime.ScriptBytecodeAdapter.getProperty(ScriptBytecodeAdapter.java:501)\n\tat groovy.formatter.GroovySourceFormatter.format(GroovySourceFormatter.groovy:44)\n\tat gjdk.groovy.formatter.GroovySourceFormatter_GroovyReflector.invoke(Unknown Source)\n\tat groovy.lang.MetaMethod.invoke(MetaMethod.java:111)\n\tat org.codehaus.groovy.runtime.MetaClassHelper.doMethodInvoke(MetaClassHelper.java:659)\n\tat groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:377)\n\tat groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:344)\n\tat org.codehaus.groovy.runtime.Invoker.invokeMethod(Invoker.java:134)\n\tat org.codehaus.groovy.runtime.InvokerHelper.invokeMethod(InvokerHelper.java:111)\n\tat org.codehaus.groovy.runtime.ScriptBytecodeAdapter.invokeMethodOnCurrentN(ScriptBytecodeAdapter.java:89)\n\tat groovy.formatter.GroovySourceFormatter$_run_closure2.doCall(GroovySourceFormatter.groovy:28)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n\tat java.lang.reflect.Method.invoke(Method.java:585)\n\tat org.codehaus.groovy.runtime.ReflectionMetaMethod.invoke(ReflectionMetaMethod.java:67)\n\tat org.codehaus.groovy.runtime.MetaClassHelper.doMethodInvoke(MetaClassHelper.java:659)\n\tat groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:377)\n\tat groovy.lang.Closure.call(Closure.java:176)\n\tat groovy.lang.Closure.call(Closure.java:189)\n\tat org.codehaus.groovy.runtime.DefaultGroovyMethods.each(DefaultGroovyMethods.java:677)\n\tat gjdk.java.util.Collection_GroovyReflector.invoke(Unknown Source)\n\tat groovy.lang.MetaMethod.invoke(MetaMethod.java:111)\n\tat org.codehaus.groovy.runtime.NewInstanceMetaMethod.invoke(NewInstanceMetaMethod.java:99)\n\tat org.codehaus.groovy.runtime.MetaClassHelper.doMethodInvoke(MetaClassHelper.java:659)\n\tat groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:377)\n\tat org.codehaus.groovy.runtime.Invoker.invokeMethod(Invoker.java:122)\n\tat org.codehaus.groovy.runtime.InvokerHelper.invokeMethod(InvokerHelper.java:111)\n\tat org.codehaus.groovy.runtime.ScriptBytecodeAdapter.invokeMethodN(ScriptBytecodeAdapter.java:165)\n\tat groovy.formatter.GroovySourceFormatter.run(GroovySourceFormatter.groovy:28)\n\tat gjdk.groovy.formatter.GroovySourceFormatter_GroovyReflector.invoke(Unknown Source)\n\tat groovy.lang.MetaMethod.invoke(MetaMethod.java:111)\n\tat org.codehaus.groovy.runtime.MetaClassHelper.doMethodInvoke(MetaClassHelper.java:659)\n\tat groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:377)\n\tat org.codehaus.groovy.runtime.Invoker.invokeMethod(Invoker.java:134)\n\tat org.codehaus.groovy.runtime.InvokerHelper.invokeMethod(InvokerHelper.java:111)\n\tat org.codehaus.groovy.runtime.ScriptBytecodeAdapter.invokeMethodN(ScriptBytecodeAdapter.java:165)\n\tat groovy.formatter.GroovySourceFormatter.main(GroovySourceFormatter.groovy:12)\n*/",
        "java.lang.VerifyError my groovy script contains the following lines: \nif (true)\n{\n   String = \"myPrice\"\n}\n\nWhen performing evaluate I would expect to get CompilationFailedException (because a value is being put into java.lang.String and not to a variable) but I get: \n\njava.lang.VerifyError: (class: Script1, method: run signature: ()Ljava/lang/Object;) Inconsistent stack height 2 != 0\n\tat java.lang.Class.getDeclaredConstructors0(Native Method)\n\tat java.lang.Class.privateGetDeclaredConstructors(Class.java:1618)\n\tat java.lang.Class.getConstructor0(Class.java:1930)\n\tat java.lang.Class.newInstance0(Class.java:278)\n\tat java.lang.Class.newInstance(Class.java:261)\n\tat org.codehaus.groovy.runtime.InvokerHelper.createScript(InvokerHelper.java:529)\n\tat groovy.lang.GroovyShell.parse(GroovyShell.java:526)\n\tat groovy.lang.GroovyShell.parse(GroovyShell.java:506)\n\tat groovy.lang.GroovyShell.evaluate(GroovyShell.java:484)\n\tat groovy.lang.GroovyShell.evaluate(GroovyShell.java:460)\n\nThe interesting thing is when writing:\nString = \"myPrice\" (not inside a condition)\nthen the evaluate succeeds and there is no error."
    ],
    [
        "GROOVY-1626",
        "GROOVY-1539",
        "Inconsitent stack height when using super Error occures in groovy-1.0-RC-02, it did'nt occure in JSR6\n\nWhen calling 'groovy SuperError.groovy' I get the error:\n  Caught: java.lang.VerifyError: (class: B, method: m signature: (Ljava/lang/Object;)V) Inconsistent stack height 1 != 0\nIn the method call super.m(p1, 'called from B') the super keyword is not necessary, but it should'nt result in an error.\n\nHere is the code:\n----------------------------------------\n// SuperError.groovy\nclass SuperError extends GroovyTestCase {\n  static void testSuperError() {\n    new B().m('Call B.m')\n  }\n}\n\nclass A {\n  void m(p1) {\n    println 'A.m with parameter: ' + p1\n  }\n  void m(p1, p2) {\n    println 'A.m with parameters: ' + p1 + ', ' + p2\n  }\n}\n\nclass B extends A {\n  void m(p1) {\n    if (p1)\n      super.m(p1, 'called from B')\n\n/*\n  This works (without if): \n    super.m(p1, 'called from B')\n\n  And this works too (without super)\n    if (p1)\n      m(p1, 'called from B')\n*/\n  }\n}\n----------------------------------------\n",
        "java.lang.VerifyError my groovy script contains the following lines: \nif (true)\n{\n   String = \"myPrice\"\n}\n\nWhen performing evaluate I would expect to get CompilationFailedException (because a value is being put into java.lang.String and not to a variable) but I get: \n\njava.lang.VerifyError: (class: Script1, method: run signature: ()Ljava/lang/Object;) Inconsistent stack height 2 != 0\n\tat java.lang.Class.getDeclaredConstructors0(Native Method)\n\tat java.lang.Class.privateGetDeclaredConstructors(Class.java:1618)\n\tat java.lang.Class.getConstructor0(Class.java:1930)\n\tat java.lang.Class.newInstance0(Class.java:278)\n\tat java.lang.Class.newInstance(Class.java:261)\n\tat org.codehaus.groovy.runtime.InvokerHelper.createScript(InvokerHelper.java:529)\n\tat groovy.lang.GroovyShell.parse(GroovyShell.java:526)\n\tat groovy.lang.GroovyShell.parse(GroovyShell.java:506)\n\tat groovy.lang.GroovyShell.evaluate(GroovyShell.java:484)\n\tat groovy.lang.GroovyShell.evaluate(GroovyShell.java:460)\n\nThe interesting thing is when writing:\nString = \"myPrice\" (not inside a condition)\nthen the evaluate succeeds and there is no error."
    ],
    [
        "GROOVY-1626",
        "GROOVY-1566",
        "Inconsitent stack height when using super Error occures in groovy-1.0-RC-02, it did'nt occure in JSR6\n\nWhen calling 'groovy SuperError.groovy' I get the error:\n  Caught: java.lang.VerifyError: (class: B, method: m signature: (Ljava/lang/Object;)V) Inconsistent stack height 1 != 0\nIn the method call super.m(p1, 'called from B') the super keyword is not necessary, but it should'nt result in an error.\n\nHere is the code:\n----------------------------------------\n// SuperError.groovy\nclass SuperError extends GroovyTestCase {\n  static void testSuperError() {\n    new B().m('Call B.m')\n  }\n}\n\nclass A {\n  void m(p1) {\n    println 'A.m with parameter: ' + p1\n  }\n  void m(p1, p2) {\n    println 'A.m with parameters: ' + p1 + ', ' + p2\n  }\n}\n\nclass B extends A {\n  void m(p1) {\n    if (p1)\n      super.m(p1, 'called from B')\n\n/*\n  This works (without if): \n    super.m(p1, 'called from B')\n\n  And this works too (without super)\n    if (p1)\n      m(p1, 'called from B')\n*/\n  }\n}\n----------------------------------------\n",
        "problems with if statements not returning correctly package groovy.runtime.metaclass.org.codehaus.groovy.antlr\n\nimport groovy.formatter.DefaultTraverser\nimport java.beans.IntrospectionException\n\nclass GroovySourceASTMetaClass extends MetaClassImpl {\n\n\tpublic GroovySourceASTMetaClass(MetaClassRegistry mcr, Class clazz) throws IntrospectionException {\n\t\tsuper(mcr, clazz)\n\t}\n\n        // version that exhibits the bug\n\tObject getProperty(final Object object, final String property) {\n\t\tif (property == \"children\") {\n\t\t\tnew ASTIterator(next:object.firstChild)\n\t\t} else {\n\t\t\tsuper.getProperty(object, property)\n\t\t}\n\t}\n\n        /* version that works \t\n\tObject getProperty(final Object object, final String property) {\n\t\tdef result = null\n\t\t\n\t\tif (property == \"children\") {\n\t\t\tresult = new ASTIterator(next:object.firstChild)\n\t\t} else {\n\t\t\tresult = super.getProperty(object, property)\n\t\t}\n\t\t\n\t\treturn result\n\t}\n        */\n\n}\n\nclass ASTIterator implements Iterator {\n\n\tObject next = null\n\n\tboolean hasNext() {\n\t\treturn next != null;\n\t}\n\n\tObject next() {\n\t\tdef prevNext = next\n\t\tnext = next.nextSibling\n\t\tprevNext\n\t}\n\n\tvoid remove() {\n\t\tthrow new RuntimeException(\"Removal of AST nodes is not implemented.\");\n\t}\n\t\n}\n\n\n// and here is some script that trips with an exception\nGroovyRecognizer parser = null\nUnicodeEscapingReader unicodeReader = new UnicodeEscapingReader(new StringReader (\"println 'Hello, there!'\"), null)\nGroovyLexer lexer = new GroovyLexer(unicodeReader)\nunicodeReader.setLexer(lexer)\nparser = GroovyRecognizer.make(lexer)\nparser.compilationUnit()\n\t    \nGroovySourceAST ast = (GroovySourceAST) parser.getAST()\nast.children.each { println it.text }\n\n\n// exception thrown is \n// Note: execution is not that of the snippet above.\n/*\nException in thread \"main\" java.lang.VerifyError: (class: groovy/runtime/metaclass/org/codehaus/groovy/antlr/GroovySourceASTMetaClass, method: getProperty signature: (Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Object;) Inconsistent stack height 1 != 0\n\tat java.lang.Class.forName0(Native Method)\n\tat java.lang.Class.forName(Class.java:164)\n\tat groovy.lang.MetaClassRegistry.getMetaClassFor(MetaClassRegistry.java:218)\n\tat groovy.lang.MetaClassRegistry.getMetaClass(MetaClassRegistry.java:142)\n\tat org.codehaus.groovy.runtime.Invoker.getProperty(Invoker.java:247)\n\tat org.codehaus.groovy.runtime.InvokerHelper.getProperty(InvokerHelper.java:213)\n\tat org.codehaus.groovy.runtime.ScriptBytecodeAdapter.getProperty(ScriptBytecodeAdapter.java:501)\n\tat groovy.formatter.GroovySourceFormatter.format(GroovySourceFormatter.groovy:44)\n\tat gjdk.groovy.formatter.GroovySourceFormatter_GroovyReflector.invoke(Unknown Source)\n\tat groovy.lang.MetaMethod.invoke(MetaMethod.java:111)\n\tat org.codehaus.groovy.runtime.MetaClassHelper.doMethodInvoke(MetaClassHelper.java:659)\n\tat groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:377)\n\tat groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:344)\n\tat org.codehaus.groovy.runtime.Invoker.invokeMethod(Invoker.java:134)\n\tat org.codehaus.groovy.runtime.InvokerHelper.invokeMethod(InvokerHelper.java:111)\n\tat org.codehaus.groovy.runtime.ScriptBytecodeAdapter.invokeMethodOnCurrentN(ScriptBytecodeAdapter.java:89)\n\tat groovy.formatter.GroovySourceFormatter$_run_closure2.doCall(GroovySourceFormatter.groovy:28)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n\tat java.lang.reflect.Method.invoke(Method.java:585)\n\tat org.codehaus.groovy.runtime.ReflectionMetaMethod.invoke(ReflectionMetaMethod.java:67)\n\tat org.codehaus.groovy.runtime.MetaClassHelper.doMethodInvoke(MetaClassHelper.java:659)\n\tat groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:377)\n\tat groovy.lang.Closure.call(Closure.java:176)\n\tat groovy.lang.Closure.call(Closure.java:189)\n\tat org.codehaus.groovy.runtime.DefaultGroovyMethods.each(DefaultGroovyMethods.java:677)\n\tat gjdk.java.util.Collection_GroovyReflector.invoke(Unknown Source)\n\tat groovy.lang.MetaMethod.invoke(MetaMethod.java:111)\n\tat org.codehaus.groovy.runtime.NewInstanceMetaMethod.invoke(NewInstanceMetaMethod.java:99)\n\tat org.codehaus.groovy.runtime.MetaClassHelper.doMethodInvoke(MetaClassHelper.java:659)\n\tat groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:377)\n\tat org.codehaus.groovy.runtime.Invoker.invokeMethod(Invoker.java:122)\n\tat org.codehaus.groovy.runtime.InvokerHelper.invokeMethod(InvokerHelper.java:111)\n\tat org.codehaus.groovy.runtime.ScriptBytecodeAdapter.invokeMethodN(ScriptBytecodeAdapter.java:165)\n\tat groovy.formatter.GroovySourceFormatter.run(GroovySourceFormatter.groovy:28)\n\tat gjdk.groovy.formatter.GroovySourceFormatter_GroovyReflector.invoke(Unknown Source)\n\tat groovy.lang.MetaMethod.invoke(MetaMethod.java:111)\n\tat org.codehaus.groovy.runtime.MetaClassHelper.doMethodInvoke(MetaClassHelper.java:659)\n\tat groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:377)\n\tat org.codehaus.groovy.runtime.Invoker.invokeMethod(Invoker.java:134)\n\tat org.codehaus.groovy.runtime.InvokerHelper.invokeMethod(InvokerHelper.java:111)\n\tat org.codehaus.groovy.runtime.ScriptBytecodeAdapter.invokeMethodN(ScriptBytecodeAdapter.java:165)\n\tat groovy.formatter.GroovySourceFormatter.main(GroovySourceFormatter.groovy:12)\n*/"
    ],
    [
        "GROOVY-1651",
        "GROOVY-1586",
        "Bitwise OR and AND operators with left operand inverted (!) cause VerifyError 100% reproducible test case with Groovy 1.0.1:\n\ndef y = !true | false\n\nThat's all you need. It happens with AND too:\n\ndef y = !true & false\n\nBut not with && or ||. The NOT operator is required on the first operand.\n\n-Please- add a unit test for this before fixing it.",
        "verify error / NPE with & operator C:\\>groovy -e \"i=0;j=1;((i = 1) == 3) & ((j = 2) == 2)\"\nCaught: java.lang.VerifyError: (class: script_from_command_line, method: run signature: ()Ljava/lang/Object;) Expecting to find object/array on stack\n\n  With jdk 150_09 and 142_09 the same one liner seems to cause a null pointer exception.\n\n"
    ],
    [
        "GROOVY-1674",
        "GROOVY-1602",
        "AntBuilder provided by default within Groovy task executes tasks twice When using the AntBuilder provided by the \"ant\" property within a Groovy Ant task, any tasks created by the builder execute twice.\nRun the following build (with the groovy-all-1.0.jar in the current directory) to see 'Hi' printed twice. Note that once it comes before\n'After Groovy task' is printed, and once it comes after. Using a new AntBuilder within the task doesn't have this issue.\n\n<project name=\"Test\" default=\"test\">\n  <taskdef name=\"groovy\"\n           classname=\"org.codehaus.groovy.ant.Groovy\"\n           classpath=\"groovy-all-1.0.jar\" />           \n           \n  <target name=\"test\">\n    <groovy>\n      ant.echo('Hi')\n    </groovy>\n    <echo>After Groovy task</echo>\n  </target>\n                \n</project> ",
        "Using the groovy task in ant, my tasks run twice If I run the 'ant test' command with the following ant build.xml,\n\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project basedir=\".\" name=\"test\">\n\t<path id=\"groovy.classpath\">\n\t\t<fileset dir=\"groovy\" includes=\"*.jar\"/>\n\t</path>\n\t<taskdef name=\"groovy\" classname=\"org.codehaus.groovy.ant.Groovy\" classpathref=\"groovy.classpath\"/>\n\t<target name=\"test\">\n\t\t<groovy>\n\t\t\tant.echo \"Test\"\n\t\t</groovy>\n\t</target>\n</project>\n\nI get the following output:\n\nC:\\@WORK2\\test>ant test\nBuildfile: build.xml\n\ntest:\n     [echo] Test\n     [echo] Test\n\nBUILD SUCCESSFUL\nTotal time: 2 seconds\nC:\\@WORK2\\test>\n\nI have also tested this with long running tasks like jarring and unjarring, and the tasks are actually executed twice, not only printed twice.\n\nI found a workaround like this:\n\n\t<target name=\"test\">\n\t\t<groovy>\n\t\t\tant = new AntBuilder( project )\n\t\t\tant.echo \"Test\"\n\t\t</groovy>\n\t</target>\n\nBut I'm not sure about the consequences of this.\n"
    ],
    [
        "GROOVY-1833",
        "GROOVY-1787",
        "blank in path  makes calling one groovy file from another fail (Note: Searched for this topic but did not find an issue)\n\nSituation:  One groovy file containing one class named like the file.  (see att. MyGroovyClass.groovy)\n\nAnother groovy file instanciating this other class.   (see att. UseGroovyClass.groovy,  sorry for not providing it as JUnit test now)\n\nCommand:   groovy UseGroovyClass.groovy   \n\nshall print:   Hello World\n\n1)  No problem if no blank in current directory where above command is run\n\n2) If path of current directory contains a blank:\n\na) Calling the above command results in:\n\norg.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed, UseGroovyClass.groovy: 2: unable to resolve class MyGroovyClass\n @ line 2, column 13.\n   def value = new MyGroovyClass()\n               ^\n\nb) It is possible to compile MyGroovyClass.groovy with groovyc.   If done, no problem occurs when running command.\n\n",
        "GroovyClassLoader fails to load a script from a file whose absolute name contains spaces I have two scripts in a directory under C:\\Documents and Settings:\nA.groovy:\nthis.class.classLoader.loadClass(\"B\", true, false, true)\n\nand B.groovy which contains a simple (arbitrary) script.\n\nA.groovy fails to find the \"B\" class. It gets as far as the GroovyClassLoader.getSourceFile, which successfully locates the resource URL \"file:/C:/Documents%20and%20Settings/.../B.groovy\". However, it then tries to turn this into a File on the line:\n            File path = new File(ret.getFile()).getParentFile();\nThis fails, as java.io.File expects the unescaped filename of \"C:/Documents and Settings/...\", i.e. with the %20s converted to spaces."
    ],
    [
        "GROOVY-1860",
        "GROOVY-1314",
        "Problem calling override method with different return type. I am not able to call a method that is overridden to return a different type. Being able to return a different type is a JDK1.5 feature that I use a lot on my JMesa open source project. Because I was trying to groovy up my own source code I was able to trouble shoot it to figure out that the problem was with calling the overridden method. If I remove the overridden method then everything works because groovy does the duck typing. However, this is a valid JDK1.5 feature and I believe Groovy is trying to be JDK1.5 compliant. \n\nThis is the abstract class that returns a Table object in the createTable() method:\n\npublic abstract class AbstractTableFactory {\n    public Table createTable(String... columnNames) {\n        ComponentFactory factory = getComponentFactory();\n        Table table = factory.createTable();\n        ...\n        return table;\n    }\n}\n\nThis is the concrete class that overrides the method and return a very specific Table...an HtmlTable. If I remove this method then Groovy calls the method from the abstract class and everything works. Of course I need this method....\n\npublic class HtmlTableFactory {\n    @Override\n    public HtmlTable createTable(String... columnNames) {\n        return (HtmlTable) super.createTable(columnNames);\n    }\n}\n\n\nHere is my groovy code: \n\ndef tableFactory = new HtmlTableFactory(webContext, coreContext);\ndef columns = [\"name.firstName\", \"name.lastName\", \"term\", \"career\"] as String[];\ndef table = tableFactory.createTable(columns);\n\n\nThe error I get is this:\n\njava.lang.NoSuchMethodError: org.jmesa.view.AbstractTableFactory.createTable([Ljava/lang/String;)Lorg/jmesa/view/html/component/HtmlTable;\n\tgjdk.org.jmesa.view.html.HtmlTableFactory_GroovyReflector.invoke(Unknown Source)\n\tgroovy.lang.MetaMethod.invoke(MetaMethod.java:115)\n\torg.codehaus.groovy.runtime.MetaClassHelper.doMethodInvoke(MetaClassHelper.java:713)\n\n\nIf it helps the decompiled groovy code is this:\n\nClass class1 = org.jmesaWeb.controller.BasicGroovyPresident.class;\nClass class2 = groovy.lang.MetaClass.class;\nObject tableFactory = ScriptBytecodeAdapter.invokeNewN(class1, org.jmesa.view.html.HtmlTableFactory.class, ((Object) (new Object[] {webContext, coreContext })));\nObject columns = (String[]) ScriptBytecodeAdapter.asType(ScriptBytecodeAdapter.createList(new Object[] { \"name.firstName\", \"name.lastName\", \"term\", \"career\" }), java.lang.String[].class);\nObject table = ScriptBytecodeAdapter.invokeMethodN(class1, tableFactory, \"createTable\", new Object[] { columns });\n\n\nI hope this example makes sense as what I am trying to do is pretty straightforward. \n\nI was going to try and run a nightly build for 1.1 to see if this works in 1.1, but the nightly build link is broken, or the link points to an empty directory. I will submit a bug report for this as well.\n\n\n\n",
        "support covariant return types (& generics) CRT is really useful, even if Generics is not fully supported / implemented"
    ],
    [
        "GROOVY-1964",
        "GROOVY-1890",
        "deadlock in MemoryAwareConcurrentReadMap.get I've found a deadlock in MemoryAwareConcurrentReadMap.get that affects calls to MetaClassRegistryImpl.getMetaClass.  This particular case seems to happen very infrequently; the last time I saw it happen was after my program had been running for 4.5 hours.  I have seen it more than once, however, so I'm fairly certain this bug will strike any Groovy program that runs long enough.\n\nThis issue may be related GROOVY-1890 but I can't be certain from the information I have.",
        "MemoryAwareConcurrentReadMap cause thred dead lock,it will hang our application at some time. The class org.codehaus.groovy.runtime.metaclass.MemoryAwareConcurrentReadMap  deal with the realization of the visit with multithreading is not doing well enough, often lead to deadlock. The worst result is that an application will hang because of it.\n\nThe problem is the writeLock and writeQueue. I don't think the writeQueue is must be used in the code,and It somewhat redundant.\nIt's possible to implement the same function without writeQueue.\n\nMay be I'm wrong about wrietQueue,but the bug is  true and is very Serious .\n\nI can not imagine, if the bug is real,  use grail to realize a project. What we will get?:(\n\nThe test case will show the \"dead lock\" when you run it some times.\nI wish the patch  should be helpful also.\n\nThanks."
    ],
    [
        "GROOVY-2081",
        "GROOVY-569",
        "Script executes correctly when called with absolute path, but fails when called with relative path The following 2-line script will run if called with an absolute path, but fails if called as ../bin/scriptName\n\nHere's the script:\n\n#!/usr/bin/env groovy\nprintln(\"Yo!\");\n\nThis may be an example of GROOVY-569, since renaming the script to have a .gr suffix seems to solve the problem.\n\nI wasn't aware until reading GROOVY-569 that script names must have a dot!\n\nThis is very confusing: script names actually don't require a dot except in limited circumstances.\nI've been using groovy for a year or so, and this is the first I've encountered this requirement.  The \"Groovy in Action\"\nbook doesn't seem to mention this requirement, although all their examples seem to use .groovy suffix, so maybe it's in there somewhere.\n\nI'm a keyboard junkie (100+ words per minute) and would like to be able to create short concise names for all my scripts, not\njust bash / perl / etc.   Scripting languages (at least in unix land).\n\nFor the sake of script developers coming from other languages, it would be preferable to strictly enforce this naming requirement in every case (e.g., \"illegal script name: filename suffix is mandatory\"), since it's very difficult to track down the cause of this problem.  A frustrated developer is not likely to be searching for the phrase \"script name\" if the symptoms are relative to absolute versus relative path used with calling a script.\n\nBTW, groovy rocks!\n\n\n\n\n",
        "java.lang.ClassFormatError running groovy script from shell (bash) Tried to run a very simple (print \"helloWorld\") script.  Runs fine using groovy compiler, groovysh, but throws exception when trying to run as standalone script.\nScript, exception, compiler output, script output, env and groovysh output below:\n\n% cat helloWorld\n#!/usr/bin/env groovy\nprint \"helloWorld\"\n\n% ./helloWorld\nException in thread \"main\" java.lang.ClassFormatError:  (Illegal Class name \"\")\n        at java.lang.ClassLoader.defineClass0(Native Method)\n        at java.lang.ClassLoader.defineClass(ClassLoader.java:537)\n        at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:123)\n        at groovy.lang.GroovyClassLoader.access$100(GroovyClassLoader.java:78)\n        at groovy.lang.GroovyClassLoader$ClassCollector.onClassNode(GroovyClassLoader.java:470)\n        at groovy.lang.GroovyClassLoader$ClassCollector.call(GroovyClassLoader.java:480)\n        at org.codehaus.groovy.control.CompilationUnit$5.call(CompilationUnit.java:674)\n        at org.codehaus.groovy.control.CompilationUnit.applyToPrimaryClassNodes(CompilationUnit.java:932)\n        at org.codehaus.groovy.control.CompilationUnit.classgen(CompilationUnit.java:591)\n        at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:485)\n        at groovy.lang.GroovyClassLoader.parseClass(GroovyClassLoader.java:226)\n        at groovy.lang.GroovyClassLoader.parseClass(GroovyClassLoader.java:154)\n        at groovy.lang.GroovyShell$2.run(GroovyShell.java:212)\n        at java.security.AccessController.doPrivileged(Native Method)\n        at groovy.lang.GroovyShell.run(GroovyShell.java:210)\n        at groovy.lang.GroovyShell.main(GroovyShell.java:94)\n        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n        at java.lang.reflect.Method.invoke(Method.java:324)\n        at org.codehaus.classworlds.Launcher.launchStandard(Launcher.java:410)\n        at org.codehaus.classworlds.Launcher.launch(Launcher.java:344)\n        at org.codehaus.classworlds.Launcher.main(Launcher.java:461)\n\n% groovy helloWorld\nhelloWorld\n\n% env\nKDE_MULTIHEAD=false\nSSH_AGENT_PID=19891\nHOSTNAME=darwin.triactive.com\nJRUN_HOME=/dev/null\nTERM=xterm\nSHELL=/bin/bash\nHISTSIZE=1000\nGTK_RC_FILES=/etc/gtk/gtkrc:/home/fran/.gtkrc:/home/fran/.gtkrc-kde\nCVSROOT=:pserver:fran@cvs:/usr/local/cvs\nGS_LIB=/home/fran/.kde/share/fonts\nOLDPWD=/home/fran/dev/groovy\nQTDIR=/usr/lib/qt-3.1\nJBOSS_HOME=/usr/local/jboss\nUSER=fran\nLD_LIBRARY_PATH=/usr/local/lib\nLS_COLORS=no=00:fi=00:di=00;34:ln=00;36:pi=40;33:so=00;35:bd=40;33;01:cd=40;33;01:or=01;05;37;41:mi=01;05;37;41:ex=00;32:*.cmd=00;32:*.exe=00;32:*.com=00;32:*.btm=00;32:*.bat=00;32:*.sh=00;32:*.csh=00;32:*.tar=00;31:*.tgz=00;31:*.arj=00;31:*.taz=00;31:*.lzh=00;31:*.zip=00;31:*.z=00;31:*.Z=00;31:*.gz=00;31:*.bz2=00;31:*.bz=00;31:*.tz=00;31:*.rpm=00;31:*.cpio=00;31:*.jpg=00;35:*.gif=00;35:*.bmp=00;35:*.xbm=00;35:*.xpm=00;35:*.png=00;35:*.tif=00;35:\nSSH_AUTH_SOCK=/tmp/ssh-XXwRPpdo/agent.19848\nSESSION_MANAGER=local/darwin.triactive.com:/tmp/.ICE-unix/19960\nKONSOLE_DCOP=DCOPRef(konsole-19982,konsole)\nMAVEN_HOME=/usr/local/src/maven-1.0-rc4\nPATH=/home/fran/bin:/home/fran/dev/ant/bin:/usr/local/epsilon11/bin:/usr/local/groovy/bin:/home/fran/bin:/home/fran/dev/ant/bin:/usr/local/epsilon11/bin:/usr/local/groovy/bin:/usr/java/bin:/usr/local/resin/bin:/usr/local/jboss/bin:/usr/local/apache/bin:/usr/local/epsilon11/bin:/usr/local/bin:/usr/bin:/bin:/usr/X11R6/bin:/home/fran/bin:/usr/local/src/maven-1.0-rc4/bin:.\nMAIL=/var/spool/mail/fran\nKONSOLE_DCOP_SESSION=DCOPRef(konsole-19982,session-4)\nPWD=/home/fran\nINPUTRC=/etc/inputrc\nXMODIFIERS=@im=none\nJAVA_HOME=/usr/java\nLANG=en_US.UTF-8\nGDMSESSION=KDE\nSSH_ASKPASS=/usr/libexec/openssh/gnome-ssh-askpass\nSHLVL=3\nHOME=/home/fran\nLOGNAME=fran\nGROOVY_HOME=/usr/local/groovy\nRESIN_HOME=/usr/local/resin\nPKG_CONFIG_PATH=/usr/local/lib/pkgconfig\nLESSOPEN=|/usr/bin/lesspipe.sh %s\nDISPLAY=:0\nAPACHE_HOME=/usr/local/apache\nDEV=/home/fran/dev/\nG_BROKEN_FILENAMES=1\nCOLORTERM=\nXAUTHORITY=/home/fran/.Xauthority\n_=/usr/bin/env\n\n% groovysh\nLets get Groovy!\n================\nVersion: 1.0-beta-6-SNAPSHOT JVM: 1.4.2_04-b05\nType 'exit' to terminate the shell\nType 'help' for command help\n\n1> print \"helloWorld\"\n2> go\nhelloWorld\n1> quit\n%"
    ],
    [
        "GROOVY-2146",
        "GROOVY-1358",
        "Can't insert null values into database groovy failed to insert a null ( a.k . Undefined ) value into database using GString.\n\nSee source of attached testcase\n\nTestcase return:\ntestNullInsert(InsertNullIntoDBTest)java.sql.SQLException: Unexpected token: ) in statement [INSERT INTO COUNTRY (country,currency) VALUES (?,)] ",
        "getParameters and asSql process / strip nulls incorrectly getParameters(GString) is incorrectly stripping null values out.  \nThis causes asSql(GString,params) to fail to replace null GString variables with empty strings.\n\nexample:\n{code}\ndef x = null\ndef y = 1\nsql.execute(\"\"\"\n   insert into TABLE (X_COL, Y_COL) \n   values (${x},${y})\n{code}\n\nProduces sql of\n{code}\ninsert into TABLE(X_COL, Y_COL)\nvalues (?,)\n{code}\n\nThe trailing variable is completely missing due to getParameters stripping nulls.\nAll functions who call getParameters pass the returned list to asSql who checks for null to know if it should use \"?\" or \"null\" for that variable.\n\nasSql was also missing an iter.remove() when processing a null value from the GString.  If it isn't removed, setParameters() will choke as it will set one too many parameters (due to the ? not existing on the prepared statement)\n\nI'm attaching a patch against head that fixes this."
    ],
    [
        "GROOVY-2211",
        "GROOVY-1659",
        "unable to resolve class by directorynames with blanks eg: \"Eigene Dateien\" unable to resolve class by directorynames with blanks eg: \"Eigene Dateien\"\n\nI make a directory \nC:\\Dokumente und Einstellungen\\Nagy\\Eigene Dateien\\BlankTest\nnext I create a groovy file\n \n------------------------ 8< -------------------------\n//\n//\n//  Dieses Skript dient zum Kl\u00e4ren des Problems\n//  beim aufrufen von Klassen in \"Eigene Datein\"\n//  Es scheint Probleme bei der Verwendung von Blanks\n//  in Verzeichnisnamen zu geben\n//\n// .--update--.\n// -- wann----+-wer+-- was -------------------------------------\n// 01.10.2007 | ny | erstellt\n\n \nimport pckUtil.ClMyUtil\n \ndef oUtil = new ClMyUtil()\nprintln oUtil.Any()\n------------------------ 8< -------------------------\n \nAfterwards: create directory\npckUtil\nin this directory I create a testclass ClMyUtil\n \n------------------------ 8< -------------------------\npackage pckUtil\n \n// ---- Classe ----------------------------------------------------\nclass ClMyUtil {\n// ----------------------------------------------------------------\n   //\n   // Dies ist eine Klasse um das Problem bei\n   // \"Eigene Dateien\" zu klaeren.\n   //\n   //\n   // .--update--.\n   // -- wann----+-wer+-- was -------------------------------------\n   // 01.10.2007 | ny | erstellt\n   //            |    |\n   //            |    |\n   //            |    |\n \n   def Any = {\n      return \"pong\"\n      }\n   }\n------------------------ 8< -------------------------\n \nBack to Applicationroot\ncd ..\n \nNow I run with following error:\n \n$ groovy BlankTest.groovy\norg.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed,\nBlankTest.groovy: 15: unable to resolve class pckUtil.ClMyUtil\n @ line 15, column 1.\n   import pckUtil.ClMyUtil\n   ^\n \n1 error\n \nWhen I copy this application to eg. \"c:\\temp\" its run trouble-free\n \n------------------------ 8< -------------------------\n$ cd\nC:\\temp\\BlankTest\n \n$ groovy BlankTest.groovy\npong\n------------------------ 8< -------------------------\nStrange!\n \nIn \"Eigene Dateien\" I used a old trick from MS-DOS \n \nsubst M: \"%cd%\"\nM:\ngroovy BlankTest.groovy\n \nthis run also ok.\n \nI assume this problems is hidden by blanks in directoryname.\n",
        "Compiler cant find groovy scripts in same directory if path (on windows) has a space I have 2 groovy scripts:\n\nCaller.groovy\n++++++++++++++\nc = new Callee()\nc.hello()\n\nCallee.groovy\n++++++++++++++\nclass Callee {\n  void hello() {\n     println \"hello, world\"\n  }\n}\n\nWhen scripts are in the following directory: \"C:\\fun fun\" I run the following command:\n\nC:>groovy -cp . Caller\norg.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed, Caller.groovy: 1: unable to resolve class Callee\n @ line 1, column 5.\n   c = new Callee()\n       ^\n\n1 error\n\nIf I run from the directory named \"C:\\fun\" it runs fine.\n\nConclusion the space in the directory name causes problems for the classloader.\n\n\n"
    ],
    [
        "GROOVY-2244",
        "GROOVY-1150",
        "Write-only JavaBeans properties cannot be set via the '=' operator This code works well:\n\ndef frame = new JFrame()\nframe.setLocationRelativeTo(null)\n\n\nBut  this one throws exception:\n\ndef frame = new JFrame()\nframe.locationRelativeTo = null\n\n\nBut it is possible to use locationRelativeTo in SwingBuilder, like if\nit is existing property.\n\nExample:\n\n       def swing = new SwingBuilder()\n\n       def frame = swing.frame(\n             title: \"Cool Groovy Frame\",\n             defaultCloseOperation: JFrame.EXIT_ON_CLOSE,\n             preferredSize: [400, 400],\n             size: [400, 400],\n             locationRelativeTo: null,\n       ) {\n               ....\n       }",
        "Strange behavior on property setter Try this:\n\n{code}\nclass Foo {\n  private _xxx\n\n  public void setBar(b) {\n    println \"before setting\"\n    _xxx = b\n    println \"after setting\"  \n  }\n}\n\ndef x = new Foo()\n\nx.bar = 1\nx.bar = 2\n{code}\n\n  When run, the output is: \n\nC:\\Temp>groovy settertest.groovy\nbefore setting\nafter setting\nbefore setting\nafter setting\nCaught: groovy.lang.GroovyRuntimeException: Cannot read property: bar\n\n  even though the property bar was never read. If you add e.g.\nprintln \"goodbye\"\n  as the last line of the script, the exception does not occur.\n"
    ],
    [
        "GROOVY-2368",
        "GROOVY-2367",
        "sudden abstract The test code is:\n\n/////////////////////////////////////\ninterface IFace { \n    List getFoos()\n    String getBar() \n}\n\nabstract class AbClass {\n    abstract IFace getFace() \n}\n\nclass TheClass extends AbClass {\n    IFace face = [\n        getFoos : { [1, 2] },\n        getBar  : { 'aBar' }\n    ] as IFace\n}\n\nnew TheClass().face.foos\n/////////////////////////////////////\n\nIt works fine with canoo build 916. With build 960 and v.1.5 the error takes place:\n\norg.codehaus.groovy.control.MultipleCompilationErrorsException: startup \nfailed, Script0: 10: Can't have an abstract method in a non-abstract class. \nThe class 'TheClass' must be declared abstract or the method 'IFace \ngetFace()' must be implemented.\n @ line 10, column 1.\n1 error",
        "property addition does not overwrite abstract getter definition interface IFace { \n    List getFoos()\n    String getBar() \n}\n\nabstract class AbClass {\n    abstract IFace getFace() \n}\n\nclass TheClass extends AbClass {\n    IFace face = [\n        getFoos : { [1, 2] },\n        getBar  : { 'aBar' }\n    ] as IFace\n}\n\nnew TheClass().face.foos"
    ],
    [
        "GROOVY-2535",
        "GROOVY-2208",
        "lost LineNumberTable in groovyc-produced bytecode We observed that in come code produced by Groovy compiler there are missing line number attributes. Consider example:\n\n~~~~~~~~~~~~~~~~~~\nclass DependencyManager {\n   Map artifactDescriptors = []\n}\n~~~~~~~~~~~~~~~~~~\n\nIn generated .class-file LineNumbertable attribute for initial code of DependencyManager class is absent. In same time if we use class initializer:\n~~~~~~~~~~~~~~~~~~\nclass DependencyManager {\n   {\n       Map artifactDescriptors = []\n   }\n}\n~~~~~~~~~~~~~~~~~~\nwe will see correct line number table:\n\n LineNumberTable:\n  line 2: 108\n  line 3: 108\n\nThis annoying discrepancy complicates debugger's work.",
        "debug info not generated We've recently been getting bug reports on JetGroovy plugin not being able to stop at breakpoints in Groovy. After spending some time with this bug, it seems that groovyc ia not generating LineNumberTable in some cases. For example in this simple script:\n\n<code>\ndef foo()\n{\n    print \"Hello World\"\n}\n\nfoo()\n</code>\n"
    ],
    [
        "GROOVY-2559",
        "GROOVY-2380",
        "java.lang.NoClassDefFoundError: java/lang/Appendable $ groovysh\nFATAL: java.lang.NoClassDefFoundError: java/lang/Appendable\njava.lang.NoClassDefFoundError: java/lang/Appendable\n        at java.lang.ClassLoader.defineClass0(Native Method)\n        at java.lang.ClassLoader.defineClass(ClassLoader.java:539)\n        at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:123)\n        at java.net.URLClassLoader.defineClass(URLClassLoader.java:251)\n        at java.net.URLClassLoader.access$100(URLClassLoader.java:55)\n        at java.net.URLClassLoader$1.run(URLClassLoader.java:194)\n        at java.security.AccessController.doPrivileged(Native Method)\n        at java.net.URLClassLoader.findClass(URLClassLoader.java:187)\n        at org.codehaus.groovy.tools.RootLoader.oldFindClass(RootLoader.java:142)\n        at org.codehaus.groovy.tools.RootLoader.loadClass(RootLoader.java:114)\n        at java.lang.ClassLoader.loadClass(ClassLoader.java:235)\n        at java.lang.ClassLoader.loadClassInternal(ClassLoader.java:302)\n        at jline.ConsoleReader.<init>(ConsoleReader.java:140)\n        at jline.ConsoleReader.<init>(ConsoleReader.java:188)\n        at jline.ConsoleReader.<init>(ConsoleReader.java:183)\n        at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)\n        at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:39\n)\n        at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl\n.java:27)\n        at java.lang.reflect.Constructor.newInstance(Constructor.java:274)\n        at org.codehaus.groovy.runtime.MetaClassHelper.doConstructorInvoke(MetaClassHelper.java:528)\n        at groovy.lang.MetaClassImpl.doConstructorInvoke(MetaClassImpl.java:2347)\n        at groovy.lang.MetaClassImpl.invokeConstructor(MetaClassImpl.java:1244)\n        at groovy.lang.MetaClassImpl.invokeConstructor(MetaClassImpl.java:1174)\n        at org.codehaus.groovy.runtime.InvokerHelper.invokeConstructorOf(InvokerHelper.java:805)\n        at org.codehaus.groovy.runtime.ScriptBytecodeAdapter.invokeNewN(ScriptBytecodeAdapter.java:227\n)\n        at org.codehaus.groovy.tools.shell.InteractiveShellRunner.<init>(InteractiveShellRunner.groovy\n:48)\n        at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)\n        at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:39\n)\n        at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl\n.java:27)\n        at java.lang.reflect.Constructor.newInstance(Constructor.java:274)\n        at org.codehaus.groovy.runtime.MetaClassHelper.doConstructorInvoke(MetaClassHelper.java:528)\n        at groovy.lang.MetaClassImpl.doConstructorInvoke(MetaClassImpl.java:2347)\n        at groovy.lang.MetaClassImpl.invokeConstructor(MetaClassImpl.java:1244)\n        at groovy.lang.MetaClassImpl.invokeConstructor(MetaClassImpl.java:1174)\n        at org.codehaus.groovy.runtime.InvokerHelper.invokeConstructorOf(InvokerHelper.java:805)\n        at org.codehaus.groovy.runtime.ScriptBytecodeAdapter.invokeNewN(ScriptBytecodeAdapter.java:227\n)\n        at org.codehaus.groovy.tools.shell.Groovysh.run(Groovysh.groovy:515)\n        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n        at java.lang.reflect.Method.invoke(Method.java:324)\n        at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:86)\n        at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:226)\n        at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:899)\n        at org.codehaus.groovy.runtime.ScriptBytecodeAdapter.invokeMethodOnCurrentN(ScriptBytecodeAdap\nter.java:77)\n        at org.codehaus.groovy.tools.shell.Groovysh.run(Groovysh.groovy:482)\n        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n        at java.lang.reflect.Method.invoke(Method.java:324)\n        at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:86)\n        at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:226)\n        at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:899)\n        at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:740)\n        at org.codehaus.groovy.runtime.InvokerHelper.invokePogoMethod(InvokerHelper.java:777)\n        at org.codehaus.groovy.runtime.InvokerHelper.invokeMethod(InvokerHelper.java:757)\n        at org.codehaus.groovy.runtime.ScriptBytecodeAdapter.invokeMethodN(ScriptBytecodeAdapter.java:\n167)\n        at org.codehaus.groovy.tools.shell.Main.main(Main.groovy:127)\n        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n        at java.lang.reflect.Method.invoke(Method.java:324)\n        at org.codehaus.groovy.tools.GroovyStarter.rootLoader(GroovyStarter.java:101)\n        at org.codehaus.groovy.tools.GroovyStarter.main(GroovyStarter.java:130)\n",
        "groovysh not working with JVM 1.4.2_06-b03 groovysh doesn't seem to work with JVM 1.4.2. It looks for java/lang/Appendable which is an Interface since JVM 1.5.\n\nStack trace generated:\n\nlinux-server:~ # groovysh\nFATAL: java.lang.NoClassDefFoundError: java/lang/Appendable\njava.lang.NoClassDefFoundError: java/lang/Appendable\n        at java.lang.ClassLoader.defineClass0(Native Method)\n        at java.lang.ClassLoader.defineClass(ClassLoader.java:539)\n        at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:123)\n        at java.net.URLClassLoader.defineClass(URLClassLoader.java:251)\n        at java.net.URLClassLoader.access$100(URLClassLoader.java:55)\n        at java.net.URLClassLoader$1.run(URLClassLoader.java:194)\n        at java.security.AccessController.doPrivileged(Native Method)\n        at java.net.URLClassLoader.findClass(URLClassLoader.java:187)\n        at org.codehaus.groovy.tools.RootLoader.oldFindClass(RootLoader.java:142)\n        at org.codehaus.groovy.tools.RootLoader.loadClass(RootLoader.java:114)\n        at java.lang.ClassLoader.loadClass(ClassLoader.java:235)\n        at java.lang.ClassLoader.loadClassInternal(ClassLoader.java:302)\n        at jline.ConsoleReader.<init>(ConsoleReader.java:140)\n        at jline.ConsoleReader.<init>(ConsoleReader.java:188)\n        at jline.ConsoleReader.<init>(ConsoleReader.java:183)\n        at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)\n        at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:39)\n        at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:27)\n        at java.lang.reflect.Constructor.newInstance(Constructor.java:274)\n        at org.codehaus.groovy.runtime.MetaClassHelper.doConstructorInvoke(MetaClassHelper.java:526)\n        at groovy.lang.MetaClassImpl.doConstructorInvoke(MetaClassImpl.java:2284)\n        at groovy.lang.MetaClassImpl.invokeConstructor(MetaClassImpl.java:1179)\n        at groovy.lang.MetaClassImpl.invokeConstructor(MetaClassImpl.java:1109)\n        at org.codehaus.groovy.runtime.Invoker.invokeConstructorOf(Invoker.java:127)\n        at org.codehaus.groovy.runtime.InvokerHelper.invokeConstructorOf(InvokerHelper.java:95)\n        at org.codehaus.groovy.runtime.ScriptBytecodeAdapter.invokeNewN(ScriptBytecodeAdapter.java:225)\n        at org.codehaus.groovy.tools.shell.InteractiveShellRunner.<init>(InteractiveShellRunner.groovy:48)\n        at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)\n        at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:39)\n        at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:27)\n        at java.lang.reflect.Constructor.newInstance(Constructor.java:274)\n        at org.codehaus.groovy.runtime.MetaClassHelper.doConstructorInvoke(MetaClassHelper.java:526)\n        at groovy.lang.MetaClassImpl.doConstructorInvoke(MetaClassImpl.java:2284)\n        at groovy.lang.MetaClassImpl.invokeConstructor(MetaClassImpl.java:1179)\n        at groovy.lang.MetaClassImpl.invokeConstructor(MetaClassImpl.java:1109)\n        at org.codehaus.groovy.runtime.Invoker.invokeConstructorOf(Invoker.java:127)\n        at org.codehaus.groovy.runtime.InvokerHelper.invokeConstructorOf(InvokerHelper.java:95)\n        at org.codehaus.groovy.runtime.ScriptBytecodeAdapter.invokeNewN(ScriptBytecodeAdapter.java:225)\n        at org.codehaus.groovy.tools.shell.Groovysh.run(Groovysh.groovy:513)\n        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n        at java.lang.reflect.Method.invoke(Method.java:324)\n        at org.codehaus.groovy.runtime.metaclass.ReflectionMetaMethod.invoke(ReflectionMetaMethod.java:56)\n        at org.codehaus.groovy.runtime.MetaClassHelper.doMethodInvoke(MetaClassHelper.java:599)\n        at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:903)\n        at org.codehaus.groovy.runtime.ScriptBytecodeAdapter.invokeMethodOnCurrentN(ScriptBytecodeAdapter.java:75)\n        at org.codehaus.groovy.tools.shell.Groovysh.run(Groovysh.groovy:482)\n        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n        at java.lang.reflect.Method.invoke(Method.java:324)\n        at org.codehaus.groovy.runtime.metaclass.ReflectionMetaMethod.invoke(ReflectionMetaMethod.java:56)\n        at org.codehaus.groovy.runtime.MetaClassHelper.doMethodInvoke(MetaClassHelper.java:599)\n        at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:903)\n        at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:742)\n        at org.codehaus.groovy.runtime.Invoker.invokePogoMethod(Invoker.java:99)\n        at org.codehaus.groovy.runtime.Invoker.invokeMethod(Invoker.java:79)\n        at org.codehaus.groovy.runtime.InvokerHelper.invokeMethod(InvokerHelper.java:66)\n        at org.codehaus.groovy.runtime.ScriptBytecodeAdapter.invokeMethodN(ScriptBytecodeAdapter.java:165)\n        at org.codehaus.groovy.tools.shell.Main.main(Main.groovy:119)\n        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n        at java.lang.reflect.Method.invoke(Method.java:324)\n        at org.codehaus.groovy.tools.GroovyStarter.rootLoader(GroovyStarter.java:101)\n        at org.codehaus.groovy.tools.GroovyStarter.main(GroovyStarter.java:130)\n"
    ],
    [
        "GROOVY-2591",
        "GROOVY-2590",
        "Groovy Ant Task is not executing Groovy Test Cases as the Command Line does Trying to execute a Groovy Test Case using the Groovy Ant Tasks fails because it is complaining about a missing main() method:\n\ngroovy.lang.MissingMethodException: No signature of method: org.guilder.plugin.PluginTest.main() is applicable for argument types: ([Ljava.lang.String;) values: {[]}\n\tat org.codehaus.groovy.runtime.ScriptBytecodeAdapter.unwrap(ScriptBytecodeAdapter.java:54)\n\tat org.codehaus.groovy.runtime.ScriptBytecodeAdapter.unwrap(ScriptBytecodeAdapter.java:59)\n\tat org.codehaus.groovy.runtime.ScriptBytecodeAdapter.invokeMethodN(ScriptBytecodeAdapter.java:169)\n\tat org.guilder.plugin.PluginTest.invokeMethod(PluginTest.groovy)\n\tat org.codehaus.groovy.runtime.InvokerHelper$2.run(InvokerHelper.java:426)\n\tat org.codehaus.groovy.ant.Groovy.execGroovy(Groovy.java:348)\n\nThis happens when I use Ant through the command line as well as using AntBuilder. This is the build.xml script I use:\n\nproject>\n  <path id=\"my.classpath\">\n      <fileset dir=\"/Java/groovy/lib\">\n        <include name=\"**/*.jar\"/>\n      </fileset>\n    </path>\n  <target name=\"run\">\n         <taskdef name=\"groovy\"\n             classname=\"org.codehaus.groovy.ant.Groovy\"\n             classpathref=\"my.classpath\"/>\n        <groovy src=\"org/guilder/plugin/PluginTest.groovy\">\n        </groovy>\n    </target>\n</project>\n\nExecuting the Script through: 'groovy org/guilder/plugin/PluginTest.groovy' it works fine.\n\nUnfortunately I could not figure out how the Groovy Command Line tool does handle that otherwise I would created a patch.\n\nAny ideas?\n\n-Andy",
        "MissingMethodException in Unit Test build.xml:61: groovy.lang.MissingMethodException: No signature of method: org.reverttoconsole.mymediamanager.integration.SimpleTest.main() is applicable for argument types: ([Ljava.lang.String;) values: {[]}\n\nrunning the test reliably reproduced the errors for me. I attached my simple project without dependencies. There are like 5 files.\n\nthe bin dir is a red herring- the groovy plugin prefers this dir, but the classes produced by the ant script all end up in web/WEB-INF/classes,  and that's in the classpath.\n"
    ],
    [
        "GROOVY-2607",
        "GROOVY-2567",
        "AntBuilder input task error Hi, with new version of groovy-al jar I'm getting a StackOverflowError\n\nI've attached two files - the only difference is the version of groovy jar. Is something changed since 1.0 ?\n\nMore details from the stack trace ( from different build.xml file):\n    [input] test\n: java.lang.StackOverflowError\n        at org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:115)\n        at org.apache.tools.ant.Task.perform(Task.java:348)\n        at groovy.util.AntBuilder.nodeCompleted(AntBuilder.java:178)\n        at groovy.util.BuilderSupport.doInvokeMethod(BuilderSupport.java:153)\n        at groovy.util.AntBuilder.doInvokeMethod(AntBuilder.java:132)\n        at groovy.util.BuilderSupport.invokeMethod(BuilderSupport.java:64)\n        at org.codehaus.groovy.runtime.InvokerHelper.invokePogoMethod(InvokerHelper.java:781)\n        at org.codehaus.groovy.runtime.InvokerHelper.invokeMethod(InvokerHelper.java:757)\n        at org.codehaus.groovy.runtime.ScriptBytecodeAdapter.invokeMethodN(ScriptBytecodeAdapter.java:167)\n        at embedded_script_in__home_piotrus_IdeaProjects_september_vine_build.run(embedded_script_in__home_piotrus_IdeaProjects_september_vine_build.xml:4)\n        at org.codehaus.groovy.ant.Groovy.execGroovy(Groovy.java:348)\n        at org.codehaus.groovy.ant.Groovy.execute(Groovy.java:228)\n        at org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:288)\n        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n        at java.lang.reflect.Method.invoke(Method.java:597)\n        at org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:105)\n        at org.apache.tools.ant.Task.perform(Task.java:348)\n        at org.apache.tools.ant.Target.execute(Target.java:357)\n        at org.apache.tools.ant.Target.performTasks(Target.java:385)\n        at org.apache.tools.ant.Project.executeSortedTargets(Project.java:1329)\n        at org.apache.tools.ant.Project.executeTarget(Project.java:1298)\n        at org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:41)\n        at org.apache.tools.ant.Project.executeTargets(Project.java:1181)\n        at org.apache.tools.ant.Main.runBuild(Main.java:698)\n        at org.apache.tools.ant.Main.startAnt(Main.java:199)\n        at org.apache.tools.ant.launch.Launcher.run(Launcher.java:257)\n        at org.apache.tools.ant.launch.Launcher.main(Launcher.java:104)\nCaused by: java.lang.StackOverflowError\n        at java.lang.ref.ReferenceQueue.poll(ReferenceQueue.java:82)\n        at java.util.WeakHashMap.expungeStaleEntries(WeakHashMap.java:274)\n",
        "Antbuilder/Groovy ant task that uses forking java task causes StackOverflow in ANT script While developing an ANT build.xml script to test some aspects of grails, we need a <groovy> task that invokes an ANT macro which uses a forked <java> task.\n\nThis consistently causes a stack overflow in ANT, apparently in the thread that ANT uses to monitor the output of the forked task.\n\nTrace:\n    [java] Exception in thread \"Thread-26\" java.lang.StackOverflowError\n     [java] \tat org.apache.tools.ant.Project.getThreadTask(Project.java:2300)\n     [java] \tat org.apache.tools.ant.Project.demuxInput(Project.java:1244)\n     [java] \tat org.apache.tools.ant.DemuxInputStream.read(DemuxInputStream.java:70)\n     [java] \tat java.io.FilterInputStream.read(FilterInputStream.java:111)\n     [java] \tat org.apache.tools.ant.taskdefs.Redirector.handleInput(Redirector.java:666)\n     [java] \tat org.apache.tools.ant.taskdefs.Java.handleInput(Java.java:667)\n     [java] \tat org.apache.tools.ant.UnknownElement.handleInput(UnknownElement.java:229)\n     [java] \tat org.apache.tools.ant.Project.demuxInput(Project.java:1248)\n     [java] \tat org.apache.tools.ant.DemuxInputStream.read(DemuxInputStream.java:70)\n     [java] \tat java.io.FilterInputStream.read(FilterInputStream.java:111)\n     [java] \tat org.apache.tools.ant.taskdefs.Redirector.handleInput(Redirector.java:666)\n     [java] \tat org.apache.tools.ant.taskdefs.Java.handleInput(Java.java:667)\n     [java] \tat org.apache.tools.ant.UnknownElement.handleInput(UnknownElement.java:229)\n     [java] \tat org.apache.tools.ant.Project.demuxInput(Project.java:1248)\n     [java] \tat org.apache.tools.ant.DemuxInputStream.read(DemuxInputStream.java:70)\n     [java] \tat java.io.FilterInputStream.read(FilterInputStream.java:111)\n     [java] \tat org.apache.tools.ant.taskdefs.Redirector.handleInput(Redirector.java:666)\n     [java] \tat org.apache.tools.ant.taskdefs.Java.handleInput(Java.java:667)\n     [java] \tat org.apache.tools.ant.UnknownElement.handleInput(UnknownElement.java:229)\n\n\nScript that suffers the problem is attached - its the functional-test target's use of <groovy> to call the \"grails\" macrodef that is the problem when the macrodef uses fork=\"true\" on the <java> task. If fork=false there is no stack overflow.\n"
    ],
    [
        "GROOVY-2619",
        "GROOVY-2523",
        "for ( ; ite.hasNext() ; ) does not compile Next does not compile:\n\nfor ( ; ite.hasNext() ; ) ... does not compile, \nbut for ( int i = 0; ite.hasNext() ; ) is compiling. All antoher code is the same.",
        "compiler complains for loop has  empty body  compiler complains for loop has  empty body \n\n{code}\nfor (int i = 0; i < 10; i++) ;\n{code}\n\n\ngroovy> for (int i = 0; i < 10; i++) ;\n\nException thrown: org.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed, Script1: 1: unexpected token: ; @ line 1, column 30.\n1 error\n"
    ],
    [
        "GROOVY-2673",
        "GROOVY-2672",
        "groovysh catch an exception in the multibyte environment at org.codehaus.groovy.tools.shell.util.ANSI.detect(ANSI.java:48) (Linux Platform) Exception in thread \"AWT-EventQueue-0\" java.lang.NullPointerException\n        at com.sun.java.swing.plaf.gtk.GTKLookAndFeel.initSystemColorDefaults(GTKLookAndFeel.java:1267)\n        at com.sun.java.swing.plaf.gtk.GTKLookAndFeel.loadStyles(GTKLookAndFeel.java:1509)\n        at com.sun.java.swing.plaf.gtk.GTKLookAndFeel.access$000(GTKLookAndFeel.java:37)\n        at com.sun.java.swing.plaf.gtk.GTKLookAndFeel$WeakPCL$1.run(GTKLookAndFeel.java:1449)\n        at java.awt.event.InvocationEvent.dispatch(InvocationEvent.java:209)\n        at java.awt.EventQueue.dispatchEvent(EventQueue.java:597)\n        at java.awt.EventDispatchThread.pumpOneEventForFilters(EventDispatchThread.java:273)\n        at java.awt.EventDispatchThread.pumpEventsForFilter(EventDispatchThread.java:183)\n        at java.awt.EventDispatchThread.pumpEventsForHierarchy(EventDispatchThread.java:173)\n        at java.awt.EventDispatchThread.pumpEvents(EventDispatchThread.java:168)\n        at java.awt.EventDispatchThread.pumpEvents(EventDispatchThread.java:160)\n        at java.awt.EventDispatchThread.run(EventDispatchThread.java:121)\njava.lang.reflect.InvocationTargetException\n        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n        at java.lang.reflect.Method.invoke(Method.java:597)\n        at org.codehaus.groovy.tools.GroovyStarter.rootLoader(GroovyStarter.java:101)\n        at org.codehaus.groovy.tools.GroovyStarter.main(GroovyStarter.java:130)\nCaused by: java.lang.NullPointerException\n        at javax.swing.plaf.synth.SynthLookAndFeel$AATextListener.propertyChange(SynthLookAndFeel.java:793)\n        at java.beans.PropertyChangeSupport.firePropertyChange(PropertyChangeSupport.java:339)\n        at java.beans.PropertyChangeSupport.firePropertyChange(PropertyChangeSupport.java:347)\n        at java.beans.PropertyChangeSupport.firePropertyChange(PropertyChangeSupport.java:276)\n        at java.awt.Toolkit.setDesktopProperty(Toolkit.java:1784)\n        at sun.awt.SunToolkit.fireDesktopFontPropertyChanges(SunToolkit.java:1714)\n        at sun.awt.SunToolkit.setAAFontSettingsCondition(SunToolkit.java:1759)\n        at sun.swing.SwingUtilities2$AATextInfo.getAATextInfo(SwingUtilities2.java:119)\n        at com.sun.java.swing.plaf.gtk.GTKLookAndFeel.initComponentDefaults(GTKLookAndFeel.java:1258)\n        at com.sun.java.swing.plaf.gtk.GTKLookAndFeel.getDefaults(GTKLookAndFeel.java:294)\n        at javax.swing.UIManager.setLookAndFeel(UIManager.java:537)\n        at javax.swing.UIManager.setLookAndFeel(UIManager.java:581)\n        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n        at java.lang.reflect.Method.invoke(Method.java:597)\n        at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:102)\n        at org.codehaus.groovy.runtime.callsite.StaticMetaMethodSite$StaticMetaMethodSiteNoUnwrapNoCoerce.invoke(StaticMetaMethodSite.java:98)\n        at org.codehaus.groovy.tools.shell.Main.main(Main.groovy:116)\n        ... 6 more\nException in thread \"AWT-EventQueue-0\" java.lang.NullPointerException\n        at com.sun.java.swing.plaf.gtk.GTKLookAndFeel.initSystemColorDefaults(GTKLookAndFeel.java:1267)\n        at com.sun.java.swing.plaf.gtk.GTKLookAndFeel.loadStyles(GTKLookAndFeel.java:1509)\n        at com.sun.java.swing.plaf.gtk.GTKLookAndFeel.access$000(GTKLookAndFeel.java:37)\n        at com.sun.java.swing.plaf.gtk.GTKLookAndFeel$WeakPCL$1.run(GTKLookAndFeel.java:1449)\n        at java.awt.event.InvocationEvent.dispatch(InvocationEvent.java:209)\n        at java.awt.EventQueue.dispatchEvent(EventQueue.java:597)\n        at java.awt.EventDispatchThread.pumpOneEventForFilters(EventDispatchThread.java:273)\n        at java.awt.EventDispatchThread.pumpEventsForFilter(EventDispatchThread.java:183)\n        at java.awt.EventDispatchThread.pumpEventsForHierarchy(EventDispatchThread.java:173)\n        at java.awt.EventDispatchThread.pumpEvents(EventDispatchThread.java:168)\n        at java.awt.EventDispatchThread.pumpEvents(EventDispatchThread.java:160)\n        at java.awt.EventDispatchThread.run(EventDispatchThread.java:121)\n\njava.lang.IllegalStateException: Shutdown in progress\n        at java.lang.ApplicationShutdownHooks.add(ApplicationShutdownHooks.java:39)\n        at java.lang.Runtime.addShutdownHook(Runtime.java:192)\n        at jline.UnixTerminal.initializeTerminal(UnixTerminal.java:97)\n        at jline.Terminal.setupTerminal(Terminal.java:75)\n        at jline.Terminal.getTerminal(Terminal.java:26)\n        at org.codehaus.groovy.tools.shell.util.ANSI.detect(ANSI.java:48)\n        at org.codehaus.groovy.tools.shell.util.ANSI.isDetected(ANSI.java:59)\n        at org.codehaus.groovy.tools.shell.util.ANSI.isEnabled(ANSI.java:70)\n        at org.codehaus.groovy.tools.shell.util.ANSI$Buffer.attrib(ANSI.java:225)\n        at org.codehaus.groovy.tools.shell.util.ANSI$Renderer.evaluate(ANSI.java:313)\n        at org.codehaus.groovy.tools.shell.util.ANSI$Renderer.render(ANSI.java:289)\n        at org.codehaus.groovy.tools.shell.util.ANSI$RenderWriter.write(ANSI.java:378)\n        at java.io.PrintWriter.print(PrintWriter.java:559)\n        at java.io.PrintWriter.println(PrintWriter.java:695)\n        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n        at java.lang.reflect.Method.invoke(Method.java:597)\n        at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:102)\n        at org.codehaus.groovy.runtime.callsite.PojoMetaMethodSite$PojoMetaMethodSiteNoUnwrapNoCoerce.invoke(PojoMetaMethodSite.java:127)\n        at org.codehaus.groovy.tools.shell.Main$_main_closure2.doCall(Main.groovy:109)\n        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n        at java.lang.reflect.Method.invoke(Method.java:597)\n        at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:102)\n        at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:229)\n        at org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:252)\n        at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:716)\n        at org.codehaus.groovy.runtime.callsite.PogoMetaClassSite.invoke(PogoMetaClassSite.java:34)\n        at org.codehaus.groovy.runtime.callsite.CallSite.callCurrent(CallSite.java:118)\n        at org.codehaus.groovy.tools.shell.Main$_main_closure2.doCall(Main.groovy)\n        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n        at java.lang.reflect.Method.invoke(Method.java:597)\n        at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:102)\n        at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:229)\n        at org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:252)\n        at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:716)\n        at groovy.lang.Closure.call(Closure.java:292)\n        at groovy.lang.Closure.call(Closure.java:287)\n        at groovy.lang.Closure.run(Closure.java:368)\n        at java.lang.Thread.run(Thread.java:619)\nWARNING: Abnormal JVM shutdown detected",
        "groovysh catch an exception on the multibyte environment.  LANG=LANG=zh_CN.UTF-8,  I start groovysh, there is an exception:\n\nException in thread \"AWT-EventQueue-0\" java.lang.NullPointerException\n        at com.sun.java.swing.plaf.gtk.GTKLookAndFeel.initSystemColorDefaults(GTKLookAndFeel.java:1267)\n        at com.sun.java.swing.plaf.gtk.GTKLookAndFeel.loadStyles(GTKLookAndFeel.java:1509)\n        at com.sun.java.swing.plaf.gtk.GTKLookAndFeel.access$000(GTKLookAndFeel.java:37)\n        at com.sun.java.swing.plaf.gtk.GTKLookAndFeel$WeakPCL$1.run(GTKLookAndFeel.java:1449)\n        at java.awt.event.InvocationEvent.dispatch(InvocationEvent.java:209)\n        at java.awt.EventQueue.dispatchEvent(EventQueue.java:597)\n        at java.awt.EventDispatchThread.pumpOneEventForFilters(EventDispatchThread.java:273)\n        at java.awt.EventDispatchThread.pumpEventsForFilter(EventDispatchThread.java:183)\n        at java.awt.EventDispatchThread.pumpEventsForHierarchy(EventDispatchThread.java:173)\n        at java.awt.EventDispatchThread.pumpEvents(EventDispatchThread.java:168)\n        at java.awt.EventDispatchThread.pumpEvents(EventDispatchThread.java:160)\n        at java.awt.EventDispatchThread.run(EventDispatchThread.java:121)\njava.lang.reflect.InvocationTargetException\n        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n        at java.lang.reflect.Method.invoke(Method.java:597)\n        at org.codehaus.groovy.tools.GroovyStarter.rootLoader(GroovyStarter.java:101)\n        at org.codehaus.groovy.tools.GroovyStarter.main(GroovyStarter.java:130)\nCaused by: java.lang.NullPointerException\n        at javax.swing.plaf.synth.SynthLookAndFeel$AATextListener.propertyChange(SynthLookAndFeel.java:793)\n        at java.beans.PropertyChangeSupport.firePropertyChange(PropertyChangeSupport.java:339)\n        at java.beans.PropertyChangeSupport.firePropertyChange(PropertyChangeSupport.java:347)\n        at java.beans.PropertyChangeSupport.firePropertyChange(PropertyChangeSupport.java:276)\n        at java.awt.Toolkit.setDesktopProperty(Toolkit.java:1784)\n        at sun.awt.SunToolkit.fireDesktopFontPropertyChanges(SunToolkit.java:1714)\n        at sun.awt.SunToolkit.setAAFontSettingsCondition(SunToolkit.java:1759)\n        at sun.swing.SwingUtilities2$AATextInfo.getAATextInfo(SwingUtilities2.java:119)\n        at com.sun.java.swing.plaf.gtk.GTKLookAndFeel.initComponentDefaults(GTKLookAndFeel.java:1258)\n        at com.sun.java.swing.plaf.gtk.GTKLookAndFeel.getDefaults(GTKLookAndFeel.java:294)\n        at javax.swing.UIManager.setLookAndFeel(UIManager.java:537)\n        at javax.swing.UIManager.setLookAndFeel(UIManager.java:581)\n        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n        at java.lang.reflect.Method.invoke(Method.java:597)\n        at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:102)\n        at org.codehaus.groovy.runtime.callsite.StaticMetaMethodSite$StaticMetaMethodSiteNoUnwrapNoCoerce.invoke(StaticMetaMethodSite.java:98)\n        at org.codehaus.groovy.tools.shell.Main.main(Main.groovy:116)\n        ... 6 more\nException in thread \"AWT-EventQueue-0\" java.lang.NullPointerException\n        at com.sun.java.swing.plaf.gtk.GTKLookAndFeel.initSystemColorDefaults(GTKLookAndFeel.java:1267)\n        at com.sun.java.swing.plaf.gtk.GTKLookAndFeel.loadStyles(GTKLookAndFeel.java:1509)\n        at com.sun.java.swing.plaf.gtk.GTKLookAndFeel.access$000(GTKLookAndFeel.java:37)\n        at com.sun.java.swing.plaf.gtk.GTKLookAndFeel$WeakPCL$1.run(GTKLookAndFeel.java:1449)\n        at java.awt.event.InvocationEvent.dispatch(InvocationEvent.java:209)\n        at java.awt.EventQueue.dispatchEvent(EventQueue.java:597)\n        at java.awt.EventDispatchThread.pumpOneEventForFilters(EventDispatchThread.java:273)\n        at java.awt.EventDispatchThread.pumpEventsForFilter(EventDispatchThread.java:183)\n        at java.awt.EventDispatchThread.pumpEventsForHierarchy(EventDispatchThread.java:173)\n        at java.awt.EventDispatchThread.pumpEvents(EventDispatchThread.java:168)\n        at java.awt.EventDispatchThread.pumpEvents(EventDispatchThread.java:160)\n        at java.awt.EventDispatchThread.run(EventDispatchThread.java:121)\n\njava.lang.IllegalStateException: Shutdown in progress\n        at java.lang.ApplicationShutdownHooks.add(ApplicationShutdownHooks.java:39)\n        at java.lang.Runtime.addShutdownHook(Runtime.java:192)\n        at jline.UnixTerminal.initializeTerminal(UnixTerminal.java:97)\n        at jline.Terminal.setupTerminal(Terminal.java:75)\n        at jline.Terminal.getTerminal(Terminal.java:26)\n        at org.codehaus.groovy.tools.shell.util.ANSI.detect(ANSI.java:48)\n        at org.codehaus.groovy.tools.shell.util.ANSI.isDetected(ANSI.java:59)\n        at org.codehaus.groovy.tools.shell.util.ANSI.isEnabled(ANSI.java:70)\n        at org.codehaus.groovy.tools.shell.util.ANSI$Buffer.attrib(ANSI.java:225)\n        at org.codehaus.groovy.tools.shell.util.ANSI$Renderer.evaluate(ANSI.java:313)\n        at org.codehaus.groovy.tools.shell.util.ANSI$Renderer.render(ANSI.java:289)\n        at org.codehaus.groovy.tools.shell.util.ANSI$RenderWriter.write(ANSI.java:378)\n        at java.io.PrintWriter.print(PrintWriter.java:559)\n        at java.io.PrintWriter.println(PrintWriter.java:695)\n        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n        at java.lang.reflect.Method.invoke(Method.java:597)\n        at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:102)\n        at org.codehaus.groovy.runtime.callsite.PojoMetaMethodSite$PojoMetaMethodSiteNoUnwrapNoCoerce.invoke(PojoMetaMethodSite.java:127)\n        at org.codehaus.groovy.tools.shell.Main$_main_closure2.doCall(Main.groovy:109)\n        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n        at java.lang.reflect.Method.invoke(Method.java:597)\n        at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:102)\n        at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:229)\n        at org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:252)\n        at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:716)\n        at org.codehaus.groovy.runtime.callsite.PogoMetaClassSite.invoke(PogoMetaClassSite.java:34)\n        at org.codehaus.groovy.runtime.callsite.CallSite.callCurrent(CallSite.java:118)\n        at org.codehaus.groovy.tools.shell.Main$_main_closure2.doCall(Main.groovy)\n        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n        at java.lang.reflect.Method.invoke(Method.java:597)\n        at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:102)\n        at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:229)\n        at org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:252)\n        at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:716)\n        at groovy.lang.Closure.call(Closure.java:292)\n        at groovy.lang.Closure.call(Closure.java:287)\n        at groovy.lang.Closure.run(Closure.java:368)\n        at java.lang.Thread.run(Thread.java:619)\nWARNING: Abnormal JVM shutdown detected\n"
    ],
    [
        "GROOVY-2718",
        "GROOVY-636",
        "CLONE -JAVA_HOME with Backslash at end results in Error JAVA_HOME not set On my system I have JAVA_HOME set to \"C:\\JDK\\\"\nThis results in an error message when starting GROOVY:\n\"JAVA_HOME not set\"\n\nWhen I change JAVA_HOME to \"C:\\JDK\" everything works fine.\n\nThis can be a litte disturbing for new users and should be easy to fix, I guess.\n\nGreetings,\n   Malte",
        "JAVA_HOME with Backslash at end results in Error JAVA_HOME not set On my system I have JAVA_HOME set to \"C:\\JDK\\\"\nThis results in an error message when starting GROOVY:\n\"JAVA_HOME not set\"\n\nWhen I change JAVA_HOME to \"C:\\JDK\" everything works fine.\n\nThis can be a litte disturbing for new users and should be easy to fix, I guess.\n\nGreetings,\n   Malte"
    ],
    [
        "GROOVY-2732",
        "GROOVY-2599",
        "GString doesn't call correct toString method when it's been changed via the metaClass mechanism This is best shown by a small example.  I've attached a trivial patch as well.\n\nclass A {\n    String toString() {\n        \"unchanged\";\n    }\n}\n\nA.metaClass.toString = { ->\n    \"changed\";\n}\n\ndef a = new A();\nprintln a.toString();\nprintln \"${a}\";\n\nbrandon@Brandon:~/localtmp/groovy-1.5.4$ unset GROOVY_HOME\nbrandon@Brandon:~/localtmp/groovy-1.5.4$ groovy-unpatched test.groovy\nchanged\nunchanged\nbrandon@Brandon:~/localtmp/groovy-1.5.4$ groovy test.groovy\nchanged\nchanged\n",
        "unable to overwritel toString() via MOP in some cases If toString is overridden via the metaClass then \"${obj}\" !=  obj.toString().\n\nTest case below\n{code}\nclass DateTest extends GroovyTestCase {\n\n    void testToString(){\n\n        Date.metaClass.toString = { ->\n            'boogie'\n        }\n       \n        def date = new Date()\n        assertEquals('boogie', date.toString())\n        assertEquals( date.toString(), \"${date}\") //fails\n    }\n}\n{code}\nPaul King gave this pointer as to where the problem is:\n\n\"Yes, the final line of InvokerHelper.format() should be something like:\n\n       return (String) invokeMethod(arguments, \"toString\", EMPTY_ARGS);\n       //return arguments.toString();\n\nto make your example work.\""
    ],
    [
        "GROOVY-2745",
        "GROOVY-1276",
        "the gsp template can not support unicode(utf-8) a test gsp file is (chinese encoding):\n\n<html>\n<head>\n    <meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\"/>\n    <title>&#27979;&#35797;&#39029;</title>\n</head>\n<body>\n<%\n    print \"groopvy &#27979;&#35797;&#39029;\"\n%>\n</body>\n</html>\n\nAfter browser the groovy.servlet.TemplateServlet source code,I find that the service method only set the ContentType to \"text/html\" .There no information about encoding.\nSo I add the encoding support for it,you can see the attachment(diff format),and you can configure it throgh the web.xml",
        "GroovyServlet lacks possibility to specify encoding The GroovyServlet should accept an init- parameter allowing to specify the encoding to use to read the Groovy scripts. \n\nCurrently the platform default value is used what would be the correct default value but the possibility to configure it is missing. \n\nThis is comparable to javac's -encoding command line flag (and probably Tomcat's JspServlet javaEncoding init-param, event if its description is not very clear)."
    ],
    [
        "GROOVY-2752",
        "GROOVY-1416",
        "final keyword does not work {code}\nfinal greeting = 'Hello'\n\ngreeting = 'Welcome'\n\nprintln greeting\n{code}\n\nWhat I expect is that Groovy will complain greeting is final variable that should not be able to be modified.\n\nActually, the code executed very well, and its result is: Welcome\n",
        "final modifier ignored in scripts The simple script:\n\nprintln \"Hello World\"\nfinal foo = \"Foo is final\"\nprintln foo\nfoo = \"Yet foo has changed\"\nprintln foo\n\noutputs:\nHello World\nFoo is final\nYet foo has changed\n\ngroovy should error when the final variable foo is re-assigned"
    ],
    [
        "GROOVY-2752",
        "GROOVY-1628",
        "final keyword does not work {code}\nfinal greeting = 'Hello'\n\ngreeting = 'Welcome'\n\nprintln greeting\n{code}\n\nWhat I expect is that Groovy will complain greeting is final variable that should not be able to be modified.\n\nActually, the code executed very well, and its result is: Welcome\n",
        "Inconsistent checking of final The following code appears to show that final is being applied inconsistently.  A final list can be amended but an object that manipulates a lsit that is final cannot.  In the former case the final is being applied to the reference and in the later, it is being applied to the object.\n\n{code}\n class Blah {\n  def list = []\n   public plus ( item ) {\n     list += [ item ]\n     return this\n   }\n}\n\nclass Foobar {\n   final static blah = new Blah ( )\n}\n\nfinal x = []\nx += [1]\nprintln ( x )\n\nFoobar.blah += 1\nprintln ( Foobar.blah.list ) \n{code}\n\n|> groovy finalProblem.groovy\n[1]\nCaught: java.lang.IllegalAccessException: Field is final\n        at finalProblem.run(finalProblem.groovy:17)\n        at finalProblem.main(finalProblem.groovy)\n"
    ],
    [
        "GROOVY-3052",
        "GROOVY-3050",
        "RangeExpression wrong line, column data {noformat}\ndef rangeTest() {\n    (1..10).a\n}\n\n{noformat}\nParsed RangeExpression (part of PropertyExpression): line = 2, column = 5, endLine = 2, endColumn = 12\n---from line = 2, column = 6, endLine = 2, endColumn = 9\n---to line = 2, column = 9, endLine = 2, endColumn = 13\n\nCoordinates for from and to are wrong and to even overlaps the RangeExpression.",
        "RangeExpression providing wrong ClassNode When simple range is parsed (I attached the whole snippet to be accurate, but problem is not related to list):\n{noformat}\n(5..8).a\n[1,2].a\n{noformat}\n\nThe name of the ClassNode is \"groovy.lang.Range\", but its clazz is java.lang.Object and isInterface() method returns false (which I think is incorrect)."
    ],
    [
        "GROOVY-3076",
        "GROOVY-3049",
        "ConstantExpression line, column data overlap defining scope When this sample grails config is parsed\n{noformat}\ndataSource {\n\tpooled = true\n\tdriverClassName = \"org.hsqldb.jdbcDriver\"\n\tusername = \"sa\"\n\tpassword = \"\"\n}.\nhibernate {\n    cache.use_second_level_cache=true\n    cache.use_query_cache=true\n    cache.provider_class='com.opensymphony.oscache.hibernate.OSCacheProvider'\n}\n// environment specific settings\nenvironments {\n\tdevelopment {\n\t\tdataSource {\n\t\t\tdbCreate = \"create-drop\" // one of 'create', 'create-drop','update'\n\t\t\turl = \"jdbc:hsqldb:mem:devDB\"\n\t\t}\n\t}\n\ttest {\n\t\tdataSource {\n\t\t\tdbCreate = \"update\"\n\t\t\turl = \"jdbc:hsqldb:mem:testDb\"\n\t\t}\n\t}\n\tproduction {\n\t\tdataSource {\n\t\t\tdbCreate = \"update\"\n\t\t\turl = \"jdbc:hsqldb:file:prodDb;shutdown=true\"\n\t\t}\n\t}\n}\n{noformat}\n\nConstantExpression for string at line 5 provides following: lineNumber=5, columnNumber=13, lastLineNumber=7, lastColumnNumber=1. The columnNumber seems to be right (there is a tab at the beginning of the line), however lastLine and lastColumn overlaps the closure definition.",
        "PropertyExpression contains wrong line,column data For certain kind of expressions it looks like PropertyExpression provides wrong (last)Line and (last)Column data. For the error case it is usually line == lastLine and column == lastColumn.\n\nFor the following snippet:\n{noformat}\nprintln new URL(\"http://google.com\").getT\n\nname = \"xxx\"\n\"User ${name}\"\n{noformat}\n\nnew URL(\"http://google.com\").getT is parsed as PropertyExpression:\nPropertyEpression: line = 1, column = 37, lastLine = 1, lastColumn = 37\nwhile\n    objectExpression: line = 1, column = 9, lastLine = 1, lastColumn = 37\n    property: line = 1. column = 38, lastLine = 3, lastColumn = 1\n"
    ],
    [
        "GROOVY-3178",
        "GROOVY-2443",
        "Dont support method override in enum When I override a method in enum, I get a error:\n\nMultipleCompilationErrorsException\n\nI atached a example.",
        "Enum does not support instance (value) specific methods Java enum allows instance (value) specific methods. Groovy does not support this currently. The following code fails in Groovy (compilation error):\n\nclass GroovyEnumRangeTest extends GroovyTestCase {\n  void testEnumMethod()\n  {\n    assertEquals \"Work\", Day.MONDAY.activity()\n    assertEquals \"Relax\", Day.SUNDAY.activity()\n  }\n}\n\nenum Day {\n    SUNDAY {\n      String activity() { 'Relax' }\n    }, MONDAY, TUESDAY, WEDNESDAY,\n    THURSDAY, FRIDAY, SATURDAY\n    \n    String activity() { 'Work' }\n}\n\nIf I need it right now, I am able to use EMC to achieve this:\n\nclass GroovyEnumRangeTest extends GroovyTestCase\n{\n  void testEnumMethod()\n  {\n    def emc = new ExpandoMetaClass(Day)\n    emc.activity = {-> 'Relax' }\n    emc.initialize()\n\n    Day.SUNDAY.metaClass = emc\n    assertEquals \"Work\", Day.MONDAY.activity()    \n    assertEquals \"Relax\", Day.SUNDAY.activity()\n    assertEquals \"Work\", Day.TUESDAY.activity()\n  }\n}\n\nenum Day {\n    SUNDAY, MONDAY, TUESDAY, WEDNESDAY,\n    THURSDAY, FRIDAY, SATURDAY\n    \n    String activity() { 'Work' }\n}\n\nso it is not major (IMHO)."
    ],
    [
        "GROOVY-3278",
        "GROOVY-2827",
        "Using referenced String constant as value of Annotation causes compile error When using a String constant as the value for an annotation groovyc errors out with the following message:\n\n&#65279;Attribute 'value' should have type java.lang.String but found type java.lang.Object in @SpringBean\n\nI've attached sample code to reproduce.  The annotation and PersonDao are regular Java classes, just as was my case when finding the bug.   The PersonAction is a Groovy class.",
        "org.codehaus.groovy.ast.expr.PropertyExpression when using external constants in annotations On annotation attributes, when assigning a constant with a \".\" in its name (as is the case when the constant is defined in a different class than the one being compiled), groovy generates org.codehaus.groovy.ast.expr.PropertyExpression.\n\nSee simple test case below.\n\n--- Tag.java\n{code}\npackage pkg;\n\nimport java.lang.annotation.Target;\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\n\n\n@Retention(RetentionPolicy.RUNTIME)\n@Target({ElementType.METHOD,ElementType.FIELD})\npublic @interface Tag {\n        String value() default \"\";\n}\n{code}\n--- TagType.java\n{code}\npackage pkg;\n\nimport org.apache.log4j.Logger;\n\npublic class TagType {\n        private final static Logger theLogger = Logger.getLogger(TagType.class);\n        public static final String TAG_1 = \"tag_1\";\n        public static final String TAG_2 = \"tag_2\";\n}\n{code}\n--- GroovyClassWithAnnotationsAndConstants.groovy\n{code}\npackage pkg;\n\nimport pkg.Tag;\nimport pkg.TagType\n\nclass GroovyClassWithAnnotationsAndConstants {\n\n        int myIntField;\n\n        @Tag( value = TagType.TAG_1) // this will not compile and generate org.codehaus.groovy.ast.expr.PropertyExpression\n        //@Tag( value = \"tag_1\") //the commented version, which uses a string literal does compile\n        public int getIntField() {\n                return myIntField;\n        }\n\n        public void setIntField(int value) {\n                myIntField = value;\n        }\n}\n{code}"
    ],
    [
        "GROOVY-3289",
        "GROOVY-3117",
        "System path emptied by installer 1.5.7 on windows My system path used to contain a whole bunch of stuff. Now, all that is left is the groovy path! Makes me very sad.\n\nPath before:\n\nPath=C:\\Program Files\\PC Connectivity Solution\\;c:\\Program Files\\Apache Software Foundation\\apache-maven-2.0.9\\bin;C:\\Program Files\\Internet Explorer;;C:\\WINDOWS\\system32\n;C:\\WINDOWS;C:\\WINDOWS\\System32\\Wbem;c:\\Program Files\\Hewlett-Packard\\IAM\\bin;c:\\Program Files\\ActivIdentity\\ActivClient\\;C:\\Program Files\\BEA Systems\\TUXEDO\\bin;C:\\Progr\nam Files\\Rational\\ClearCase\\bin;C:\\Program Files\\Rational\\common;C:\\Program Files\\maven-2.0.7\\bin;C:\\Program Files\\Java\\jdk1.5.0_11;C:\\Program Files\\Common Files\\Teleca S\nhared;C:\\Program Files\\Groovy\\Groovy-1.5.4\\bin;C:\\views\\johba_view\\ida\\java\\ant\\tool\\bin\\;C:\\Program Files\\TortoiseHg;C:\\Program Files\\MySQL\\MySQL Server 5.0\\bin;c:\\Progr\nam Files\\Microsoft SQL Server\\90\\Tools\\binn\\;C:\\Program Files\\GnuWin32\\bin;C:\\Program Files\\YourKit Java Profiler 7.0 RC build 2090\\bin;C:\\Program Files\\TortoiseSVN\\bin;C\n:\\Program Files\\Perforce;C:\\Program Files\\Perforce\\;C:\\Program Files\\Appupdater;c:\\mingw\\bin;c:\\windows\\system32\\dns\\bin;C:\\Program Files\\Rational\\ClearCase\\bin;C:\\Progra\nm Files\\Sun\\xVM VirtualBox;C:\\Program Files\\Nmap;C:\\Program Files\\QuickTime\\QTSystem\\\n\nPath after:\n\nPath=C:\\Program Files\\Groovy\\Groovy-1.5.7\\bin\n\n\nAnd if I go to Control Panel->System->Advanced->Environment Variables I see that System variables has a path=%GROOVY_HOME%\\bin\n\n",
        "PATHEXT environment variable hogged? After installing Groovy using groovy-1.5.7-installer.exe, I noticed problems to start my WebLogic server...\nAfter investigation it turned out it was no longer possible to run 'java' from command line, it did work when using 'java.exe'\nSome further investigation showed that the environment variable PATHEXT was now PATHEXT=;.groovy;.gy in stead of the usual value PATHEXT=.COM;.EXE;.BAT;.CMD;.VBS;.VBE;.JS;.JSE;.WSF;.WSH\n\nNeedless to say Groovy left the building in the mean time... :-(("
    ],
    [
        "GROOVY-3336",
        "GROOVY-3117",
        "CLONE -System path emptied by installer 1.6 RC2 on windows My system path used to contain a whole bunch of stuff. Now, all that is left is the groovy path! Makes me very sad.\n\nPath before:\n\nPath=C:\\Program Files\\PC Connectivity Solution\\;c:\\Program Files\\Apache Software Foundation\\apache-maven-2.0.9\\bin;C:\\Program Files\\Internet Explorer;;C:\\WINDOWS\\system32\n;C:\\WINDOWS;C:\\WINDOWS\\System32\\Wbem;c:\\Program Files\\Hewlett-Packard\\IAM\\bin;c:\\Program Files\\ActivIdentity\\ActivClient\\;C:\\Program Files\\BEA Systems\\TUXEDO\\bin;C:\\Progr\nam Files\\Rational\\ClearCase\\bin;C:\\Program Files\\Rational\\common;C:\\Program Files\\maven-2.0.7\\bin;C:\\Program Files\\Java\\jdk1.5.0_11;C:\\Program Files\\Common Files\\Teleca S\nhared;C:\\Program Files\\Groovy\\Groovy-1.5.4\\bin;C:\\views\\johba_view\\ida\\java\\ant\\tool\\bin\\;C:\\Program Files\\TortoiseHg;C:\\Program Files\\MySQL\\MySQL Server 5.0\\bin;c:\\Progr\nam Files\\Microsoft SQL Server\\90\\Tools\\binn\\;C:\\Program Files\\GnuWin32\\bin;C:\\Program Files\\YourKit Java Profiler 7.0 RC build 2090\\bin;C:\\Program Files\\TortoiseSVN\\bin;C\n:\\Program Files\\Perforce;C:\\Program Files\\Perforce\\;C:\\Program Files\\Appupdater;c:\\mingw\\bin;c:\\windows\\system32\\dns\\bin;C:\\Program Files\\Rational\\ClearCase\\bin;C:\\Progra\nm Files\\Sun\\xVM VirtualBox;C:\\Program Files\\Nmap;C:\\Program Files\\QuickTime\\QTSystem\\\n\nPath after:\n\nPath=C:\\Program Files\\Groovy\\Groovy-1.5.7\\bin\n\n\nAnd if I go to Control Panel->System->Advanced->Environment Variables I see that System variables has a path=%GROOVY_HOME%\\bin\n\n",
        "PATHEXT environment variable hogged? After installing Groovy using groovy-1.5.7-installer.exe, I noticed problems to start my WebLogic server...\nAfter investigation it turned out it was no longer possible to run 'java' from command line, it did work when using 'java.exe'\nSome further investigation showed that the environment variable PATHEXT was now PATHEXT=;.groovy;.gy in stead of the usual value PATHEXT=.COM;.EXE;.BAT;.CMD;.VBS;.VBE;.JS;.JSE;.WSF;.WSH\n\nNeedless to say Groovy left the building in the mean time... :-(("
    ],
    [
        "GROOVY-3336",
        "GROOVY-3289",
        "CLONE -System path emptied by installer 1.6 RC2 on windows My system path used to contain a whole bunch of stuff. Now, all that is left is the groovy path! Makes me very sad.\n\nPath before:\n\nPath=C:\\Program Files\\PC Connectivity Solution\\;c:\\Program Files\\Apache Software Foundation\\apache-maven-2.0.9\\bin;C:\\Program Files\\Internet Explorer;;C:\\WINDOWS\\system32\n;C:\\WINDOWS;C:\\WINDOWS\\System32\\Wbem;c:\\Program Files\\Hewlett-Packard\\IAM\\bin;c:\\Program Files\\ActivIdentity\\ActivClient\\;C:\\Program Files\\BEA Systems\\TUXEDO\\bin;C:\\Progr\nam Files\\Rational\\ClearCase\\bin;C:\\Program Files\\Rational\\common;C:\\Program Files\\maven-2.0.7\\bin;C:\\Program Files\\Java\\jdk1.5.0_11;C:\\Program Files\\Common Files\\Teleca S\nhared;C:\\Program Files\\Groovy\\Groovy-1.5.4\\bin;C:\\views\\johba_view\\ida\\java\\ant\\tool\\bin\\;C:\\Program Files\\TortoiseHg;C:\\Program Files\\MySQL\\MySQL Server 5.0\\bin;c:\\Progr\nam Files\\Microsoft SQL Server\\90\\Tools\\binn\\;C:\\Program Files\\GnuWin32\\bin;C:\\Program Files\\YourKit Java Profiler 7.0 RC build 2090\\bin;C:\\Program Files\\TortoiseSVN\\bin;C\n:\\Program Files\\Perforce;C:\\Program Files\\Perforce\\;C:\\Program Files\\Appupdater;c:\\mingw\\bin;c:\\windows\\system32\\dns\\bin;C:\\Program Files\\Rational\\ClearCase\\bin;C:\\Progra\nm Files\\Sun\\xVM VirtualBox;C:\\Program Files\\Nmap;C:\\Program Files\\QuickTime\\QTSystem\\\n\nPath after:\n\nPath=C:\\Program Files\\Groovy\\Groovy-1.5.7\\bin\n\n\nAnd if I go to Control Panel->System->Advanced->Environment Variables I see that System variables has a path=%GROOVY_HOME%\\bin\n\n",
        "System path emptied by installer 1.5.7 on windows My system path used to contain a whole bunch of stuff. Now, all that is left is the groovy path! Makes me very sad.\n\nPath before:\n\nPath=C:\\Program Files\\PC Connectivity Solution\\;c:\\Program Files\\Apache Software Foundation\\apache-maven-2.0.9\\bin;C:\\Program Files\\Internet Explorer;;C:\\WINDOWS\\system32\n;C:\\WINDOWS;C:\\WINDOWS\\System32\\Wbem;c:\\Program Files\\Hewlett-Packard\\IAM\\bin;c:\\Program Files\\ActivIdentity\\ActivClient\\;C:\\Program Files\\BEA Systems\\TUXEDO\\bin;C:\\Progr\nam Files\\Rational\\ClearCase\\bin;C:\\Program Files\\Rational\\common;C:\\Program Files\\maven-2.0.7\\bin;C:\\Program Files\\Java\\jdk1.5.0_11;C:\\Program Files\\Common Files\\Teleca S\nhared;C:\\Program Files\\Groovy\\Groovy-1.5.4\\bin;C:\\views\\johba_view\\ida\\java\\ant\\tool\\bin\\;C:\\Program Files\\TortoiseHg;C:\\Program Files\\MySQL\\MySQL Server 5.0\\bin;c:\\Progr\nam Files\\Microsoft SQL Server\\90\\Tools\\binn\\;C:\\Program Files\\GnuWin32\\bin;C:\\Program Files\\YourKit Java Profiler 7.0 RC build 2090\\bin;C:\\Program Files\\TortoiseSVN\\bin;C\n:\\Program Files\\Perforce;C:\\Program Files\\Perforce\\;C:\\Program Files\\Appupdater;c:\\mingw\\bin;c:\\windows\\system32\\dns\\bin;C:\\Program Files\\Rational\\ClearCase\\bin;C:\\Progra\nm Files\\Sun\\xVM VirtualBox;C:\\Program Files\\Nmap;C:\\Program Files\\QuickTime\\QTSystem\\\n\nPath after:\n\nPath=C:\\Program Files\\Groovy\\Groovy-1.5.7\\bin\n\n\nAnd if I go to Control Panel->System->Advanced->Environment Variables I see that System variables has a path=%GROOVY_HOME%\\bin\n\n"
    ],
    [
        "GROOVY-3368",
        "GROOVY-3339",
        "Collection.sort{Closure} regression Starting from Groovy 1.6 final I experienced a regression on the Collection.sort{Closure} method.\nThe minimal example to replicate it requires the following steps\n1. Run groovysh\n2. Write the following line\n for (x in [1,2,3].sort{it*2}) { println x }\n3. An exception is raised\nERROR java.lang.NoSuchFieldError: $const$1\n        at groovysh_evaluate$_run_closure1.doCall (groovysh_evaluate:2)\n        at groovysh_evaluate.run (groovysh_evaluate:2)\n        ...\n\nThe same example with Groovy 1.5.7 worked fine, printing \n1\n2\n3\n\nOn Groovy 1.6 the error can be replicated also with\nfor (x in [1,2,3].sort{0}) { println x }\n\nThe problem seems somehow related to the for cycle, because the following code doesn't throw exceptions\n[1,2,3].sort{it * 2}\n[1,2,3].sort{0}",
        "Calling a method that takes a closure containing a list or number (and maybe others) constant throws a weird exception This script:\n\n{code}\nfor(myVal in evaluate('[10,11,12]', 2, 'foo') { [10,11,12] }) { \n println myVal\n}\n\ndef evaluate(text, num, thing, closure) {\n   closure.call()\n}\n{code}\n\nProduces:\n\n{code}\nException thrown: $const$1\n\njava.lang.NoSuchFieldError: $const$1\n       at ConsoleScript1$_run_closure1.doCall(ConsoleScript1:1)\n       at ConsoleScript1$_run_closure1.doCall(ConsoleScript1)\n       at ConsoleScript1.evaluate(ConsoleScript1:6)\n       at ConsoleScript1$evaluate.callCurrent(Unknown Source)\n{code}\n\nWhilst this one that has a String inside the closure works fine:\n\n{code}\nfor(myVal in evaluate('[10,11,12]', 2, 'foo') { \"one\" }) { \n println myVal\n}\n\ndef evaluate(text, num, thing, closure) {\n   closure.call()\n}\n{code}"
    ],
    [
        "GROOVY-3408",
        "GROOVY-2443",
        "Groovy does not support abstract methods in enums {code}\nenum MyEnum {\n    a {\n        void something() {}\n    }\n    \n    abstract void something()\n}\n\nMyEnum.a.something()\n{code}\n\ncode above should work (if I extrapolate from Java) but brings in Groovy console:\n1 compilation error:\nUnknown type: OBJBLOCK at line: 2 column: 7. File: ConsoleScript10 at ",
        "Enum does not support instance (value) specific methods Java enum allows instance (value) specific methods. Groovy does not support this currently. The following code fails in Groovy (compilation error):\n\nclass GroovyEnumRangeTest extends GroovyTestCase {\n  void testEnumMethod()\n  {\n    assertEquals \"Work\", Day.MONDAY.activity()\n    assertEquals \"Relax\", Day.SUNDAY.activity()\n  }\n}\n\nenum Day {\n    SUNDAY {\n      String activity() { 'Relax' }\n    }, MONDAY, TUESDAY, WEDNESDAY,\n    THURSDAY, FRIDAY, SATURDAY\n    \n    String activity() { 'Work' }\n}\n\nIf I need it right now, I am able to use EMC to achieve this:\n\nclass GroovyEnumRangeTest extends GroovyTestCase\n{\n  void testEnumMethod()\n  {\n    def emc = new ExpandoMetaClass(Day)\n    emc.activity = {-> 'Relax' }\n    emc.initialize()\n\n    Day.SUNDAY.metaClass = emc\n    assertEquals \"Work\", Day.MONDAY.activity()    \n    assertEquals \"Relax\", Day.SUNDAY.activity()\n    assertEquals \"Work\", Day.TUESDAY.activity()\n  }\n}\n\nenum Day {\n    SUNDAY, MONDAY, TUESDAY, WEDNESDAY,\n    THURSDAY, FRIDAY, SATURDAY\n    \n    String activity() { 'Work' }\n}\n\nso it is not major (IMHO)."
    ],
    [
        "GROOVY-3408",
        "GROOVY-3178",
        "Groovy does not support abstract methods in enums {code}\nenum MyEnum {\n    a {\n        void something() {}\n    }\n    \n    abstract void something()\n}\n\nMyEnum.a.something()\n{code}\n\ncode above should work (if I extrapolate from Java) but brings in Groovy console:\n1 compilation error:\nUnknown type: OBJBLOCK at line: 2 column: 7. File: ConsoleScript10 at ",
        "Dont support method override in enum When I override a method in enum, I get a error:\n\nMultipleCompilationErrorsException\n\nI atached a example."
    ],
    [
        "GROOVY-3447",
        "GROOVY-3250",
        "Cyclic data will result in StackOverflowError Try this and I get java.lang.StackOverflowError\n\nls = ['groovy']\nls.add(ls)\nprintln(ls)\n\nWhile java will smart enough to print the following:\n\t\tList<Object> ls = new ArrayList<Object>();\n\t\tls.add(1);\n\t\tls.add(2);\n\t\tls.add(3);\n\t\tls.add(ls);\n\t\tSystem.out.println(ls);\n>>> [1, 2, 3, (this Collection)]\n\nSo some where along the line Groovy did too much on overwriting the toString method?\n",
        "StackOverflowError in List and Map formatting If a List or Map that contains itself is formatted for output (print, inspect,...) a StackOverflowError occurs.\n\n{code}\nimport org.codehaus.groovy.runtime.InvokerHelper\n\ndef x\n\n// List (simple case)\nx = []\nx << x\nassert \"[(this Collection)]\" == x.toString()\nInvokerHelper.toListString(x)\n\n// List (nested case)\nx = []\nx << [x]\nassert InvokerHelper.toListString(x)\n\n// Map (simple case)\nx = [:]\nx.put(\"self\", x)\nassert \"[self:this Map_]\" == InvokerHelper.toMapString(x) // JDK uses \"(this Map)\"\n\n// Map (nested case)\nx = [:]\nx.put(\"nested\", [\"self\":x])\nassert InvokerHelper.toMapString(x)\n\n// there are also List/Map mixed cases\n// ...\n{code}\n\nSee also GROOVY-1106."
    ],
    [
        "GROOVY-3450",
        "GROOVY-3223",
        "Ant properties don't work within the source / target attributes on javac Ant task within groovyc task With Groovy 1.5.1, I used the <groovyc> Ant task with a nested <javac> which has the 'source' and 'target' attributes specified using Ant properties: \n\n<groovyc ...\n<javac debug=\"${javac.debug}\" source=\"${javac.compatibility.source.version}\" target=\"${javac.compatibility.target.version}\"/>\n</groovyc>\n\nThe 'javac.compatibility.source.version' and 'javac.compatibility.target.version' properties are both set to '1.4'. This worked fine in 1.5.1, but upgrading to Groovy 1.6.0 I get the following error: \n\n  [groovyc] org.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed, Invalid commandline usage for javac.\n  [groovyc] javac: invalid source release: ${javac.compatibility.source.version}\n\nThe properties are set up correctly (<echoproperties/> proves it), but for some reason they're not getting resolved in this particular context. If I convert the Ant script to use AntBuilder within a <groovy> script element, it resolves the problem, e.g.\n\n<groovy>\nant.groovyc( ... ) {\n  ...\n  javac( debug:properties[\"javac.debug\"], source:properties[\"javac.compatibility.source.version\"], target:properties[\"javac.compatibility.target.version\"] )\n}\n</groovy>\n",
        "Nested javac Ant task does not do property substitution on its attributes If using groovyc with an embedded javac it is no longer possible to use Ant property substitution on the javac attributes.\n\nFor example having a call to groovyc like this:\n\n      <groovyc destdir=\"build\" srcdir=\"src\">\n         <javac source=\"${javac.source}\" target=\"${javac.target}\" debug=\"${javac.debug}\" encoding=\"UTF-8\"/>\n      </groovyc>\n\nwill lead to this error:\n\n  [groovyc] javac: invalid source release: ${javac.source}\n\nThis works fine with Groovy 1.5.7\n\nI have attached a simple test case with a build.xml file which loads an external build.properties and then attempts to compile a single Java file.\nTo test simply edit the build.properties file to point groovy.home at a relevant Groovy installation.\nPointing it a my 1.6 b2 fails but 1.5.7 works.\n\nI wasn't sure how to turn this into a Junit test easily though.\n\n"
    ],
    [
        "GROOVY-3501",
        "GROOVY-3468",
        "NPE at groovy.lang.GroovyClassLoader.getPermissions(GroovyClassLoader.java:342) ScriptEngine scriptEngine = new GroovyScriptEngineImpl();\nObject result = scriptEngine.eval(\"...\");\n\nWhen executing this, I get:\n\nCaused by: java.lang.NullPointerException\n        at groovy.lang.GroovyClassLoader.getPermissions(GroovyClassLoader.java:342)\n        at java.security.SecureClassLoader.getProtectionDomain(SecureClassLoader.java:192)\n        at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:124)\n        at groovy.lang.GroovyClassLoader.access$200(GroovyClassLoader.java:54)\n        at groovy.lang.GroovyClassLoader$ClassCollector.createClass(GroovyClassLoader.java:468)\n        at groovy.lang.GroovyClassLoader$ClassCollector.onClassNode(GroovyClassLoader.java:485)\n        at groovy.lang.GroovyClassLoader$ClassCollector.call(GroovyClassLoader.java:489)\n        at org.codehaus.groovy.control.CompilationUnit$10.call(CompilationUnit.java:727)\n        at org.codehaus.groovy.control.CompilationUnit.applyToPrimaryClassNodes(CompilationUnit.java:924)\n        at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:462)\n        at groovy.lang.GroovyClassLoader.parseClass(GroovyClassLoader.java:278)\n        at groovy.lang.GroovyClassLoader.parseClass(GroovyClassLoader.java:249)\n        at groovy.lang.GroovyClassLoader.parseClass(GroovyClassLoader.java:244)\n        at org.codehaus.groovy.jsr223.GroovyScriptEngineImpl.getScriptClass(GroovyScriptEngineImpl.java:320)\n        at org.codehaus.groovy.jsr223.GroovyScriptEngineImpl.eval(GroovyScriptEngineImpl.java:113)\n\nThis is caused by \"myDomain.getPermissions()\" returning a null value.\nAt runtime the myDomain is org.apache.felix.framework.BundleProtectionDomain.\n\nI think it is a bug in the groovy as the mettod is allowed to return the null \n(http://java.sun.com/javase/6/docs/api/java/security/ProtectionDomain.html#getPermissions()).\n",
        "NullPointerException in GroovyClassLoader.getPermissions() when called from BSFManager.exec() GroovyClassLoader.java   \t rev 15766\nin function getPermissions()\nline no. 341: null is assigned to myPerms in the given environment.\nconsequently, a NullPointerException occurs in the next line.\nPlease see attached stack trace."
    ],
    [
        "GROOVY-3542",
        "GROOVY-3468",
        "GroovyShell.evaluate(File) NPE NPE when evaluating a script with Groovy 1.6.2 and 1.6.3 using groovy.lang.GroovyShell.evaluate(File). The problem is not happening with v.1.0 and v.1.5.6.\n\n{quote}\njava.lang.NullPointerException\n\tat groovy.lang.GroovyClassLoader.getPermissions(GroovyClassLoader.java:342)\n\tat java.security.SecureClassLoader.getProtectionDomain(SecureClassLoader.java:192)\n\tat java.security.SecureClassLoader.defineClass(SecureClassLoader.java:124)\n\tat groovy.lang.GroovyClassLoader.access$200(GroovyClassLoader.java:54)\n\tat groovy.lang.GroovyClassLoader$ClassCollector.createClass(GroovyClassLoader.java:468)\n\tat groovy.lang.GroovyClassLoader$ClassCollector.onClassNode(GroovyClassLoader.java:485)\n\tat groovy.lang.GroovyClassLoader$ClassCollector.call(GroovyClassLoader.java:489)\n\tat org.codehaus.groovy.control.CompilationUnit$10.call(CompilationUnit.java:727)\n\tat org.codehaus.groovy.control.CompilationUnit.applyToPrimaryClassNodes(CompilationUnit.java:924)\n\tat org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:462)\n\tat groovy.lang.GroovyClassLoader.parseClass(GroovyClassLoader.java:278)\n\tat groovy.lang.GroovyShell.parseClass(GroovyShell.java:590)\n\tat groovy.lang.GroovyShell.parse(GroovyShell.java:602)\n\tat groovy.lang.GroovyShell.evaluate(GroovyShell.java:490)\n\tat groovy.lang.GroovyShell.evaluate(GroovyShell.java:526)\n\tat Refresh_Groovy_List.actionPerformed(Refresh_Groovy_List.java:127)\n\tat java.awt.MenuItem.processActionEvent(MenuItem.java:627)\n\tat java.awt.MenuItem.processEvent(MenuItem.java:586)\n{quote}\n\nThe problem is a bit tricky to reproduce, but can be reproduced consistently. You need to run the test code from within ImageJ (http://rsb.info.nih.gov/ij/). There is no problem when I execute the same code and script from IDEA.\n\nSteps to reproduce:\n1) Download and install ImageJ\n2) In ImageJ 'plugins' directory create directory named 'Groovy\"\n3) Copy attached files to the new directory\n4) Start ImageJ and select from menu Plugins>Groovy>Refresh Groovy List (if you do not see the last menu item, steps 2) and 3) were not done right). This will create new menu item \"Add Noise\"\n5) Select from menu Plugins>Groovy>Add Noise\n\nGroovyShell.evaluate is executed by the code in Refresh_Groovy_List.java line 127.\n\n",
        "NullPointerException in GroovyClassLoader.getPermissions() when called from BSFManager.exec() GroovyClassLoader.java   \t rev 15766\nin function getPermissions()\nline no. 341: null is assigned to myPerms in the given environment.\nconsequently, a NullPointerException occurs in the next line.\nPlease see attached stack trace."
    ],
    [
        "GROOVY-3542",
        "GROOVY-3501",
        "GroovyShell.evaluate(File) NPE NPE when evaluating a script with Groovy 1.6.2 and 1.6.3 using groovy.lang.GroovyShell.evaluate(File). The problem is not happening with v.1.0 and v.1.5.6.\n\n{quote}\njava.lang.NullPointerException\n\tat groovy.lang.GroovyClassLoader.getPermissions(GroovyClassLoader.java:342)\n\tat java.security.SecureClassLoader.getProtectionDomain(SecureClassLoader.java:192)\n\tat java.security.SecureClassLoader.defineClass(SecureClassLoader.java:124)\n\tat groovy.lang.GroovyClassLoader.access$200(GroovyClassLoader.java:54)\n\tat groovy.lang.GroovyClassLoader$ClassCollector.createClass(GroovyClassLoader.java:468)\n\tat groovy.lang.GroovyClassLoader$ClassCollector.onClassNode(GroovyClassLoader.java:485)\n\tat groovy.lang.GroovyClassLoader$ClassCollector.call(GroovyClassLoader.java:489)\n\tat org.codehaus.groovy.control.CompilationUnit$10.call(CompilationUnit.java:727)\n\tat org.codehaus.groovy.control.CompilationUnit.applyToPrimaryClassNodes(CompilationUnit.java:924)\n\tat org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:462)\n\tat groovy.lang.GroovyClassLoader.parseClass(GroovyClassLoader.java:278)\n\tat groovy.lang.GroovyShell.parseClass(GroovyShell.java:590)\n\tat groovy.lang.GroovyShell.parse(GroovyShell.java:602)\n\tat groovy.lang.GroovyShell.evaluate(GroovyShell.java:490)\n\tat groovy.lang.GroovyShell.evaluate(GroovyShell.java:526)\n\tat Refresh_Groovy_List.actionPerformed(Refresh_Groovy_List.java:127)\n\tat java.awt.MenuItem.processActionEvent(MenuItem.java:627)\n\tat java.awt.MenuItem.processEvent(MenuItem.java:586)\n{quote}\n\nThe problem is a bit tricky to reproduce, but can be reproduced consistently. You need to run the test code from within ImageJ (http://rsb.info.nih.gov/ij/). There is no problem when I execute the same code and script from IDEA.\n\nSteps to reproduce:\n1) Download and install ImageJ\n2) In ImageJ 'plugins' directory create directory named 'Groovy\"\n3) Copy attached files to the new directory\n4) Start ImageJ and select from menu Plugins>Groovy>Refresh Groovy List (if you do not see the last menu item, steps 2) and 3) were not done right). This will create new menu item \"Add Noise\"\n5) Select from menu Plugins>Groovy>Add Noise\n\nGroovyShell.evaluate is executed by the code in Refresh_Groovy_List.java line 127.\n\n",
        "NPE at groovy.lang.GroovyClassLoader.getPermissions(GroovyClassLoader.java:342) ScriptEngine scriptEngine = new GroovyScriptEngineImpl();\nObject result = scriptEngine.eval(\"...\");\n\nWhen executing this, I get:\n\nCaused by: java.lang.NullPointerException\n        at groovy.lang.GroovyClassLoader.getPermissions(GroovyClassLoader.java:342)\n        at java.security.SecureClassLoader.getProtectionDomain(SecureClassLoader.java:192)\n        at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:124)\n        at groovy.lang.GroovyClassLoader.access$200(GroovyClassLoader.java:54)\n        at groovy.lang.GroovyClassLoader$ClassCollector.createClass(GroovyClassLoader.java:468)\n        at groovy.lang.GroovyClassLoader$ClassCollector.onClassNode(GroovyClassLoader.java:485)\n        at groovy.lang.GroovyClassLoader$ClassCollector.call(GroovyClassLoader.java:489)\n        at org.codehaus.groovy.control.CompilationUnit$10.call(CompilationUnit.java:727)\n        at org.codehaus.groovy.control.CompilationUnit.applyToPrimaryClassNodes(CompilationUnit.java:924)\n        at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:462)\n        at groovy.lang.GroovyClassLoader.parseClass(GroovyClassLoader.java:278)\n        at groovy.lang.GroovyClassLoader.parseClass(GroovyClassLoader.java:249)\n        at groovy.lang.GroovyClassLoader.parseClass(GroovyClassLoader.java:244)\n        at org.codehaus.groovy.jsr223.GroovyScriptEngineImpl.getScriptClass(GroovyScriptEngineImpl.java:320)\n        at org.codehaus.groovy.jsr223.GroovyScriptEngineImpl.eval(GroovyScriptEngineImpl.java:113)\n\nThis is caused by \"myDomain.getPermissions()\" returning a null value.\nAt runtime the myDomain is org.apache.felix.framework.BundleProtectionDomain.\n\nI think it is a bug in the groovy as the mettod is allowed to return the null \n(http://java.sun.com/javase/6/docs/api/java/security/ProtectionDomain.html#getPermissions()).\n"
    ],
    [
        "GROOVY-3632",
        "GROOVY-2049",
        "Cannot overload/override setter with mutliple methods It does not seem possible to overload a setter with multiple methods. \nGroovy seems to randomly decide to fail with cast exceptions\nrather than actually calling the correct setter. Here is the code:\npublic class Person {\n   // id is added by grails\n   String name\n   String email\n   Date birthdate\n   int age = 0\n   PersonSex sex = PersonSex.unknown\n   boolean active = true\n\n    void setBirthdate(String date) {\n       // try to convert from string\n       def df = new SimpleDateFormat(\"yyyy/MM/dd\")\n       birthdate = df.parse(date);\n   }\n\n   void setBirthdate(Number date) {\n       birthdate = new Date(date)\n   }\n}\n\nI have a few tests to verify that I can create a user with a Date, String, or Long\n\nWith the code above it is not possible to set the bithdate to a Date\nanymore as I always get a cast exception.\nIf I change \"Number\" to \"Long\" or \"long\" then the String test passes\nbut the number test fails. If I leave it as shown above then the\nString test fails with this exception:\norg.codehaus.groovy.runtime.typehandling.GroovyCastException: Cannot\ncast object '1975/10/29' with class 'java.lang.String' to class\n'java.lang.Number'\n       at org.codehaus.groovy.runtime.typehandling.DefaultTypeTransformation.castToNumber(DefaultTypeTransformation.java:132)\n       at org.codehaus.groovy.runtime.typehandling.DefaultTypeTransformation.castToType(DefaultTypeTransformation.java:261)\n       at groovy.lang.MetaClassImpl.setProperty(MetaClassImpl.java:2392)\n       at groovy.lang.MetaClassImpl.setProperty(MetaClassImpl.java:3307)\n       at groovy.lang.MetaClassImpl.setProperties(MetaClassImpl.java:1506)\n       at groovy.lang.MetaClassImpl.invokeConstructor(MetaClassImpl.java:1483)\n       at groovy.lang.MetaClassImpl.invokeConstructor(MetaClassImpl.java:1404)\n       at org.codehaus.groovy.runtime.InvokerHelper.invokeConstructorOf(InvokerHelper.java:775)\n       at org.codehaus.groovy.runtime.ScriptBytecodeAdapter.invokeNewN(ScriptBytecodeAdapter.java:220)\n       at PersonTest.testPersonStringDate(PersonTests.groovy:32)\n\nIt seems like groovy is only able to work with a single setter method but it should be able to handle overloaded methods and properly call the one which matches the type.",
        "Provide some auto-overloading between int and String values The String setter in the attached example is never called. Instead, the int setter is called when I assign a String with size() == 1. If the size is bigger, I get a GroovyClassCastException"
    ],
    [
        "GROOVY-3632",
        "GROOVY-2500",
        "Cannot overload/override setter with mutliple methods It does not seem possible to overload a setter with multiple methods. \nGroovy seems to randomly decide to fail with cast exceptions\nrather than actually calling the correct setter. Here is the code:\npublic class Person {\n   // id is added by grails\n   String name\n   String email\n   Date birthdate\n   int age = 0\n   PersonSex sex = PersonSex.unknown\n   boolean active = true\n\n    void setBirthdate(String date) {\n       // try to convert from string\n       def df = new SimpleDateFormat(\"yyyy/MM/dd\")\n       birthdate = df.parse(date);\n   }\n\n   void setBirthdate(Number date) {\n       birthdate = new Date(date)\n   }\n}\n\nI have a few tests to verify that I can create a user with a Date, String, or Long\n\nWith the code above it is not possible to set the bithdate to a Date\nanymore as I always get a cast exception.\nIf I change \"Number\" to \"Long\" or \"long\" then the String test passes\nbut the number test fails. If I leave it as shown above then the\nString test fails with this exception:\norg.codehaus.groovy.runtime.typehandling.GroovyCastException: Cannot\ncast object '1975/10/29' with class 'java.lang.String' to class\n'java.lang.Number'\n       at org.codehaus.groovy.runtime.typehandling.DefaultTypeTransformation.castToNumber(DefaultTypeTransformation.java:132)\n       at org.codehaus.groovy.runtime.typehandling.DefaultTypeTransformation.castToType(DefaultTypeTransformation.java:261)\n       at groovy.lang.MetaClassImpl.setProperty(MetaClassImpl.java:2392)\n       at groovy.lang.MetaClassImpl.setProperty(MetaClassImpl.java:3307)\n       at groovy.lang.MetaClassImpl.setProperties(MetaClassImpl.java:1506)\n       at groovy.lang.MetaClassImpl.invokeConstructor(MetaClassImpl.java:1483)\n       at groovy.lang.MetaClassImpl.invokeConstructor(MetaClassImpl.java:1404)\n       at org.codehaus.groovy.runtime.InvokerHelper.invokeConstructorOf(InvokerHelper.java:775)\n       at org.codehaus.groovy.runtime.ScriptBytecodeAdapter.invokeNewN(ScriptBytecodeAdapter.java:220)\n       at PersonTest.testPersonStringDate(PersonTests.groovy:32)\n\nIt seems like groovy is only able to work with a single setter method but it should be able to handle overloaded methods and properly call the one which matches the type.",
        "Assignment calls the wrong setter, depending on order of declaration The following build.xml fails:\n\n{code}\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project name=\"test\" default=\"run\">\n\n\t<path id=\"groovy.classpath\">\n\t\t<fileset dir=\".\" includes=\"groovy-*.jar\"/>\n\t</path>\n\n\t<taskdef name=\"groovy\" classname=\"org.codehaus.groovy.ant.Groovy\" classpathref=\"groovy.classpath\"/>\n\n\t<target name=\"compile\">\n\t\t<echo file=\"Test.java\">\n\t\t\tpublic class Test\n\t\t\t{\n\t\t\t\tpublic void setField( String value )\n\t\t\t\t{ \n\t\t\t\t\tSystem.out.println( \"String\" );\n\t\t\t\t}\n\t\t\t\n\t\t\t\tpublic void setField( Integer value )\n\t\t\t\t{ \n\t\t\t\t\tSystem.out.println( \"Integer\" );\n\t\t\t\t}\n\t\t\t}\n\t\t</echo>\n\t\t<javac srcdir=\".\" includes=\"Test.java\"/>\n\t</target>\n\n\t<target name=\"run\" depends=\"compile\">\n\t\t<groovy>\n\t\t\ttry\n\t\t\t{\n\t\t\t\tnew Test().setField( \"sss\" ) // This works\n\t\t\t\tprintln \"success 1\"\n\t\t\t\tnew Test().field = \"sss\" // This gives exception\n\t\t\t\tprintln \"success 2\"\n\t\t\t}\n\t\t\tcatch( Exception e )\n\t\t\t{\n\t\t\t\te.printStackTrace( System.out )\n\t\t\t}\n\t\t</groovy>\n\t</target>\n\n</project>\n{code}\n\n(you need to put the groovy.jar in the same folder)\n\nThe setField() succeeds, but the assignment fails.\n\nIf I change the order of the two setField() methods, both succeed.\n"
    ],
    [
        "GROOVY-3676",
        "GROOVY-3616",
        "Explicitly dereferenced hash values created by variables return null \"${key1}\" as a key in a hash (left side of a ' X : X ' item) can't be dereferenced later.  As in \n\n    key1 = \"VARIABLE_1\"\n    a1 = [ \"${key1}\" : \"YES 3\"]  // This is not accessible, later.\n\nThe key shows a key=value pair when you move through the map using eachWithIndex\n\n   a1.eachWithIndex { it -> print \"$it\\n\" }\n\nproduces \"VARIABLE_1=YES 3\"\n\nBut when you explicitly dereference it, you get a null\n\n   print a1[\"${key1}\"]\n\nproduces \"null\"\n\nThis is not a minor problem if one uses groovy as a text processing/scripting language.\n\n",
        "Inconsistent behavior with GStrings and Maps I know that there are already several closed bugs around GStrings and Map keys but I think this one is a bit different.  The behavior is inconsistent between using the GString on map creation and adding to the map after it was created.\n\nIn the example below the commented out asserts fail.  The output is:\n{noformat}\ntest\nclass java.lang.String\nnull\nclass org.codehaus.groovy.runtime.GStringImpl\n{noformat}\n\n{code}\ndef key = 1\ndef myMap = [:]\nmyMap[\"${key}\"] = 'test'\nassert(myMap[\"${key}\"] == 'test')\nprintln myMap[\"${key}\"]\nmyMap.keySet().each {\n  assert it.class == java.lang.String\n  println it.class\n}\n\ndef key1 = 1\ndef myMap1 = [\"${key1}\": 'test']\n//assert(myMap1[\"${key1}\"] == 'test')\nassert(myMap1[\"${key1}\"] == null)\nprintln myMap1[\"${key1}\"]\nmyMap1.keySet().each {\n  //assert it.class == java.lang.String\n  assert it.class == org.codehaus.groovy.runtime.GStringImpl\n  println it.class\n}\n{code}\n"
    ],
    [
        "GROOVY-3877",
        "GROOVY-3318",
        "problem trying to extend an abstract groovy class with a java class Take a simple abstract groovy class:\n\n{noformat}\n--- Foo.groovy\nabstract class Foo {}\n---\n{noformat}\n\ncompile it with groovyc.  Take a simple java class\n\n{noformat}\n--- FooSub.java\nclass FooSub extends Foo {}\n---\n{noformat}\n\ntry and compile it with javac.  It will fail because the GroovyObject methods added to Foo are marked synthetic so it doesn't think GroovyObject has been implemented in the hierarchy.  Neither javac or the Eclipse Compiler for Java (ECJ) allow synthetic methods to satisfy an interface implementation (and Foo has had GroovyObject added to it by groovyc).  It is the word 'abstract' on Foo that causes both javac and ECJ to check this situation and report the problem.\n\nI've discussed things with Jochen and we are thinking about removing synthetic for these methods if they are being added to a groovy type that is abstract.\n\nJoint compilation works because the stubs don't show that the methods will be abstract when the java code is compiled.",
        "Javac doesn't see synthetic Groovy methods in Groovy-compiled superclass Create a Foo.groovy class containing:\n\nabstract class Foo {}\n\nand Bar.java with:\n\nclass Bar extends Foo {}.\n\nAfter  that  you compile the first file with groovyc (1.6) and the other one\nwith javac (1.5 or 1.6):\n\nC:\\sdks\\groovy-1.6-RC-1>set GROOVY_HOME=c:\\sdks\\groovy-1.6-RC-1\\\n\nC:\\sdks\\groovy-1.6-RC-1\\bin>set path=c:\\sdks\\groovy-1.6-RC-1\\bin\\;%path%\n\nC:\\temp>groovyc Foo.groovy\n\nC:\\temp>c:\\jdk1.5.0_08\\bin\\javac.exe -classpath c:\\sdks\\groovy-1.6-RC-1\\embeddable\\groovy-all-1.6-RC-1.jar;. Bar.java\nBar.java:1: Bar is not abstract and does not override abstract method setMetaClass(groovy.lang.MetaClass) in groovy.lang.GroovyObject\nclass Bar extends Foo {}\n^\n1 error\n\nFoo.jad contains the required setMetaClass method, but it's synthetic. Javac doesn't consider synthetic methods to be the ones already implementing what it wants. The abstractness of Foo is important, otherwise everything works. The same may apply not only to GroovyObject MOP methods, but also to generated property accessors.\n"
    ],
    [
        "GROOVY-3981",
        "GROOVY-3973",
        "Spring 2.5.X refresh interval incompatibility Version 1.7.0 corrupts Spring 2.5.X refresh interval behaviour. I include set of test proving that. If you run them with Groovy 1.6.5 (see comments containing Groovy 1.6.5, that are necessary to process before running with 1.6.5 - 1.7.0 introduces some changes breaking backward compatibility) all tests pass. With 1.7.0 two fails - one is described in another issue GROOVY-3980.\n\nThis issue should concern with test: com.fg.scripting.groovy.SpringGroovyReloadSupportTest#testReloadLoadGroovyClass\n\nNote that before running tests, path in com.fg.scripting.groovy.AbstractGroovyTest#setUp must be modified to match your system.\n\nSpring configuration is so simple, that (I hope) cannot be wrong:\n\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:lang=\"http://www.springframework.org/schema/lang\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.0.xsd http://www.springframework.org/schema/lang http://www.springframework.org/schema/lang/spring-lang.xsd\">\n\n    <bean id=\"propertyPlaceholderConfigurer\" class=\"org.springframework.beans.factory.config.PropertyPlaceholderConfigurer\"/>       \n\n    <lang:groovy id=\"mainGroovyClass\"\n                 refresh-check-delay=\"0\"\n                 script-source=\"file:${project.build.directory}/target/test-classes/com/fg/mock/MainGroovyClass.groovy\"/>\n\n    <lang:groovy id=\"referencingGroovyClass\"\n                 refresh-check-delay=\"0\"\n                 script-source=\"file:${project.build.directory}/target/test-classes/com/fg/mock/ReferencingGroovyClass.groovy\">\n        <lang:property name=\"mainGroovyClass\" ref=\"mainGroovyClass\"/>\n    </lang:groovy>\n\n</beans>\n\nBean refreshes to conform to actual source code occurs no more with Groovy 1.7.0.\nRegretfully I wasn't able to find out where problem lies, so no patch is included.",
        "GroovyClassLoader incompatible with older version(s) There is incompatibility in GroovyClassLoader between versions 1.6.7 and 1.7.0 which is making impossible to refresh groovy script in spring framework. GroovyScriptFactory from spring framework is parsing class using parseClass(String text, String fileName) method from GroovyClassLoader. This method has been changed in 1.7.0 causing shouldCacheSource flag in parseClass(GroovyCodeSource codeSource, boolean shouldCacheSource) method to be set to true instead of false as in version 1.6.7. Since file name is not changed between calls, after first call to parseClass(String, String) resulting class will be cached and will never be compiled again."
    ],
    [
        "GROOVY-4016",
        "GROOVY-4015",
        "Single super constructor argument is casted to array if super constructor has vararg parameter {code:Java}\nclass Foo {\n  def Foo(String... s) { }\n}\nclass ImplOneParameter extends Foo {\n  def ImplOneParameter(String s) {\n    super(s)\n  }\n}\nclass ImplArray extends Foo {\n  def ImplArray(String[] s) {\n    super(s)\n  }\n}\n\n\nnew ImplArray(\"String\")\nnew ImplOneParameter(\"String\") //fails with CCE\n{code}\nThe same dispatch as for usual method calls should apply.",
        "GStrings are not coerced to Strings in super constructor call class Foo {\n  def Foo(String s) { }\n}\nclass ImplString extends Foo {\n  def ImplString(String s) {\n    super(s)\n  }\n}\nclass ImplObject extends Foo {\n  def ImplObject(s) {\n    super(s)\n  }\n}\n\n\ndef a = 2\n\nnew ImplString(\"GString $a\")\nnew ImplObject(\"String\")\nnew ImplObject(\"GString $a\") //fails with CCE"
    ],
    [
        "GROOVY-4064",
        "GROOVY-3979",
        "Inner Enums do not work with standard Java Enum.valueOf() The following test fails:\n\n{code}\nsmarter.ecommerce.smeco.support.smecoscript.services\n\nimport org.junit.Test;\n\nclass InnerEnumTest {\n\n\tenum TestEnum {\n\t\tA, B\n\t}\n\t\n\t@Test\n\tvoid useEnumValueOf() {\n\t\tassert TestEnum.A == Enum.valueOf(TestEnum, \"A\")\n\t}\n\t\n}\n\njava.lang.IllegalArgumentException: smarter.ecommerce.smeco.support.smecoscript.services.InnerEnumTest$TestEnum is not an enum type\n\tat java.lang.Class.enumConstantDirectory(Class.java:2965)\n\tat java.lang.Enum.valueOf(Enum.java:191)\n\tat java_lang_Enum$valueOf.call(Unknown Source)\n\tat org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:40)\n\tat org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:117)\n\tat org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:129)\n\tat smarter.ecommerce.smeco.support.smecoscript.services.InnerEnumTest.useEnumValueOf(InnerEnumTest.groovy:13)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n\tat java.lang.reflect.Method.invoke(Method.java:597)\n\tat org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:44)\n\tat org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:15)\n\tat org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:41)\n\tat org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:20)\n\tat org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:76)\n\tat org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:50)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:193)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:52)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:191)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:42)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:184)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:236)\n\tat org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:46)\n\tat org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:467)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:683)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:390)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:197)\n{code}\n\nThe problem lies in Class.getEnumConstantsShared(). Java expects each enumeration to implement a method values() -> In this case the method seems to be inaccessible (IllegalAccessException is caught and null returned which later leads to the IllegalArgumentException)\n",
        "Enum inside a class Iteration of enum defined inside a class fails with the following exception:\n\nCaught: groovy.lang.MissingMethodException: No signature of method:\nstatic EnumTest2$Direction.values() is applicable for argument types: ()\nvalues: []\n\nThe following example demonstrates the problem   \n\nclass EnumTest2 {  \n\n  enum Direction { North, East, South, West } \n\n  static void main(args) { \n    for (d in Direction) { \n      println d\n    }\n\n  }\n\n}"
    ],
    [
        "GROOVY-4083",
        "GROOVY-3142",
        "private members should be accessible in closures used from sub classes Private members should be accessible in closures even if the code is called from sub classes (see test below). The current behavior prevents subclassing e.g of groovy.ui.Console.\n\nclass MySuperClass {\n    private test = \"test\"\n    \n    def run() {\n        {-> test }()\n    }\n}\n\nclass MySubClass extends MySuperClass {\n}\n\nassert new MySuperClass().run() == \"test\"\n\nassert new MySubClass().run() == \"test\"\n",
        "Unable to access inherited private fields from a closure within an inherited method {noformat}\nclass B {\n    String data\n    B(arg) {\n        arg.each() { this.@data = it }\n    }\n}\nclass C extends B {\n    C(arg) {\n        super(arg)\n    }\n}\nnew C([\"test\"])\n{noformat}\n\nThe previous unexpectedly produce: Exception thrown: groovy.lang.MissingFieldException: No such field: data for class: C\n\n{noformat}\nclass B {\n    private String data\n    public String getData() { this.@data }\n    private setData(String value) { this.@data = value }\n    B(arg) {\n        arg.each() { data = it }\n    }\n}\nclass C extends B {\n    C(arg) {\n        super(arg)\n    }\n}\n\nnew C([\"test\"])\n{noformat}\n\nAnd this one produce a similar issue: Exception thrown: groovy.lang.ReadOnlyPropertyException: Cannot set readonly property: data for class: C\n\nBoth is related to the fact that the closure is routed throught C and not B which is the expectation. In the second sample, providing a protected setter is a workaround."
    ],
    [
        "GROOVY-4084",
        "GROOVY-3142",
        "Private class property not visible from closure in a super. invoked method {code}\nclass Foo {\n  private boolean b = false\n\n  def foo(msg) {\n    [\"a\"].each {\n      println it + b\n    }\n  }\n}\n\nclass Bar extends Foo {\n\n  def foo(Object msg) {\n    super.foo(msg)\n  }\n\n}\n\nnew Foo().foo(\"a\")\nnew Bar().foo(\"a\")\n{code}\n\nOutput:\n\nafalse\nCaught: groovy.lang.MissingPropertyException: No such property: b for class: Bar\n\tat Foo$_foo_closure1.doCall(test.groovy:6)\n\tat Foo.foo(test.groovy:5)\n\tat Bar.super$2$foo(test.groovy)\n\tat Bar.foo(test.groovy:14)\n\tat test.run(test.groovy:20)\n",
        "Unable to access inherited private fields from a closure within an inherited method {noformat}\nclass B {\n    String data\n    B(arg) {\n        arg.each() { this.@data = it }\n    }\n}\nclass C extends B {\n    C(arg) {\n        super(arg)\n    }\n}\nnew C([\"test\"])\n{noformat}\n\nThe previous unexpectedly produce: Exception thrown: groovy.lang.MissingFieldException: No such field: data for class: C\n\n{noformat}\nclass B {\n    private String data\n    public String getData() { this.@data }\n    private setData(String value) { this.@data = value }\n    B(arg) {\n        arg.each() { data = it }\n    }\n}\nclass C extends B {\n    C(arg) {\n        super(arg)\n    }\n}\n\nnew C([\"test\"])\n{noformat}\n\nAnd this one produce a similar issue: Exception thrown: groovy.lang.ReadOnlyPropertyException: Cannot set readonly property: data for class: C\n\nBoth is related to the fact that the closure is routed throught C and not B which is the expectation. In the second sample, providing a protected setter is a workaround."
    ],
    [
        "GROOVY-4084",
        "GROOVY-4083",
        "Private class property not visible from closure in a super. invoked method {code}\nclass Foo {\n  private boolean b = false\n\n  def foo(msg) {\n    [\"a\"].each {\n      println it + b\n    }\n  }\n}\n\nclass Bar extends Foo {\n\n  def foo(Object msg) {\n    super.foo(msg)\n  }\n\n}\n\nnew Foo().foo(\"a\")\nnew Bar().foo(\"a\")\n{code}\n\nOutput:\n\nafalse\nCaught: groovy.lang.MissingPropertyException: No such property: b for class: Bar\n\tat Foo$_foo_closure1.doCall(test.groovy:6)\n\tat Foo.foo(test.groovy:5)\n\tat Bar.super$2$foo(test.groovy)\n\tat Bar.foo(test.groovy:14)\n\tat test.run(test.groovy:20)\n",
        "private members should be accessible in closures used from sub classes Private members should be accessible in closures even if the code is called from sub classes (see test below). The current behavior prevents subclassing e.g of groovy.ui.Console.\n\nclass MySuperClass {\n    private test = \"test\"\n    \n    def run() {\n        {-> test }()\n    }\n}\n\nclass MySubClass extends MySuperClass {\n}\n\nassert new MySuperClass().run() == \"test\"\n\nassert new MySubClass().run() == \"test\"\n"
    ],
    [
        "GROOVY-4122",
        "GROOVY-4015",
        "super-constructor-call does not work for var args constructors I have attached a test case demonstrating this bug:\n\nclass First declares a Constructor with var args string parameter\nclass Second inherits this and declares a new constructor, which super-calls the var-args constructor with two strings (should work, since the original constructor can be called with two strings).\nhowever, the super-call throws a class cast exception because at some point groovy tries to cast one of the Strings to a String array, which of course is not possible.",
        "GStrings are not coerced to Strings in super constructor call class Foo {\n  def Foo(String s) { }\n}\nclass ImplString extends Foo {\n  def ImplString(String s) {\n    super(s)\n  }\n}\nclass ImplObject extends Foo {\n  def ImplObject(s) {\n    super(s)\n  }\n}\n\n\ndef a = 2\n\nnew ImplString(\"GString $a\")\nnew ImplObject(\"String\")\nnew ImplObject(\"GString $a\") //fails with CCE"
    ],
    [
        "GROOVY-4122",
        "GROOVY-4016",
        "super-constructor-call does not work for var args constructors I have attached a test case demonstrating this bug:\n\nclass First declares a Constructor with var args string parameter\nclass Second inherits this and declares a new constructor, which super-calls the var-args constructor with two strings (should work, since the original constructor can be called with two strings).\nhowever, the super-call throws a class cast exception because at some point groovy tries to cast one of the Strings to a String array, which of course is not possible.",
        "Single super constructor argument is casted to array if super constructor has vararg parameter {code:Java}\nclass Foo {\n  def Foo(String... s) { }\n}\nclass ImplOneParameter extends Foo {\n  def ImplOneParameter(String s) {\n    super(s)\n  }\n}\nclass ImplArray extends Foo {\n  def ImplArray(String[] s) {\n    super(s)\n  }\n}\n\n\nnew ImplArray(\"String\")\nnew ImplOneParameter(\"String\") //fails with CCE\n{code}\nThe same dispatch as for usual method calls should apply."
    ],
    [
        "GROOVY-4149",
        "GROOVY-4107",
        "1.7 error importing groovy scripts Following error when importing a script:\n\nCaught: BUG! exception in phase 'class generation' in source unit 'C:\\F\\miner\\xx.groovy' ClassNode#getTypeClass for xxutil is called before the type class is set \n\n\nThis works fine in 1.6.  I've attached very simple test scripts, xx.groovy, the main script and xxutil.groovy the imported script.\n\nThis is a major issue for me because I have many scripts that are failing under 1.7. ",
        "ResolveVisitor falsely resolves an import against itself ResolveVisitor seems to be resolving an unqualified import against itself by mistake.\n\nThe following code should fail with a \"Unable to resolve class Test\" error, but due to the ResolveVisitor bug, it reaches ACG and then fails.\n\n{code}\nimport Test\n\nTest.foo()\n{code}\n\nIt is failing with the following message:\n{noformat}\nCaught: BUG! exception in phase 'class generation' in source unit 'D:\\Roshan\\GroovyDevSetup\\Workspace18x\\Try18X\\src\\Try.groovy' ClassNode#getTypeClass for Roshan is called before the type class is set \n{noformat}"
    ],
    [
        "GROOVY-4149",
        "GROOVY-4128",
        "1.7 error importing groovy scripts Following error when importing a script:\n\nCaught: BUG! exception in phase 'class generation' in source unit 'C:\\F\\miner\\xx.groovy' ClassNode#getTypeClass for xxutil is called before the type class is set \n\n\nThis works fine in 1.6.  I've attached very simple test scripts, xx.groovy, the main script and xxutil.groovy the imported script.\n\nThis is a major issue for me because I have many scripts that are failing under 1.7. ",
        "error messages for 'incorrect' imports are incoherent Given:\n{code:title=constants.groovy}\nclass constants {\n  static int width=80\n}\n{code}\n\nThe following yield bizarre, non-helpful error messages.  (My first using of groovy, this wasted quite a bit of my time).  It doesn't help that the import policy is not well documented.  (e.g. there were no good examples that I could find)\n\nTrue, it's _similar_ to Java's, but the differences are enough to be impossibly cryptic when something goes wrong.\n\nExamples of things that went wrong for me:\n\n{code:title=err.groovy}\nimport constants\nprintln constants.width\n{code}\ngives:\n{quote}\nCaught: BUG! exception in phase 'class generation' in source unit '/homes/u0100050/groovy/errors/import/err.groovy' ClassNode#getTypeClass for constants is called before the type class is set\n{quote}\nA scary message that doesn't point you at all to the right solution.  You will get this whether or not it's an \"import static.\"\n\nNext:\n{code:title=noStatic.groovy}\nimport constants.*\nprintln constants.width\n{code}\n\nGives:\n{quote}\nCaught: groovy.lang.MissingPropertyException: No such property: constants for class: noStatic\n        at noStatic.run(noStatic.groovy:4)\n{quote}\n\nWhat it should be telling me is that I want the static keyword.\n\nHere's what works:\n{code:title=ok.groovy}\nimport static constants.*\nprintln constants.width\n{code}\n"
    ],
    [
        "GROOVY-4210",
        "GROOVY-3493",
        "String(Buffer|Builder).metaClass.toString ignored I assume this is a hard fix, as it is mentioned in GROOVY-2599, but the following code passes all the asserts.  I would have expected them all to fail?\n\n{code}\nString.metaClass.toString = {-> \"silly\"}\nStringBuffer.metaClass.toString = {-> \"silly\"}\nStringBuilder.metaClass.toString = {-> \"silly\"}\n\nassert \"hello world\".toString() == \"hello world\"\nassert new StringBuffer(\"hello world\").toString() == \"hello world\"\nassert new StringBuilder(\"hello world\").toString() == \"hello world\"\n{code}\n\nI have added it as a new issue as I don't believe GROOVY-2599 actually covers this problem, it just crops up in the comments",
        "Cannot override methods via metaclass that are part of an interface implementation The following works...\n\n{code}\nclass T {\n       def doIt() { true }\n}\n\ndef t = new T()\n\nassert t.doIt()\nt.metaClass.doIt = { -> false }\nassert !t.doIt()\n{code}\n\nBut this fails...\n\n{code}\ninterface I {\n       def doIt()\n}\n\nclass T implements I {\n       def doIt() { true }\n}\n\ndef t = new T()\n\nassert t.doIt()\nt.metaClass.doIt = { -> false }\nassert !t.doIt()\n{code}"
    ],
    [
        "GROOVY-4517",
        "GROOVY-4354",
        "Java stub generator does not set correct value for annotations that expect a Class as a value This issue is related to http://jira.codehaus.org/browse/GROOVY-4434. \n\nIf an annotation expects a class (not a classname, but a class) as its value, the java stub compiler does not seem to write out the java stub annotation value correctly. Here is some groovy code that shows an example:\n\n<code>\nimport org.springframework.test.context.junit4.SpringJUnit4ClassRunner\n@RunWith(SpringJUnit4ClassRunner.class)\nclass someClass{\n...\n}\n</code>\n\nThe @RunWith annotation expects an actual class (not a class name) as its parameter.\n\nIn the above mentioned issue, the annotation value is at least expanded to a fully qualified class name. Using the 1.7.6-SNAPSHOT (which includes the patch from GROOVY-4434), I can confirm the classname is expanded. However, this is the output of the java file the stub compiler creates:\n\n<code>\n@org.junit.runner.RunWith(value=org.springframework.test.context.junit4.SpringJUnit4ClassRunner) \nclass someClass{\n...\n}\n</code>\n\nThe trouble is that then javac chokes since org.springframework.test.context.junit4.SpringJUnit4ClassRunner is not an actual class reference. Interestingly, groovyc handles this same code just fine, but javac expects the .class suffix to make the class reference explicit. Thus, the generated code does not compile. \n\nI have attached a very simple patch which seems to address this issue. I do not know, however if this might break something else. \n",
        "Stub Generator does not add .class for classes in annotations The Groovy Stub generator does not add a .class extension for Class usages in annotations. For example, generating stubs for the following doesn't work:\n\n{noformat}\n    @Test(expected = IllegalArgumentException)\n    void shouldFailOnDifferentCurrencies() {\n       // impl\n    }\n{noformat}\n\nFor more information, see GMAVEN-79"
    ],
    [
        "GROOVY-4568",
        "GROOVY-4485",
        "MapEntry parameters don't work for enum elements This code should be valid: \n{code}\nenum MyEnum {\n  FOO(prop: 'foo'), \n  BAR(prop: 'bar'); \n  String prop\n}\n{code}\n\nBut it fails to compile in 1.8 with this exception: \n\n{code}\nBUG! exception in phase 'class generation' in source unit 'ConsoleScript2' MapEntryExpression should not be visited here\n\n\tat org.codehaus.groovy.classgen.AsmClassGenerator.visitMapEntryExpression(AsmClassGenerator.java:1326)\n\n\tat org.codehaus.groovy.ast.expr.MapEntryExpression.visit(MapEntryExpression.java:37)\n\n\tat org.codehaus.groovy.classgen.asm.CallSiteWriter.makeCallSite(CallSiteWriter.java:301)\n\n\tat org.codehaus.groovy.classgen.asm.InvocationWriter.makeCall(InvocationWriter.java:157)\n\n\tat org.codehaus.groovy.classgen.asm.InvocationWriter.makeCall(InvocationWriter.java:87)\n\n\tat org.codehaus.groovy.classgen.asm.InvocationWriter.writeInvokeStaticMethod(InvocationWriter.java:306)\n\n\tat org.codehaus.groovy.classgen.AsmClassGenerator.visitStaticMethodCallExpression(AsmClassGenerator.java:674)\n\n\tat org.codehaus.groovy.ast.expr.StaticMethodCallExpression.visit(StaticMethodCallExpression.java:43)\n\n\tat org.codehaus.groovy.classgen.asm.BinaryExpressionHelper.evaluateEqual(BinaryExpressionHelper.java:281)\n\n\tat org.codehaus.groovy.classgen.asm.BinaryExpressionHelper.eval(BinaryExpressionHelper.java:70)\n\n\tat org.codehaus.groovy.classgen.AsmClassGenerator.visitBinaryExpression(AsmClassGenerator.java:503)\n\n\tat org.codehaus.groovy.ast.expr.BinaryExpression.visit(BinaryExpression.java:49)\n\n\tat org.codehaus.groovy.classgen.asm.StatementWriter.writeExpressionStatement(StatementWriter.java:599)\n\n\tat org.codehaus.groovy.classgen.asm.OptimizingStatementWriter.writeExpressionStatement(OptimizingStatementWriter.java:300)\n\n\tat org.codehaus.groovy.classgen.AsmClassGenerator.visitExpressionStatement(AsmClassGenerator.java:437)\n\n\tat org.codehaus.groovy.ast.stmt.ExpressionStatement.visit(ExpressionStatement.java:40)\n\n\tat org.codehaus.groovy.classgen.asm.StatementWriter.writeBlockStatement(StatementWriter.java:80)\n\n\tat org.codehaus.groovy.classgen.asm.OptimizingStatementWriter.writeBlockStatement(OptimizingStatementWriter.java:128)\n\n\tat org.codehaus.groovy.classgen.AsmClassGenerator.visitBlockStatement(AsmClassGenerator.java:383)\n\n\tat org.codehaus.groovy.ast.stmt.BlockStatement.visit(BlockStatement.java:51)\n\n\tat org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClassCodeContainer(ClassCodeVisitorSupport.java:101)\n\n\tat org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitConstructorOrMethod(ClassCodeVisitorSupport.java:112)\n\n\tat org.codehaus.groovy.classgen.AsmClassGenerator.visitStdMethod(AsmClassGenerator.java:281)\n\n\tat org.codehaus.groovy.classgen.AsmClassGenerator.visitConstructorOrMethod(AsmClassGenerator.java:260)\n\n\tat org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitMethod(ClassCodeVisitorSupport.java:123)\n\n\tat org.codehaus.groovy.classgen.AsmClassGenerator.visitMethod(AsmClassGenerator.java:343)\n\n\tat org.codehaus.groovy.ast.ClassNode.visitContents(ClassNode.java:1056)\n\n\tat org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClass(ClassCodeVisitorSupport.java:50)\n\n\tat org.codehaus.groovy.classgen.AsmClassGenerator.visitClass(AsmClassGenerator.java:174)\n\n\tat org.codehaus.groovy.control.CompilationUnit$12.call(CompilationUnit.java:745)\n\n\tat org.codehaus.groovy.control.CompilationUnit.applyToPrimaryClassNodes(CompilationUnit.java:939)\n\n\tat org.codehaus.groovy.control.CompilationUnit.doPhaseOperation(CompilationUnit.java:518)\n\n\tat org.codehaus.groovy.control.CompilationUnit.processPhaseOperations(CompilationUnit.java:496)\n\n\tat org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:473)\n\n\tat groovy.lang.GroovyClassLoader.doParseClass(GroovyClassLoader.java:306)\n\n\tat groovy.lang.GroovyClassLoader.parseClass(GroovyClassLoader.java:287)\n\n\tat groovy.lang.GroovyShell.parseClass(GroovyShell.java:731)\n\n\tat groovy.lang.GroovyShell.run(GroovyShell.java:516)\n\n\tat groovy.lang.GroovyShell.run(GroovyShell.java:172)\n\n\tat groovy.lang.GroovyShell$run$0.call(Unknown Source)\n\n\tat org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:42)\n\n\tat org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:108)\n\n\tat org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:124)\n\n\tat groovy.ui.Console$_runScriptImpl_closure17.doCall(Console.groovy:927)\n\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n\tat java.lang.reflect.Method.invoke(Method.java:597)\n\tat org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:88)\n\tat groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:233)\n\tat org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:272)\n\tat groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:885)\n\tat org.codehaus.groovy.runtime.callsite.PogoMetaClassSite.callCurrent(PogoMetaClassSite.java:66)\n\tat org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCallCurrent(CallSiteArray.java:46)\n\tat org.codehaus.groovy.runtime.callsite.AbstractCallSite.callCurrent(AbstractCallSite.java:133)\n\tat org.codehaus.groovy.runtime.callsite.AbstractCallSite.callCurrent(AbstractCallSite.java:141)\n\tat groovy.ui.Console$_runScriptImpl_closure17.doCall(Console.groovy)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n\tat java.lang.reflect.Method.invoke(Method.java:597)\n\tat org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:88)\n\tat groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:233)\n\tat org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:272)\n\tat groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:885)\n\tat groovy.lang.Closure.call(Closure.java:293)\n\tat groovy.lang.Closure.call(Closure.java:287)\n\tat groovy.lang.Closure.run(Closure.java:371)\n\n\tat java.lang.Thread.run(Thread.java:619)\n{code}\n",
        "enum does not support default map constructors This enum should compile, but it does not.\n\n{code}\nenum ExportFormat {\n\n    EXCEL_OOXML(mime: \"application/vnd.ms-excel\", extension: \"xlsx\"),\n    EXCEL_BINARY(mime: \"application/vnd.ms-excel\", extension: \"xls\"),\n    EXCEL_HTML(mime: \"application/vnd.ms-excel\", extension: \"xls\")\n    \n    String mime\n    String extension\n\n}\n{code}"
    ],
    [
        "GROOVY-4901",
        "GROOVY-4757",
        "Compilatin exception for a method with generics and default access modifier The following code fails with a compilation exception due to \"bad syntax\"\n\n{code:title=Foo.java}\npublic interface Foo {}\n{code}\n\n{code:title=Bar.groovy}\nclass Bar {\n    <Foo> void foo() {}\n}\n{code}\n\n{code}\ngroovyc Foo.java Bar.groovy \norg.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed:\nBar.groovy: 2: unexpected token: < @ line 2, column 5.\n       <Foo> void foo() {}\n       ^\n\n1 error\n{code}\n\nHowever if the {{public}} modifier is added to the method declaration this will work. BUT it breaks when @Delegate is added into the mix (I know AST xforms have plenty of corner cases, I'm pretty confident that if the 1st error is solved then @Delegate should work as well).",
        "Can't compile method with generic signatures and defualt visibiliy access The following script results in a compilation error\n\n{code}\nclass Foo {\n    <T extends Object> void foo(T t) {}\n}\n\nf = new Foo()\n// compiler output\n1 compilation error:\n\nunexpected token: < at line: 2, column: 5\n{code}\n\nAdding a visibility accessor makes it work\n\n{code}\nclass Foo {\n    public <T extends Object> void foo(T t) {}\n}\n\nf = new Foo()\n{code}"
    ],
    [
        "GROOVY-4911",
        "GROOVY-4661",
        "nonintuitive behaviour on getting sublist with range def list = [1,2,3,4]\nlist[0..<-1]\n\nFor me the first interpretation in mind would be: get everything but last from the list.\nBut range 0..<-1 == 0..0 and we get just one element.\n\nI think ..< ranges should not implicitly be converted to .. ranges, but should hold original edges and the type.\nIn this case in getting sublist operation -1 first become size()-1 == 3 and then depending on type become 2 or just stay 3",
        "List#getAt(Range) method doesn't work with half-exclusive ranges def list = [1, 2, 3, 4]\n\nprintln list[0..<1]    // [1], correct\nprintln list[0..<2]    // [1, 2], correct\nprintln list[0..<-1]   // [1], should be [1, 2, 3]\nprintln list[0..<-2]   // [1, 2, 3, 4], should be [1, 2]\n\nWhile this particular behavior is not covered in the Groovy JDK documentation it is intuitive to believe that indexing by such half-exclusive ranges should work just fine. But it doesn't."
    ],
    [
        "GROOVY-5215",
        "GROOVY-5214",
        "Linenumber information is missing for Enums in AST In the AST for enums, the linenumber information is not available. This causes some errors in CodeNarc, which uses that information to report on.",
        "Source location incorrect for enums As per:\nhttps://github.com/groovy/groovy-core/pull/10"
    ],
    [
        "GROOVY-5225",
        "GROOVY-4189",
        "CLONE - Removing a metaClass method Spotted a question on stackoverflow about removing a metaclass method\n\nThe page here\n\nhttp://groovy.codehaus.org/JN3525-MetaClasses\n\nSays you should be able to do it by setting it to null, but we get this:\n{code}\nString.metaClass.foo = { \"${delegate}foo\" }\nassert 'kung'.foo() == 'kungfoo'\nString.metaClass.foo = null\nassert 'woo'.foo() == 'woofoo'\n{code}\nThat last assert should fail (according to the docs), but it passes\n\nIs this a documentation issue?",
        "Removing a metaClass method Spotted a question on stackoverflow about removing a metaclass method\n\nThe page here\n\nhttp://groovy.codehaus.org/JN3525-MetaClasses\n\nSays you should be able to do it by setting it to null, but we get this:\n{code}\nString.metaClass.foo = { \"${delegate}foo\" }\nassert 'kung'.foo() == 'kungfoo'\nString.metaClass.foo = null\nassert 'woo'.foo() == 'woofoo'\n{code}\nThat last assert should fail (according to the docs), but it passes\n\nIs this a documentation issue?"
    ],
    [
        "GROOVY-5309",
        "GROOVY-3437",
        "Wrong line/col info for binary expressions {code}\nassert annotationsOfIdField[0]    instanceof Id\n{code}\n\nThe binary expression between the assert and instanceof: the end of the line / col info is right before instance of, instead of being after the last closing square bracket",
        "Line / column issues in the AST While integrating and extending Hamlet's AST browser in the Groovy swing console, I noticed that some AST nodes still not had the right line / column information.\n\nA few examples:\n\n* Binary expressions\n{code}\nassert annotationsOfIdField[0]    instanceof Id\n{code}\nThe binary expression between the assert and instanceof: the end of the line / col info is right before instance of, instead of being after the last closing square bracket\n\n* Statements\nIf there are spaces at the end of a line statement, the space is also accounted in the lin / col info, instead of being the last character of the statement\n\n* Annotations\nPerhaps it's as designed, but I was wondering what should be the start / end of an annotation.\n{code}\n@Target([ElementType.TYPE])\n{code}\nHere, the annotation node has a start after the @ and the end before the open parentheses.\nShould the whole expression be highlighted, or just the class name of the annotation?\n\n* GStrings\nGStrings have problems with their various sub parts: the constant strings and the variables interpolated.\nWith this example:\n{code}\ndef gs1 = \"-$a-${b}-${->c}-\" \n{code}\nThe first constant string represents \"-$ instead of just the minus sign.\nThe second and third constant are -$ instead of just the minus sign again.\nAnd the last constant is -\", instead of just the minus sign, it's going one character too far.\nNow on to the variables.\nVariable a is okay.\nVarible b is actually {b} and I think it should be just b\nAnd the closure expression is jut right too.\n\n* MapEntryExpression\nWhenever there's a map entry, a named parameter, etc, a MapEntryExpression is used, but the line / col of MapEntryExpression is just surrounding the column, instead of the whole key + colon + value.\nAnother problem with MEE is that the value goes up to the next comma or closing square bracket (including all potential whitespace), instead of just stopping at the end of the expression or constant.\n\n* SpreadMapExpression\n{code}\ndef m = [a  :1  , b: 2 ]\ndef map = [abc: 1, bcd: 2, *:m , cde: 3]\n{code}\nThe SME highlights just the star *, and the m variable is highlighted till the comma, instead of just the m character."
    ],
    [
        "GROOVY-5310",
        "GROOVY-3437",
        "Wrong line/col info for statements with whitespace before EOL If there are spaces at the end of a line statement, the space is also accounted in the lin / col info, instead of being the last (non-whitespace) character of the statement",
        "Line / column issues in the AST While integrating and extending Hamlet's AST browser in the Groovy swing console, I noticed that some AST nodes still not had the right line / column information.\n\nA few examples:\n\n* Binary expressions\n{code}\nassert annotationsOfIdField[0]    instanceof Id\n{code}\nThe binary expression between the assert and instanceof: the end of the line / col info is right before instance of, instead of being after the last closing square bracket\n\n* Statements\nIf there are spaces at the end of a line statement, the space is also accounted in the lin / col info, instead of being the last character of the statement\n\n* Annotations\nPerhaps it's as designed, but I was wondering what should be the start / end of an annotation.\n{code}\n@Target([ElementType.TYPE])\n{code}\nHere, the annotation node has a start after the @ and the end before the open parentheses.\nShould the whole expression be highlighted, or just the class name of the annotation?\n\n* GStrings\nGStrings have problems with their various sub parts: the constant strings and the variables interpolated.\nWith this example:\n{code}\ndef gs1 = \"-$a-${b}-${->c}-\" \n{code}\nThe first constant string represents \"-$ instead of just the minus sign.\nThe second and third constant are -$ instead of just the minus sign again.\nAnd the last constant is -\", instead of just the minus sign, it's going one character too far.\nNow on to the variables.\nVariable a is okay.\nVarible b is actually {b} and I think it should be just b\nAnd the closure expression is jut right too.\n\n* MapEntryExpression\nWhenever there's a map entry, a named parameter, etc, a MapEntryExpression is used, but the line / col of MapEntryExpression is just surrounding the column, instead of the whole key + colon + value.\nAnother problem with MEE is that the value goes up to the next comma or closing square bracket (including all potential whitespace), instead of just stopping at the end of the expression or constant.\n\n* SpreadMapExpression\n{code}\ndef m = [a  :1  , b: 2 ]\ndef map = [abc: 1, bcd: 2, *:m , cde: 3]\n{code}\nThe SME highlights just the star *, and the m variable is highlighted till the comma, instead of just the m character."
    ],
    [
        "GROOVY-5310",
        "GROOVY-5309",
        "Wrong line/col info for statements with whitespace before EOL If there are spaces at the end of a line statement, the space is also accounted in the lin / col info, instead of being the last (non-whitespace) character of the statement",
        "Wrong line/col info for binary expressions {code}\nassert annotationsOfIdField[0]    instanceof Id\n{code}\n\nThe binary expression between the assert and instanceof: the end of the line / col info is right before instance of, instead of being after the last closing square bracket"
    ],
    [
        "GROOVY-5311",
        "GROOVY-3437",
        "Wrong line/col info for GStrings GStrings have problems with their various sub parts: the constant strings and the variables interpolated.\nWith this example:\n{code}\ndef gs1 = \"-$a-${b}-${->c}-\"\n{code}\nThe first constant string represents \"-$ instead of just the minus sign.\nThe second and third constant are -$ instead of just the minus sign again.\nAnd the last constant is -\", instead of just the minus sign, it's going one character too far.\nNow on to the variables.\nVariable a is okay.\nVarible b is actually {b} and I think it should be just b\nAnd the closure expression is jut right too.",
        "Line / column issues in the AST While integrating and extending Hamlet's AST browser in the Groovy swing console, I noticed that some AST nodes still not had the right line / column information.\n\nA few examples:\n\n* Binary expressions\n{code}\nassert annotationsOfIdField[0]    instanceof Id\n{code}\nThe binary expression between the assert and instanceof: the end of the line / col info is right before instance of, instead of being after the last closing square bracket\n\n* Statements\nIf there are spaces at the end of a line statement, the space is also accounted in the lin / col info, instead of being the last character of the statement\n\n* Annotations\nPerhaps it's as designed, but I was wondering what should be the start / end of an annotation.\n{code}\n@Target([ElementType.TYPE])\n{code}\nHere, the annotation node has a start after the @ and the end before the open parentheses.\nShould the whole expression be highlighted, or just the class name of the annotation?\n\n* GStrings\nGStrings have problems with their various sub parts: the constant strings and the variables interpolated.\nWith this example:\n{code}\ndef gs1 = \"-$a-${b}-${->c}-\" \n{code}\nThe first constant string represents \"-$ instead of just the minus sign.\nThe second and third constant are -$ instead of just the minus sign again.\nAnd the last constant is -\", instead of just the minus sign, it's going one character too far.\nNow on to the variables.\nVariable a is okay.\nVarible b is actually {b} and I think it should be just b\nAnd the closure expression is jut right too.\n\n* MapEntryExpression\nWhenever there's a map entry, a named parameter, etc, a MapEntryExpression is used, but the line / col of MapEntryExpression is just surrounding the column, instead of the whole key + colon + value.\nAnother problem with MEE is that the value goes up to the next comma or closing square bracket (including all potential whitespace), instead of just stopping at the end of the expression or constant.\n\n* SpreadMapExpression\n{code}\ndef m = [a  :1  , b: 2 ]\ndef map = [abc: 1, bcd: 2, *:m , cde: 3]\n{code}\nThe SME highlights just the star *, and the m variable is highlighted till the comma, instead of just the m character."
    ],
    [
        "GROOVY-5311",
        "GROOVY-5309",
        "Wrong line/col info for GStrings GStrings have problems with their various sub parts: the constant strings and the variables interpolated.\nWith this example:\n{code}\ndef gs1 = \"-$a-${b}-${->c}-\"\n{code}\nThe first constant string represents \"-$ instead of just the minus sign.\nThe second and third constant are -$ instead of just the minus sign again.\nAnd the last constant is -\", instead of just the minus sign, it's going one character too far.\nNow on to the variables.\nVariable a is okay.\nVarible b is actually {b} and I think it should be just b\nAnd the closure expression is jut right too.",
        "Wrong line/col info for binary expressions {code}\nassert annotationsOfIdField[0]    instanceof Id\n{code}\n\nThe binary expression between the assert and instanceof: the end of the line / col info is right before instance of, instead of being after the last closing square bracket"
    ],
    [
        "GROOVY-5311",
        "GROOVY-5310",
        "Wrong line/col info for GStrings GStrings have problems with their various sub parts: the constant strings and the variables interpolated.\nWith this example:\n{code}\ndef gs1 = \"-$a-${b}-${->c}-\"\n{code}\nThe first constant string represents \"-$ instead of just the minus sign.\nThe second and third constant are -$ instead of just the minus sign again.\nAnd the last constant is -\", instead of just the minus sign, it's going one character too far.\nNow on to the variables.\nVariable a is okay.\nVarible b is actually {b} and I think it should be just b\nAnd the closure expression is jut right too.",
        "Wrong line/col info for statements with whitespace before EOL If there are spaces at the end of a line statement, the space is also accounted in the lin / col info, instead of being the last (non-whitespace) character of the statement"
    ],
    [
        "GROOVY-5312",
        "GROOVY-3437",
        "Wrong line/col info for MapEntryExpressions Whenever there's a map entry, a named parameter, etc, a MapEntryExpression is used, but the line / col of MapEntryExpression is just surrounding the column, instead of the whole key + colon + value.\n\nAnother problem with MEE is that the value goes up to the next comma or closing square bracket (including all potential whitespace), instead of just stopping at the end of the expression or constant.",
        "Line / column issues in the AST While integrating and extending Hamlet's AST browser in the Groovy swing console, I noticed that some AST nodes still not had the right line / column information.\n\nA few examples:\n\n* Binary expressions\n{code}\nassert annotationsOfIdField[0]    instanceof Id\n{code}\nThe binary expression between the assert and instanceof: the end of the line / col info is right before instance of, instead of being after the last closing square bracket\n\n* Statements\nIf there are spaces at the end of a line statement, the space is also accounted in the lin / col info, instead of being the last character of the statement\n\n* Annotations\nPerhaps it's as designed, but I was wondering what should be the start / end of an annotation.\n{code}\n@Target([ElementType.TYPE])\n{code}\nHere, the annotation node has a start after the @ and the end before the open parentheses.\nShould the whole expression be highlighted, or just the class name of the annotation?\n\n* GStrings\nGStrings have problems with their various sub parts: the constant strings and the variables interpolated.\nWith this example:\n{code}\ndef gs1 = \"-$a-${b}-${->c}-\" \n{code}\nThe first constant string represents \"-$ instead of just the minus sign.\nThe second and third constant are -$ instead of just the minus sign again.\nAnd the last constant is -\", instead of just the minus sign, it's going one character too far.\nNow on to the variables.\nVariable a is okay.\nVarible b is actually {b} and I think it should be just b\nAnd the closure expression is jut right too.\n\n* MapEntryExpression\nWhenever there's a map entry, a named parameter, etc, a MapEntryExpression is used, but the line / col of MapEntryExpression is just surrounding the column, instead of the whole key + colon + value.\nAnother problem with MEE is that the value goes up to the next comma or closing square bracket (including all potential whitespace), instead of just stopping at the end of the expression or constant.\n\n* SpreadMapExpression\n{code}\ndef m = [a  :1  , b: 2 ]\ndef map = [abc: 1, bcd: 2, *:m , cde: 3]\n{code}\nThe SME highlights just the star *, and the m variable is highlighted till the comma, instead of just the m character."
    ],
    [
        "GROOVY-5312",
        "GROOVY-5309",
        "Wrong line/col info for MapEntryExpressions Whenever there's a map entry, a named parameter, etc, a MapEntryExpression is used, but the line / col of MapEntryExpression is just surrounding the column, instead of the whole key + colon + value.\n\nAnother problem with MEE is that the value goes up to the next comma or closing square bracket (including all potential whitespace), instead of just stopping at the end of the expression or constant.",
        "Wrong line/col info for binary expressions {code}\nassert annotationsOfIdField[0]    instanceof Id\n{code}\n\nThe binary expression between the assert and instanceof: the end of the line / col info is right before instance of, instead of being after the last closing square bracket"
    ],
    [
        "GROOVY-5312",
        "GROOVY-5310",
        "Wrong line/col info for MapEntryExpressions Whenever there's a map entry, a named parameter, etc, a MapEntryExpression is used, but the line / col of MapEntryExpression is just surrounding the column, instead of the whole key + colon + value.\n\nAnother problem with MEE is that the value goes up to the next comma or closing square bracket (including all potential whitespace), instead of just stopping at the end of the expression or constant.",
        "Wrong line/col info for statements with whitespace before EOL If there are spaces at the end of a line statement, the space is also accounted in the lin / col info, instead of being the last (non-whitespace) character of the statement"
    ],
    [
        "GROOVY-5312",
        "GROOVY-5311",
        "Wrong line/col info for MapEntryExpressions Whenever there's a map entry, a named parameter, etc, a MapEntryExpression is used, but the line / col of MapEntryExpression is just surrounding the column, instead of the whole key + colon + value.\n\nAnother problem with MEE is that the value goes up to the next comma or closing square bracket (including all potential whitespace), instead of just stopping at the end of the expression or constant.",
        "Wrong line/col info for GStrings GStrings have problems with their various sub parts: the constant strings and the variables interpolated.\nWith this example:\n{code}\ndef gs1 = \"-$a-${b}-${->c}-\"\n{code}\nThe first constant string represents \"-$ instead of just the minus sign.\nThe second and third constant are -$ instead of just the minus sign again.\nAnd the last constant is -\", instead of just the minus sign, it's going one character too far.\nNow on to the variables.\nVariable a is okay.\nVarible b is actually {b} and I think it should be just b\nAnd the closure expression is jut right too."
    ],
    [
        "GROOVY-5313",
        "GROOVY-3437",
        "Wrong line/col info for SpreadMapExpressions {code}\ndef m = [a  :1  , b: 2 ]\ndef map = [abc: 1, bcd: 2, *:m , cde: 3]\n{code}\nThe SpreadMapExpression highlights just the star *, and the m variable is highlighted till the comma, instead of just the m character (ie. including further whitespace).",
        "Line / column issues in the AST While integrating and extending Hamlet's AST browser in the Groovy swing console, I noticed that some AST nodes still not had the right line / column information.\n\nA few examples:\n\n* Binary expressions\n{code}\nassert annotationsOfIdField[0]    instanceof Id\n{code}\nThe binary expression between the assert and instanceof: the end of the line / col info is right before instance of, instead of being after the last closing square bracket\n\n* Statements\nIf there are spaces at the end of a line statement, the space is also accounted in the lin / col info, instead of being the last character of the statement\n\n* Annotations\nPerhaps it's as designed, but I was wondering what should be the start / end of an annotation.\n{code}\n@Target([ElementType.TYPE])\n{code}\nHere, the annotation node has a start after the @ and the end before the open parentheses.\nShould the whole expression be highlighted, or just the class name of the annotation?\n\n* GStrings\nGStrings have problems with their various sub parts: the constant strings and the variables interpolated.\nWith this example:\n{code}\ndef gs1 = \"-$a-${b}-${->c}-\" \n{code}\nThe first constant string represents \"-$ instead of just the minus sign.\nThe second and third constant are -$ instead of just the minus sign again.\nAnd the last constant is -\", instead of just the minus sign, it's going one character too far.\nNow on to the variables.\nVariable a is okay.\nVarible b is actually {b} and I think it should be just b\nAnd the closure expression is jut right too.\n\n* MapEntryExpression\nWhenever there's a map entry, a named parameter, etc, a MapEntryExpression is used, but the line / col of MapEntryExpression is just surrounding the column, instead of the whole key + colon + value.\nAnother problem with MEE is that the value goes up to the next comma or closing square bracket (including all potential whitespace), instead of just stopping at the end of the expression or constant.\n\n* SpreadMapExpression\n{code}\ndef m = [a  :1  , b: 2 ]\ndef map = [abc: 1, bcd: 2, *:m , cde: 3]\n{code}\nThe SME highlights just the star *, and the m variable is highlighted till the comma, instead of just the m character."
    ],
    [
        "GROOVY-5313",
        "GROOVY-5309",
        "Wrong line/col info for SpreadMapExpressions {code}\ndef m = [a  :1  , b: 2 ]\ndef map = [abc: 1, bcd: 2, *:m , cde: 3]\n{code}\nThe SpreadMapExpression highlights just the star *, and the m variable is highlighted till the comma, instead of just the m character (ie. including further whitespace).",
        "Wrong line/col info for binary expressions {code}\nassert annotationsOfIdField[0]    instanceof Id\n{code}\n\nThe binary expression between the assert and instanceof: the end of the line / col info is right before instance of, instead of being after the last closing square bracket"
    ],
    [
        "GROOVY-5313",
        "GROOVY-5310",
        "Wrong line/col info for SpreadMapExpressions {code}\ndef m = [a  :1  , b: 2 ]\ndef map = [abc: 1, bcd: 2, *:m , cde: 3]\n{code}\nThe SpreadMapExpression highlights just the star *, and the m variable is highlighted till the comma, instead of just the m character (ie. including further whitespace).",
        "Wrong line/col info for statements with whitespace before EOL If there are spaces at the end of a line statement, the space is also accounted in the lin / col info, instead of being the last (non-whitespace) character of the statement"
    ],
    [
        "GROOVY-5313",
        "GROOVY-5311",
        "Wrong line/col info for SpreadMapExpressions {code}\ndef m = [a  :1  , b: 2 ]\ndef map = [abc: 1, bcd: 2, *:m , cde: 3]\n{code}\nThe SpreadMapExpression highlights just the star *, and the m variable is highlighted till the comma, instead of just the m character (ie. including further whitespace).",
        "Wrong line/col info for GStrings GStrings have problems with their various sub parts: the constant strings and the variables interpolated.\nWith this example:\n{code}\ndef gs1 = \"-$a-${b}-${->c}-\"\n{code}\nThe first constant string represents \"-$ instead of just the minus sign.\nThe second and third constant are -$ instead of just the minus sign again.\nAnd the last constant is -\", instead of just the minus sign, it's going one character too far.\nNow on to the variables.\nVariable a is okay.\nVarible b is actually {b} and I think it should be just b\nAnd the closure expression is jut right too."
    ],
    [
        "GROOVY-5313",
        "GROOVY-5312",
        "Wrong line/col info for SpreadMapExpressions {code}\ndef m = [a  :1  , b: 2 ]\ndef map = [abc: 1, bcd: 2, *:m , cde: 3]\n{code}\nThe SpreadMapExpression highlights just the star *, and the m variable is highlighted till the comma, instead of just the m character (ie. including further whitespace).",
        "Wrong line/col info for MapEntryExpressions Whenever there's a map entry, a named parameter, etc, a MapEntryExpression is used, but the line / col of MapEntryExpression is just surrounding the column, instead of the whole key + colon + value.\n\nAnother problem with MEE is that the value goes up to the next comma or closing square bracket (including all potential whitespace), instead of just stopping at the end of the expression or constant."
    ],
    [
        "GROOVY-5337",
        "GROOVY-4606",
        "Collection.unique() is O(n^2) time -- suggestion for improvement I tried Collection.unique{closure}\nand it was getting very slow when the dataset grew.\nI believe it to be O(n^2)\n\nI have not yet looked it up in the groovy sources,\nbut I believe that it must be implemented,\nlike calling that closure over and over again.\n\nI'd like to suggest an alternative implementation,\nwhich actually made things toward O(n) in my case.\n\nlike:\nMap unique\nunique.put(closure(it), it)\nreturn unique.values()\n\nWhile this might use some more memory,\nit really beats the current implementation hands of.\n\nPlease note that in this type of implementation,\nthe closure is only called *once* per element,\nand all the burden of uniquing is placed on the map.\n\n\nIt should be consistent with the contract of the current api.\nBut it's much faster!\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
        "Exteremely bad performance of .unique() and .unique {closure} DefaultGroovyMethods.unique has two inner loops, so its complexity is O(n^2)\nPractically it means that it starts taking ages on collections with 1000 or more elements.\n\nSimply adding elements to a linked hash set would get O(n*log n) performance.\nWill develop my own unique implementation after New Year, and will attach it here"
    ],
    [
        "GROOVY-5369",
        "GROOVY-5208",
        "Incorrect line numbers in Groovy generated .class files unable to set breakpoints The visible problem is that debugger doesn't stop on the lines containing only primitive value operations. See more details in http://youtrack.jetbrains.net/issue/IDEA-77107.",
        "Incorrect line numbers in code using optimized primitive operations The visible problem is that debugger doesn't stop on the lines containing only primitive value operations. See more details in http://youtrack.jetbrains.net/issue/IDEA-77107."
    ],
    [
        "GROOVY-5390",
        "GROOVY-4102",
        "groovyc class generation kind of break default serialVersionUID generation by the jvm When using groovyc ant task for compiling groovy classes, the class generation visitor pattern creates a non transient static field with a variable name (timestamp) for each visited class. \n\n(cf org.codehaus.groovy.classgen.Verifier.addTimeStamp(ClassNode node) method which adds a field whose name is : \"__timeStamp__239_neverHappen\" + String.valueOf(System.currentTimeMillis())\n\n\nIf the class has no specified serialVersionUID, the jvm will compute one during the first serialisation/deserialization. Because of this field, this computed serialVersionUID will change after each compilation, even if the class has no change whatsoever.\n\n\nA workaround is of course to add a serialVersionUID to the groovy object, but this is kind of an annoyance, because default generation just works perfectly for cases in which you use serialization for things such as cache and session management, and you don't have to enforce a process in which each developer has to manually manage that serialVersionUID manually every time the class change.\n\nI have the feeling that this annoyance could be avoided, if the synthetic field added by the Verifier was set as transient, and I think it would not defeat the purpose of this field (I may of course be wrong on either of those subject...)",
        "remove timestamp fields for better hotswap While debugging I try to hot swap a groovy class.\nIt always fails with messages \"Schema change not implemented. Operation not supported by VM\".\n\nWith Java classes there is no such problem - hot swap works as long as I don't add/remove any field or method or change a method signature.\n\nI had hoped to gradually convert my Java app to groovy, but this made me refrain from using groovy for anything more complex than \"java\" beans.\n\nLooking at the bytecode with javap, it is obvious where the problem is:\nThere is an artifical  field that changes its name on each compilation.\nInitial:\n   public static java.lang.Long __timeStamp__239_neverHappen1268432715287;\nAfter recompilation:\n   public static java.lang.Long __timeStamp__239_neverHappen1268433121889;\n\nWhat is this field used for? Can't we get rid of it?\nAll other fields/methods look the same after recompilation, so I am pretty sure that hot swap will work without this field change.\n"
    ],
    [
        "GROOVY-5607",
        "GROOVY-5573",
        "@Compile static Sql.newInstance Don't know if this bug has been reported before (didn't find anything while looking)\n{code}\n@CompileStatic\nclass M\n{\n\tpublic void r()\n\t{\n\t     Sql sql = Sql.newInstance(\"jdbc:mysql://localhost/dummy\", \"dummy\", \"dummy\", \"com.mysql.jdbc.Driver\")\n\t}\n}\n\n(new M()).r()\n{code}\nfails with\n{code}\nCaught: groovy.lang.GroovyRuntimeException: Could not find matching constructor for: groovy.sql.Sql(java.lang.String, java.lang.String, java.lang.String, java.lang.String)\ngroovy.lang.GroovyRuntimeException: Could not find matching constructor for: groovy.sql.Sql(java.lang.String, java.lang.String, java.lang.String, java.lang.String)\n\tat M.r(Test2.groovy:11)\n\tat M$r.call(Unknown Source)\n\tat Test2.run(Test2.groovy:18)\n{code}\n\nLooks like DefaultGroovyMethods.newInstance get's called instead.\n\nRemoving @CompileStatic fixes the problem\n",
        "Type checker incorrectly selecting DGM return type instead of actual return type The following code:\n\n{code}\nimport java.lang.reflect.Array\n\n@groovy.transform.CompileStatic\ndef arrayTest() {\n   Object[] joinedArray = (Object[]) Array.newInstance(Integer.class, 10);\n}\n{code}\n\nResults in \n\n{code}\n[Static type checking] - Inconvertible types: cannot cast java.lang.reflect.Array to [Ljava.lang.Object;\n at line: 5, column: 27\n{code}\n\nThe DGM newInstance method is being used instead of http://docs.oracle.com/javase/6/docs/api/java/lang/reflect/Array.html#newInstance(java.lang.Class,%20int)"
    ],
    [
        "GROOVY-5790",
        "GROOVY-3476",
        "PermGen leak when using groovy command line in listen mode If I start listening to a port with an associated script (groovy -l port script), and then call the script through the opened port, I eventually get :\n\nException in thread \"Groovy client connection - 0:0:0:0:0:0:0:1%0\" java.lang.OutOfMemoryError: PermGen space\n\nafter calling the script 800 times or so.\n\nIn GroovySocketServer.run(), if I add :\n\n  groovy.resetLoadedClasses();\n  groovy.getClassLoader().clearCache();\nafter\n  new GroovyClientConnection(script, autoOutput, serverSocket.accept());\n\nI can call the script more than 4000 times without OOME/PermGen\n\n(I use CMSClassUnloadingEnabled/UseConcMarkSweepGC/-server flags)\n",
        "groovy -l constantly loads classes and leaks memory The classes loaded by a -l script keep increasing until the JVM runs out of memory.  I saw this with a script file, but it also can be demonstrated with two command lines:\n\n{code}\nJAVA_OPTS=\"-Xmx5m\" groovy -l 5000 -e \"System.err.println java.lang.management.ManagementFactory.classLoadingMXBean.loadedClassCount\" &\n\ngroovy -e \"while (true) { new Socket('localhost',5000).outputStream << '\\n'}\"\n{code}\n\nAs a work-around, I used a ServerSocket instead of groovy -l."
    ],
    [
        "GROOVY-5843",
        "GROOVY-5798",
        "CompileStatic can't cast int to char This code\n\n{code}\n@groovy.transform.CompileStatic\ndef f() {\n  (65..90).collect { int it -> (char)it }\n}\n\nf()\n{code}\n\nThrows\n\n{code}\n[Static type checking] - Inconvertible types: cannot cast int to char\n{code}\n\nRemove the CompileStatic annotation, and it works again...",
        "CompileStatic cannot cast int to char {code}\n@groovy.transform.CompileStatic\nchar m( int v ) {\n  char c = (char)v\n  c\n}\n\nprintln m( 65 )\n{code}\n\nGives:\n\n{code}\n[Static type checking] - Inconvertible types: cannot cast int to char\n{code}\n\nRemoving CompileStatic or just doing:\n\n{code}\n@groovy.transform.CompileStatic\nchar m( int v ) {\n  v\n}\n\nprintln m( 65 )\n{code}\n\nWorks"
    ],
    [
        "GROOVY-5993",
        "GROOVY-5992",
        "Compiler fails on valid override of Object#finalize(), incorrectly reporting vsibility Compiling my project with Gradle, I get this:\n\n{code}\npaul@windowbox:~/ws/MetaWeb$ grb\nversionStamp=0.0.1-dev+svn363:402M\n:Dios:compileJava UP-TO-DATE\n:Dios:compileGroovy UP-TO-DATE\n:Dios:processResources UP-TO-DATE\n:Dios:classes UP-TO-DATE\n:Dios:jar UP-TO-DATE\n:MetaWeb:compileJava UP-TO-DATE\n:MetaWeb:compileGroovy\nstartup failed:\n/Users/paul/ws/MetaWeb/src/main/groovy/com/metaficient/web/gui/core/DynamicallyTypedBeanItem.groovy: 42: The method finalize should be public as it implements the corresponding method from interface java.lang.Object\n. At [42:2]  @ line 42, column 2.\n   \t@Override\n    ^\n\n/Users/paul/ws/MetaWeb/src/main/groovy/com/metaficient/web/gui/core/CollectionContainer.groovy: 82: The method finalize should be public as it implements the corresponding method from interface java.lang.Object\n. At [82:2]  @ line 82, column 2.\n   \t@Override\n    ^\n\n2 errors\n\n:MetaWeb:compileGroovy FAILED\n\nFAILURE: Build failed with an exception.\n\n* What went wrong:\nExecution failed for task ':MetaWeb:compileGroovy'.\n> Compilation failed; see the compiler error output for details.\n\n* Try:\nRun with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output.\n\nBUILD FAILED\n\nTotal time: 9.951 secs\n{code}\n\nThe build file is set to use Groovy 1.8.8.\n\nThe thing here is that the declaration of Object#finalize() is *\"protected\"*, not \"public\", as the compiler reports. My overrides are correct in that sense, so it would seem the compiler is mistaken.\n\nI have seen this before under GRECLIPSE, and filed a Jira for that (https://jira.codehaus.org/browse/GRECLIPSE-1430), but now this is happening outside of the IDE - so it would seem to be a Groovy compiler issue.\n\nAndrew Eisenberg has reported having a test case for this which I will add as soon as I can get it from him\n\nI have not tested with 2.x, as my codebase will not compile under that version.\n",
        "Compiler report finalize() override declaration as error Under indeterminate conditions, but often on:\n* Eclipse start-up\n* code edit\n* class creation,\n\nwith auto-build enabled, the compiler reports that an override of the protected method _finalize()_ on Object declared:\n\n{code}\n/* (non-Javadoc)\n * @see java.lang.Object#finalize()\n */\n@Override\nprotected void finalize() throws Throwable {\n        // Some behavior...\n\tsuper.finalize();\n}\n\n{code}\n\nis incorrectly declared, and should be declared public to match that declared on Object. That declaration (on Object) is declared as *protected*, not *public* (as implied by the error message), showing that the compiler is incorrect, not the code. Also, the error is reported on an unrelated script file in the project, not the location where it was found.\n\nI have tried to reproduce in a small project, to no success. The zip of this is attached, and reproduces the inheritance and implementation hierarchy of the original.\n\nThe error can be resolved my commenting out the overriding definition, cleaning and rebuilding. The error then goes away, and restoring the overriding definition (by e.g. restoring from a VC system) does *NOT* make the error re-appear.\n\n"
    ],
    [
        "GROOVY-6083",
        "GROOVY-3332",
        "TimeCategory days ago toString inconsistent I ran accross this issue when working with MongoDB on Grails.\nFor what reason is the output of the following lines different from each other?\n\nuse(groovy.time.TimeCategory) {\n    println 3.days.ago\n    println 3.days.ago + 0.seconds\n}\n\nI'd expect to get the same long string \"Tue Apr 02 00:00:00 UTC 2013\" but the first one yields \"2013-04-02\"\n\nThis leads to inconsistencies (e. g. for the first one, MongoDB doesn't understand it's a date)\n\nMy suspicion is that this is somehow related to a toString implementation based on cdate rather than fasttime. I might be wrong.\n\nYou can confirm this on http://groovyconsole.appspot.com/",
        "The groovy.time.*Duration classes make use of java.sql.Date The groovy.time.*Duration classes make use of java.sql.Date, but there seems to be no justification for doing so.\n\njava.sql.Date is basically the same as java.util.Date except for the toString() formatting. So the second assert fails while the first assert succeeds:\n\n{code}\nuse (org.codehaus.groovy.runtime.TimeCategory) {\n\n Date dt1 = 0.days.from.now\n Date dt2 = new Date(0.days.from.now.time)\n\n assert dt1 == dt2\n assert dt1.toString() == dt2.toString() \n}\n{code}"
    ],
    [
        "GROOVY-6290",
        "GROOVY-6214",
        "Problem With CompileStatic and getAt After instanceof List {code:title=Demo.groovy|borderStyle=solid}\n@groovy.transform.CompileStatic\nclass Demo {\n\n    def someMethod(arg) {\n        if(arg instanceof List) {\n            return arg[0]\n        }\n    }\n}\n{code}\n\n{noformat}\n\ncompileStatic $ \ncompileStatic $ groovyc Demo.groovy \norg.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed:\nDemo.groovy: 6: [Static type checking] - Cannot find matching method java.lang.Object#getAt(int). Please check if the declared type is right and if the method exists.\n @ line 6, column 20.\n               return arg[0]\n                      ^\n\n1 error\n\ncompileStatic $ \n{noformat}",
        "Problem With CompileStatic And instanceof I think this should compile but it does not.  \n\n{noformat}\n $ cat Demo.groovy \nimport groovy.transform.CompileStatic\n\n@CompileStatic\nclass Demo {\n\n    List convertToList(Object arg) {\n        List convertedList\n        \n        if(arg instanceof List) {\n            convertedList = arg\n        }\n\n        convertedList\n    }\n}\n $ \n $ groovy -version\nGroovy Version: 2.1.5 JVM: 1.6.0_45 Vendor: Apple Inc. OS: Mac OS X\n $ \n $ groovyc Demo.groovy \norg.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed:\nDemo.groovy: 10: [Static type checking] - Cannot assign value of type java.lang.Object to variable of type java.util.List\n @ line 10, column 29.\n               convertedList = arg\n                               ^\n\n1 error\n{noformat}\n\nIs this a bug?"
    ],
    [
        "GROOVY-6291",
        "GROOVY-6214",
        "Problem With CompileStatic And Assignment After instanceof Check {code:title=Demo.groovy|borderStyle=solid}\n@groovy.transform.CompileStatic\nclass Demo {\n\n    def someMethod(arg) {\n        if(arg instanceof List) {\n            List someList = arg\n        }\n    }\n}\n{code}\n\n{noformat}\ncompileStatic $ groovy -version\nGroovy Version: 2.1.6 JVM: 1.6.0_51 Vendor: Apple Inc. OS: Mac OS X\ncompileStatic $ \ncompileStatic $ groovyc Demo.groovy \norg.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed:\nDemo.groovy: 6: [Static type checking] - Cannot assign value of type java.lang.Object to variable of type java.util.List\n @ line 6, column 29.\n               List someList = arg\n                               ^\n\n1 error\n\ncompileStatic $ \n{noformat}",
        "Problem With CompileStatic And instanceof I think this should compile but it does not.  \n\n{noformat}\n $ cat Demo.groovy \nimport groovy.transform.CompileStatic\n\n@CompileStatic\nclass Demo {\n\n    List convertToList(Object arg) {\n        List convertedList\n        \n        if(arg instanceof List) {\n            convertedList = arg\n        }\n\n        convertedList\n    }\n}\n $ \n $ groovy -version\nGroovy Version: 2.1.5 JVM: 1.6.0_45 Vendor: Apple Inc. OS: Mac OS X\n $ \n $ groovyc Demo.groovy \norg.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed:\nDemo.groovy: 10: [Static type checking] - Cannot assign value of type java.lang.Object to variable of type java.util.List\n @ line 10, column 29.\n               convertedList = arg\n                               ^\n\n1 error\n{noformat}\n\nIs this a bug?"
    ],
    [
        "GROOVY-6291",
        "GROOVY-6290",
        "Problem With CompileStatic And Assignment After instanceof Check {code:title=Demo.groovy|borderStyle=solid}\n@groovy.transform.CompileStatic\nclass Demo {\n\n    def someMethod(arg) {\n        if(arg instanceof List) {\n            List someList = arg\n        }\n    }\n}\n{code}\n\n{noformat}\ncompileStatic $ groovy -version\nGroovy Version: 2.1.6 JVM: 1.6.0_51 Vendor: Apple Inc. OS: Mac OS X\ncompileStatic $ \ncompileStatic $ groovyc Demo.groovy \norg.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed:\nDemo.groovy: 6: [Static type checking] - Cannot assign value of type java.lang.Object to variable of type java.util.List\n @ line 6, column 29.\n               List someList = arg\n                               ^\n\n1 error\n\ncompileStatic $ \n{noformat}",
        "Problem With CompileStatic and getAt After instanceof List {code:title=Demo.groovy|borderStyle=solid}\n@groovy.transform.CompileStatic\nclass Demo {\n\n    def someMethod(arg) {\n        if(arg instanceof List) {\n            return arg[0]\n        }\n    }\n}\n{code}\n\n{noformat}\n\ncompileStatic $ \ncompileStatic $ groovyc Demo.groovy \norg.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed:\nDemo.groovy: 6: [Static type checking] - Cannot find matching method java.lang.Object#getAt(int). Please check if the declared type is right and if the method exists.\n @ line 6, column 20.\n               return arg[0]\n                      ^\n\n1 error\n\ncompileStatic $ \n{noformat}"
    ],
    [
        "GROOVY-6308",
        "GROOVY-4102",
        "Timestamps in bytecode prevents baselining of code The Groovy compiler generates timestamps in the byte code such as:\n// Field __timeStamp__239_neverHappen1376222554342:J\n\nBecause of this, every build will produce different class files. \n\nWe are moving towards baselining of jars using bnd (https://github.com/bndtools/bnd/wiki/Baselining-%5Bbeta%5D). Baselining helps versioning exported packages and bundles (jar files) correctly using the semantic versioning scheme. When class files change between builds the baseline diff will always notice a change, even when the code was actually not changed.\n\nBesides the baselining issue I think builds should produce the exact same byte code on successive runs when there are no changes.\n\nThis issue is related to GROOVY-4102.",
        "remove timestamp fields for better hotswap While debugging I try to hot swap a groovy class.\nIt always fails with messages \"Schema change not implemented. Operation not supported by VM\".\n\nWith Java classes there is no such problem - hot swap works as long as I don't add/remove any field or method or change a method signature.\n\nI had hoped to gradually convert my Java app to groovy, but this made me refrain from using groovy for anything more complex than \"java\" beans.\n\nLooking at the bytecode with javap, it is obvious where the problem is:\nThere is an artifical  field that changes its name on each compilation.\nInitial:\n   public static java.lang.Long __timeStamp__239_neverHappen1268432715287;\nAfter recompilation:\n   public static java.lang.Long __timeStamp__239_neverHappen1268433121889;\n\nWhat is this field used for? Can't we get rid of it?\nAll other fields/methods look the same after recompilation, so I am pretty sure that hot swap will work without this field change.\n"
    ],
    [
        "GROOVY-6308",
        "GROOVY-5390",
        "Timestamps in bytecode prevents baselining of code The Groovy compiler generates timestamps in the byte code such as:\n// Field __timeStamp__239_neverHappen1376222554342:J\n\nBecause of this, every build will produce different class files. \n\nWe are moving towards baselining of jars using bnd (https://github.com/bndtools/bnd/wiki/Baselining-%5Bbeta%5D). Baselining helps versioning exported packages and bundles (jar files) correctly using the semantic versioning scheme. When class files change between builds the baseline diff will always notice a change, even when the code was actually not changed.\n\nBesides the baselining issue I think builds should produce the exact same byte code on successive runs when there are no changes.\n\nThis issue is related to GROOVY-4102.",
        "groovyc class generation kind of break default serialVersionUID generation by the jvm When using groovyc ant task for compiling groovy classes, the class generation visitor pattern creates a non transient static field with a variable name (timestamp) for each visited class. \n\n(cf org.codehaus.groovy.classgen.Verifier.addTimeStamp(ClassNode node) method which adds a field whose name is : \"__timeStamp__239_neverHappen\" + String.valueOf(System.currentTimeMillis())\n\n\nIf the class has no specified serialVersionUID, the jvm will compute one during the first serialisation/deserialization. Because of this field, this computed serialVersionUID will change after each compilation, even if the class has no change whatsoever.\n\n\nA workaround is of course to add a serialVersionUID to the groovy object, but this is kind of an annoyance, because default generation just works perfectly for cases in which you use serialization for things such as cache and session management, and you don't have to enforce a process in which each developer has to manually manage that serialVersionUID manually every time the class change.\n\nI have the feeling that this annoyance could be avoided, if the synthetic field added by the Verifier was set as transient, and I think it would not defeat the purpose of this field (I may of course be wrong on either of those subject...)"
    ],
    [
        "GROOVY-6385",
        "GROOVY-5347",
        "groovy.bat: Can't use question mark in script parameters see [http://groovy.329449.n5.nabble.com/Can-t-use-question-mark-in-script-parameters-td5716658.html] for details",
        "Syntax error when using question mark in the command line argument In version 1.8.5, I was able to do this on command line:\n\ngroovy xyz.groovy jdbc:sybase:Tds:host:port/mydb?charset=iso_1\n\nBut in version 1.8.6, I will get:\n\nThe syntax of the command is incorrect because of the '?'."
    ],
    [
        "GROOVY-6418",
        "GROOVY-6417",
        "Method calls are 2-3 times slower with \"indy\" option enabled When \"indy\" parameter is specified for compiler, resulted compiled script is 2-3 times slower than the one without \"indy\". For example, consider this snippet:\n{code:java}\nclass Test1 {\n    def random = new Random()\n    def sum = 0;\n\n    def stub(String s) {\n        sum += random.nextInt()\n    }\n    def methodMissing(String name, args) {\n        stub(\"stub\")\n    }\n}\n\ndef count = 100000\nfor (z in 1..10) {\n    def t = new Test1()\n    def time = 0\n    for (i in 1..count) {\n        def cur = System.nanoTime()\n        t.someMethod()\n        time += System.nanoTime() - cur\n    }\n    printf('missing: %d total, %.2f avg      %d\\n', time, time / count, t.sum)\n}\n{code}\nI removed \"invokeMethod\" and direct method calls for simplicity, but they have the same impact on performance. However there is full version in attachment.\nAlso in a debugger I can see that \"indy\"ed version has much bigger call stack compared to normal version:\n\t  at actors.Test2.methodMissing(player.groovy:30)\n\t  at sun.reflect.NativeMethodAccessorImpl.invoke0(NativeMethodAccessorImpl.java:-1)\n\t  at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)\n\t  at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\t  at java.lang.reflect.Method.invoke(Method.java:606)\n\t  at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:90)\n\t  at groovy.lang.MetaClassImpl.invokeMissingMethod(MetaClassImpl.java:837)\n\t  at groovy.lang.MetaClassImpl.invokePropertyOrMissing(MetaClassImpl.java:1134)\n\t  at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:1087)\n\t  at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:909)\n\t  at java.lang.invoke.LambdaForm$DMH.invokeSpecial_LLLL_L(LambdaForm$DMH:-1)\n\t  at java.lang.invoke.LambdaForm$DMH.invokeSpecial_LLLLL_L(LambdaForm$DMH:-1)\n\t  at java.lang.invoke.LambdaForm$NamedFunction.invoke_LLLLL_L(LambdaForm.java:1112)\n\t  at java.lang.invoke.LambdaForm$DMH.invokeStatic_LL_L(LambdaForm$DMH:-1)\n\t  at java.lang.invoke.LambdaForm$NamedFunction.invokeWithArguments(LambdaForm.java:1136)\n\t  at java.lang.invoke.LambdaForm.interpretName(LambdaForm.java:625)\n\t  at java.lang.invoke.LambdaForm.interpretWithArguments(LambdaForm.java:604)\n\t  at java.lang.invoke.LambdaForm$LFI.interpret_L(LambdaForm$LFI:-1)\n\t  at java.lang.invoke.LambdaForm$NamedFunction.invoke_LLL_L(LambdaForm.java:1102)\n\t  at java.lang.invoke.LambdaForm$DMH.invokeStatic_LL_L(LambdaForm$DMH:-1)\n\t  at java.lang.invoke.LambdaForm$NamedFunction.invokeWithArguments(LambdaForm.java:1136)\n\t  at java.lang.invoke.LambdaForm.interpretName(LambdaForm.java:625)\n\t  at java.lang.invoke.LambdaForm.interpretWithArguments(LambdaForm.java:604)\n\t  at java.lang.invoke.LambdaForm$LFI.interpret_L(LambdaForm$LFI:-1)\n\t  at java.lang.invoke.LambdaForm$MH.invokeExact_MT(LambdaForm$MH:-1)\n\t  at java.lang.invoke.MethodHandleImpl$GuardWithCatch.invoke_L3(MethodHandleImpl.java:639)\n\t  at java.lang.invoke.LambdaForm$DMH.invokeSpecial_LLLL_L(LambdaForm$DMH:-1)\n\t  at java.lang.invoke.LambdaForm$DMH.invokeSpecial_LLLLL_L(LambdaForm$DMH:-1)\n\t  at java.lang.invoke.LambdaForm$NamedFunction.invoke_LLLLL_L(LambdaForm.java:1112)\n\t  at java.lang.invoke.LambdaForm$DMH.invokeStatic_LL_L(LambdaForm$DMH:-1)\n\t  at java.lang.invoke.LambdaForm$NamedFunction.invokeWithArguments(LambdaForm.java:1136)\n\t  at java.lang.invoke.LambdaForm.interpretName(LambdaForm.java:625)\n\t  at java.lang.invoke.LambdaForm.interpretWithArguments(LambdaForm.java:604)\n\t  at java.lang.invoke.LambdaForm$LFI.interpret_L(LambdaForm$LFI:-1)\n\t  at java.lang.invoke.LambdaForm$NamedFunction.invoke_LLL_L(LambdaForm.java:1102)\n\t  at java.lang.invoke.LambdaForm$DMH.invokeStatic_LL_L(LambdaForm$DMH:-1)\n\t  at java.lang.invoke.LambdaForm$NamedFunction.invokeWithArguments(LambdaForm.java:1136)\n\t  at java.lang.invoke.LambdaForm.interpretName(LambdaForm.java:625)\n\t  at java.lang.invoke.LambdaForm.interpretWithArguments(LambdaForm.java:604)\n\t  at java.lang.invoke.LambdaForm$LFI.interpret_L(LambdaForm$LFI:-1)\n\t  at java.lang.invoke.LambdaForm$NamedFunction.invoke_LL_L(LambdaForm.java:1097)\n\t  at java.lang.invoke.LambdaForm$DMH.invokeStatic_LL_L(LambdaForm$DMH:-1)\n\t  at java.lang.invoke.LambdaForm$NamedFunction.invokeWithArguments(LambdaForm.java:1136)\n\t  at java.lang.invoke.LambdaForm.interpretName(LambdaForm.java:625)\n\t  at java.lang.invoke.LambdaForm.interpretWithArguments(LambdaForm.java:604)\n\t  at java.lang.invoke.LambdaForm$LFI.interpret_L(LambdaForm$LFI:-1)\n\t  at java.lang.invoke.LambdaForm$MH.invokeExact_MT(LambdaForm$MH:-1)\n\t  at java.lang.invoke.MethodHandleImpl$GuardWithCatch.invoke_L1(MethodHandleImpl.java:621)\n\t  at java.lang.invoke.LambdaForm$DMH.invokeSpecial_LL_L(LambdaForm$DMH:-1)\n\t  at java.lang.invoke.LambdaForm$BMH.reinvoke(LambdaForm$BMH:-1)\n\t  at java.lang.invoke.LambdaForm$DMH.invokeSpecial_LL_L(LambdaForm$DMH:-1)\n\t  at java.lang.invoke.LambdaForm$NamedFunction.invoke_LL_L(LambdaForm.java:1097)\n\t  at java.lang.invoke.LambdaForm$DMH.invokeStatic_LL_L(LambdaForm$DMH:-1)\n\t  at java.lang.invoke.LambdaForm$NamedFunction.invokeWithArguments(LambdaForm.java:1136)\n\t  at java.lang.invoke.LambdaForm.interpretName(LambdaForm.java:625)\n\t  at java.lang.invoke.LambdaForm.interpretWithArguments(LambdaForm.java:604)\n\t  at java.lang.invoke.LambdaForm$LFI.interpret_L(LambdaForm$LFI:-1)\n\t  at java.lang.invoke.LambdaForm$DMH.invokeSpecial_LL_L(LambdaForm$DMH:-1)\n\t  at java.lang.invoke.LambdaForm$NamedFunction.invoke_LL_L(LambdaForm.java:1097)\n\t  at java.lang.invoke.LambdaForm$DMH.invokeStatic_LL_L(LambdaForm$DMH:-1)\n\t  at java.lang.invoke.LambdaForm$NamedFunction.invokeWithArguments(LambdaForm.java:1136)\n\t  at java.lang.invoke.LambdaForm.interpretName(LambdaForm.java:625)\n\t  at java.lang.invoke.LambdaForm.interpretWithArguments(LambdaForm.java:604)\n\t  at java.lang.invoke.LambdaForm$LFI.interpret_L(LambdaForm$LFI:-1)\n\t  at java.lang.invoke.LambdaForm$DMH.invokeSpecial_LL_L(LambdaForm$DMH:-1)\n\t  at java.lang.invoke.LambdaForm$NamedFunction.invoke_LL_L(LambdaForm.java:1097)\n\t  at java.lang.invoke.LambdaForm$DMH.invokeStatic_LL_L(LambdaForm$DMH:-1)\n\t  at java.lang.invoke.LambdaForm$NamedFunction.invokeWithArguments(LambdaForm.java:1136)\n\t  at java.lang.invoke.LambdaForm.interpretName(LambdaForm.java:625)\n\t  at java.lang.invoke.LambdaForm.interpretWithArguments(LambdaForm.java:604)\n\t  at java.lang.invoke.LambdaForm$LFI.interpret_L(LambdaForm$LFI:-1)\n\t  at java.lang.invoke.LambdaForm$NamedFunction.invoke_L_L(LambdaForm.java:1092)\n\t  at java.lang.invoke.LambdaForm$DMH.invokeStatic_LL_L(LambdaForm$DMH:-1)\n\t  at java.lang.invoke.LambdaForm$NamedFunction.invokeWithArguments(LambdaForm.java:1136)\n\t  at java.lang.invoke.LambdaForm.interpretName(LambdaForm.java:625)\n\t  at java.lang.invoke.LambdaForm.interpretWithArguments(LambdaForm.java:604)\n\t  at java.lang.invoke.LambdaForm$LFI.interpret_L(LambdaForm$LFI:-1)\n\t  at java.lang.invoke.LambdaForm$MH.invokeExact_MT(LambdaForm$MH:-1)\n\t  at org.codehaus.groovy.vmplugin.v7.IndyInterface.selectMethod(IndyInterface.java:212)\n\t  at java.lang.invoke.LambdaForm$DMH.invokeStatic_LLLILLLLL_L(LambdaForm$DMH:-1)\n\t  at java.lang.invoke.LambdaForm$DMH.invokeSpecial_LLLLILLLLL_L(LambdaForm$DMH:-1)\n\t  at java.lang.invoke.LambdaForm$NFI.invoke_LLLLILLLLL_L(LambdaForm$NFI:-1)\n\t  at java.lang.invoke.LambdaForm$DMH.invokeStatic_LL_L(LambdaForm$DMH:-1)\n\t  at java.lang.invoke.LambdaForm$NamedFunction.invokeWithArguments(LambdaForm.java:1136)\n\t  at java.lang.invoke.LambdaForm.interpretName(LambdaForm.java:625)\n\t  at java.lang.invoke.LambdaForm.interpretWithArguments(LambdaForm.java:604)\n\t  at java.lang.invoke.LambdaForm$LFI.interpret_L(LambdaForm$LFI:-1)\n\t  at java.lang.invoke.LambdaForm$NamedFunction.invoke_L_L(LambdaForm.java:1092)\n\t  at java.lang.invoke.LambdaForm$DMH.invokeStatic_LL_L(LambdaForm$DMH:-1)\n\t  at java.lang.invoke.LambdaForm$NamedFunction.invokeWithArguments(LambdaForm.java:1136)\n\t  at java.lang.invoke.LambdaForm.interpretName(LambdaForm.java:625)\n\t  at java.lang.invoke.LambdaForm.interpretWithArguments(LambdaForm.java:604)\n\t  at java.lang.invoke.LambdaForm$LFI.interpret_L(LambdaForm$LFI:-1)\n\t  at java.lang.invoke.LambdaForm$MH.linkToCallSite(LambdaForm$MH:-1)\n\n\ncompared to just about 10 lines in non-indy version.\n\nJava code used for runnnig script:\n{code:java}\nGroovyScriptEngine engine = new GroovyScriptEngine(\"scripts\");\nBinding binding = new Binding();\nMap<String, Boolean> options = engine.getConfig().getOptimizationOptions();\noptions.put(\"indy\", Boolean.TRUE);\nObject result = engine.run(\"actors/player.groovy\", binding);\n{code}",
        "Method invocation is 2-3 times slower with indy When \"indy\" parameter is specified for compiler, resulted compiled script is 2-3 times slower than the one without \"indy\". For example, consider this snippet:\n{code:java}\nclass Test1 {\n    def random = new Random()\n    def sum = 0;\n\n    def stub(String s) {\n        sum += random.nextInt()\n    }\n    def methodMissing(String name, args) {\n        stub(\"stub\")\n    }\n}\n\ndef count = 100000\nfor (z in 1..10) {\n    def t = new Test1()\n    def time = 0\n    for (i in 1..count) {\n        def cur = System.nanoTime()\n        t.someMethod()\n        time += System.nanoTime() - cur\n    }\n    printf('missing: %d total, %.2f avg      %d\\n', time, time / count, t.sum)\n}\n{code}\nI removed \"invokeMethod\" and direct method calls for simplicity, but they have the same impact on performance. However there is full version in attachment.\nAlso in a debugger I can see that \"indy\"ed version has much bigger call stack compared to normal version:\n\t  at actors.Test2.methodMissing(player.groovy:30)\n\t  at sun.reflect.NativeMethodAccessorImpl.invoke0(NativeMethodAccessorImpl.java:-1)\n\t  at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)\n\t  at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\t  at java.lang.reflect.Method.invoke(Method.java:606)\n\t  at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:90)\n\t  at groovy.lang.MetaClassImpl.invokeMissingMethod(MetaClassImpl.java:837)\n\t  at groovy.lang.MetaClassImpl.invokePropertyOrMissing(MetaClassImpl.java:1134)\n\t  at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:1087)\n\t  at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:909)\n\t  at java.lang.invoke.LambdaForm$DMH.invokeSpecial_LLLL_L(LambdaForm$DMH:-1)\n\t  at java.lang.invoke.LambdaForm$DMH.invokeSpecial_LLLLL_L(LambdaForm$DMH:-1)\n\t  at java.lang.invoke.LambdaForm$NamedFunction.invoke_LLLLL_L(LambdaForm.java:1112)\n\t  at java.lang.invoke.LambdaForm$DMH.invokeStatic_LL_L(LambdaForm$DMH:-1)\n\t  at java.lang.invoke.LambdaForm$NamedFunction.invokeWithArguments(LambdaForm.java:1136)\n\t  at java.lang.invoke.LambdaForm.interpretName(LambdaForm.java:625)\n\t  at java.lang.invoke.LambdaForm.interpretWithArguments(LambdaForm.java:604)\n\t  at java.lang.invoke.LambdaForm$LFI.interpret_L(LambdaForm$LFI:-1)\n\t  at java.lang.invoke.LambdaForm$NamedFunction.invoke_LLL_L(LambdaForm.java:1102)\n\t  at java.lang.invoke.LambdaForm$DMH.invokeStatic_LL_L(LambdaForm$DMH:-1)\n\t  at java.lang.invoke.LambdaForm$NamedFunction.invokeWithArguments(LambdaForm.java:1136)\n\t  at java.lang.invoke.LambdaForm.interpretName(LambdaForm.java:625)\n\t  at java.lang.invoke.LambdaForm.interpretWithArguments(LambdaForm.java:604)\n\t  at java.lang.invoke.LambdaForm$LFI.interpret_L(LambdaForm$LFI:-1)\n\t  at java.lang.invoke.LambdaForm$MH.invokeExact_MT(LambdaForm$MH:-1)\n\t  at java.lang.invoke.MethodHandleImpl$GuardWithCatch.invoke_L3(MethodHandleImpl.java:639)\n\t  at java.lang.invoke.LambdaForm$DMH.invokeSpecial_LLLL_L(LambdaForm$DMH:-1)\n\t  at java.lang.invoke.LambdaForm$DMH.invokeSpecial_LLLLL_L(LambdaForm$DMH:-1)\n\t  at java.lang.invoke.LambdaForm$NamedFunction.invoke_LLLLL_L(LambdaForm.java:1112)\n\t  at java.lang.invoke.LambdaForm$DMH.invokeStatic_LL_L(LambdaForm$DMH:-1)\n\t  at java.lang.invoke.LambdaForm$NamedFunction.invokeWithArguments(LambdaForm.java:1136)\n\t  at java.lang.invoke.LambdaForm.interpretName(LambdaForm.java:625)\n\t  at java.lang.invoke.LambdaForm.interpretWithArguments(LambdaForm.java:604)\n\t  at java.lang.invoke.LambdaForm$LFI.interpret_L(LambdaForm$LFI:-1)\n\t  at java.lang.invoke.LambdaForm$NamedFunction.invoke_LLL_L(LambdaForm.java:1102)\n\t  at java.lang.invoke.LambdaForm$DMH.invokeStatic_LL_L(LambdaForm$DMH:-1)\n\t  at java.lang.invoke.LambdaForm$NamedFunction.invokeWithArguments(LambdaForm.java:1136)\n\t  at java.lang.invoke.LambdaForm.interpretName(LambdaForm.java:625)\n\t  at java.lang.invoke.LambdaForm.interpretWithArguments(LambdaForm.java:604)\n\t  at java.lang.invoke.LambdaForm$LFI.interpret_L(LambdaForm$LFI:-1)\n\t  at java.lang.invoke.LambdaForm$NamedFunction.invoke_LL_L(LambdaForm.java:1097)\n\t  at java.lang.invoke.LambdaForm$DMH.invokeStatic_LL_L(LambdaForm$DMH:-1)\n\t  at java.lang.invoke.LambdaForm$NamedFunction.invokeWithArguments(LambdaForm.java:1136)\n\t  at java.lang.invoke.LambdaForm.interpretName(LambdaForm.java:625)\n\t  at java.lang.invoke.LambdaForm.interpretWithArguments(LambdaForm.java:604)\n\t  at java.lang.invoke.LambdaForm$LFI.interpret_L(LambdaForm$LFI:-1)\n\t  at java.lang.invoke.LambdaForm$MH.invokeExact_MT(LambdaForm$MH:-1)\n\t  at java.lang.invoke.MethodHandleImpl$GuardWithCatch.invoke_L1(MethodHandleImpl.java:621)\n\t  at java.lang.invoke.LambdaForm$DMH.invokeSpecial_LL_L(LambdaForm$DMH:-1)\n\t  at java.lang.invoke.LambdaForm$BMH.reinvoke(LambdaForm$BMH:-1)\n\t  at java.lang.invoke.LambdaForm$DMH.invokeSpecial_LL_L(LambdaForm$DMH:-1)\n\t  at java.lang.invoke.LambdaForm$NamedFunction.invoke_LL_L(LambdaForm.java:1097)\n\t  at java.lang.invoke.LambdaForm$DMH.invokeStatic_LL_L(LambdaForm$DMH:-1)\n\t  at java.lang.invoke.LambdaForm$NamedFunction.invokeWithArguments(LambdaForm.java:1136)\n\t  at java.lang.invoke.LambdaForm.interpretName(LambdaForm.java:625)\n\t  at java.lang.invoke.LambdaForm.interpretWithArguments(LambdaForm.java:604)\n\t  at java.lang.invoke.LambdaForm$LFI.interpret_L(LambdaForm$LFI:-1)\n\t  at java.lang.invoke.LambdaForm$DMH.invokeSpecial_LL_L(LambdaForm$DMH:-1)\n\t  at java.lang.invoke.LambdaForm$NamedFunction.invoke_LL_L(LambdaForm.java:1097)\n\t  at java.lang.invoke.LambdaForm$DMH.invokeStatic_LL_L(LambdaForm$DMH:-1)\n\t  at java.lang.invoke.LambdaForm$NamedFunction.invokeWithArguments(LambdaForm.java:1136)\n\t  at java.lang.invoke.LambdaForm.interpretName(LambdaForm.java:625)\n\t  at java.lang.invoke.LambdaForm.interpretWithArguments(LambdaForm.java:604)\n\t  at java.lang.invoke.LambdaForm$LFI.interpret_L(LambdaForm$LFI:-1)\n\t  at java.lang.invoke.LambdaForm$DMH.invokeSpecial_LL_L(LambdaForm$DMH:-1)\n\t  at java.lang.invoke.LambdaForm$NamedFunction.invoke_LL_L(LambdaForm.java:1097)\n\t  at java.lang.invoke.LambdaForm$DMH.invokeStatic_LL_L(LambdaForm$DMH:-1)\n\t  at java.lang.invoke.LambdaForm$NamedFunction.invokeWithArguments(LambdaForm.java:1136)\n\t  at java.lang.invoke.LambdaForm.interpretName(LambdaForm.java:625)\n\t  at java.lang.invoke.LambdaForm.interpretWithArguments(LambdaForm.java:604)\n\t  at java.lang.invoke.LambdaForm$LFI.interpret_L(LambdaForm$LFI:-1)\n\t  at java.lang.invoke.LambdaForm$NamedFunction.invoke_L_L(LambdaForm.java:1092)\n\t  at java.lang.invoke.LambdaForm$DMH.invokeStatic_LL_L(LambdaForm$DMH:-1)\n\t  at java.lang.invoke.LambdaForm$NamedFunction.invokeWithArguments(LambdaForm.java:1136)\n\t  at java.lang.invoke.LambdaForm.interpretName(LambdaForm.java:625)\n\t  at java.lang.invoke.LambdaForm.interpretWithArguments(LambdaForm.java:604)\n\t  at java.lang.invoke.LambdaForm$LFI.interpret_L(LambdaForm$LFI:-1)\n\t  at java.lang.invoke.LambdaForm$MH.invokeExact_MT(LambdaForm$MH:-1)\n\t  at org.codehaus.groovy.vmplugin.v7.IndyInterface.selectMethod(IndyInterface.java:212)\n\t  at java.lang.invoke.LambdaForm$DMH.invokeStatic_LLLILLLLL_L(LambdaForm$DMH:-1)\n\t  at java.lang.invoke.LambdaForm$DMH.invokeSpecial_LLLLILLLLL_L(LambdaForm$DMH:-1)\n\t  at java.lang.invoke.LambdaForm$NFI.invoke_LLLLILLLLL_L(LambdaForm$NFI:-1)\n\t  at java.lang.invoke.LambdaForm$DMH.invokeStatic_LL_L(LambdaForm$DMH:-1)\n\t  at java.lang.invoke.LambdaForm$NamedFunction.invokeWithArguments(LambdaForm.java:1136)\n\t  at java.lang.invoke.LambdaForm.interpretName(LambdaForm.java:625)\n\t  at java.lang.invoke.LambdaForm.interpretWithArguments(LambdaForm.java:604)\n\t  at java.lang.invoke.LambdaForm$LFI.interpret_L(LambdaForm$LFI:-1)\n\t  at java.lang.invoke.LambdaForm$NamedFunction.invoke_L_L(LambdaForm.java:1092)\n\t  at java.lang.invoke.LambdaForm$DMH.invokeStatic_LL_L(LambdaForm$DMH:-1)\n\t  at java.lang.invoke.LambdaForm$NamedFunction.invokeWithArguments(LambdaForm.java:1136)\n\t  at java.lang.invoke.LambdaForm.interpretName(LambdaForm.java:625)\n\t  at java.lang.invoke.LambdaForm.interpretWithArguments(LambdaForm.java:604)\n\t  at java.lang.invoke.LambdaForm$LFI.interpret_L(LambdaForm$LFI:-1)\n\t  at java.lang.invoke.LambdaForm$MH.linkToCallSite(LambdaForm$MH:-1)\n\n\ncompared to just about 10 lines in non-indy version.\n\nJava code used for runnnig script:\n{code:java}\nGroovyScriptEngine engine = new GroovyScriptEngine(\"scripts\");\nBinding binding = new Binding();\nMap<String, Boolean> options = engine.getConfig().getOptimizationOptions();\noptions.put(\"indy\", Boolean.TRUE);\nObject result = engine.run(\"actors/player.groovy\", binding);\n{code}"
    ],
    [
        "GROOVY-6439",
        "GROOVY-5345",
        "Incorrect output of power assert when using spread operator + unique() The output of power assert is incorrect when using the spread operator in combination with {{unique()}}:\n\n*incorrect output*\n{noformat}\nassert [[a:1], [a:1]]*.a.unique() == [0]\n                       | |        |\n                       | [1]      false\n                       [1]\n{noformat}\n\n*expected output*\n{noformat}\nassert [[a:1], [a:1]]*.a.unique() == [0]\n                       | |        |\n                       | [1]      false\n                       [1, 1]\n{noformat}\n\nThe output is correct when using a method other than {{unique()}} or no method at all.\n(NOTE: I have tried many but not all possible methods.)\n\n{noformat}\nassert [[a:1], [a:1]]*.a == [0]\n                       | |\n                       | false\n                       [1, 1]\n\nassert [[a:1], [a:1]]*.a.size() == 0\n                       | |      |\n                       | 2      false\n                       [1, 1]\n{noformat}",
        "Power assert with unique() gives confusing output Here's a code with a wrong assertion:\n{code}\ndef x = [1, 1, 1]\nassert x.unique() == [2]\n{code}\n\nAnd here's the output I get:\n{noformat}\nwheleph@laptop:~/groovy$ groovy power_assert.groovy \nCaught: Assertion failed: \n\nassert x.unique() == [2]\n       | |        |\n       | [1]      false\n       [1]\n\nAssertion failed: \n\nassert x.unique() == [2]\n       | |        |\n       | [1]      false\n       [1]\n\n\tat power_assert.run(power_assert.groovy:2)\n{noformat}\n\nWhile it does state that the assertion failed, the output is confusing because {{x}} was {{[1, 1, 1]}} at the start of {{x.unique()}}. I guess this behavior is caused by the fact that {{unique()}} changes the list itself rather than returns a new instance."
    ],
    [
        "GROOVY-6516",
        "GROOVY-6472",
        "Documentation bug: http://groovy.codehaus.org/JN1035-Maps At http://groovy.codehaus.org/JN1035-Maps\n\nwe read: \n\n\"We can also use the '+' and '<<' operators to add elements to the map. Note that '<<' produces a new map while '+' modifies the map:\"\n\n\nThis should be \n\n\"We can also use the '+' and '<<' operators to add elements to the map. Note that '+=' produces a new map while '<<' modifies the map:\"\n\nas the program in the documentation (which is correct) illustrates:\n\ndef map4a = [:]\ndef map5a = map4a\nassert map5a.is(map4a)\nmap4a << ['b':'b value'] // the map reference by map4a & map5a is extended\nassert map5a.is(map4a)\nmap4a+= ['a':'a value'] // map4a is not the original map4a anymore\nassert !map5a.is(map4a)\nassert map4a == [b:'b value', a:'a value']\nassert map5a == [b:'b value']\n",
        "Documentation related to adding entries to maps appears incorrect in wiki See page http://groovy.codehaus.org/JN1035-Maps\n\nIt reads \n\nWe can also use the '+' and '<<' operators to add elements to the map. *Note that '<<' produces a new map while '+' modifies the map:*\n\ndef map4a = [:]\ndef map5a = map4a\nassert map5a.is(map4a)\nmap4a << ['b':'b value']\nassert map5a.is(map4a)\nmap4a+= ['a':'a value'] // map4a is not the original map4a anymore\nassert !map5a.is(map4a)\nassert map4a == [b:'b value', a:'a value']\nassert map5a == [b:'b value']\n\nIt should be --> \n\nWe can also use the '+' and '<<' operators to add elements to the map. *Note that '++' produces a new map while '<<' modifies the map:*\n\n\n\n"
    ],
    [
        "GROOVY-6705",
        "GROOVY-5952",
        "Compiler Doesn't Enforce Required Annotation Attributes I don't know if this is the same as GROOVY-3454 or not.  That issue is marked resolved but I am seeing the problem with 2.1.9.\n\nCode from the attached app...\n\n\n{code:title=src/main/java/com/demo/MyAnnotation.java|borderStyle=solid}\npackage com.demo;\n\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.FIELD)\npublic @interface MyAnnotation {\n    String value();\n    String code() default \"\";\n}\n{code}\n\n{code:title=src/test/groovy/com/demo/MyAnnotationSpec.groovy|borderStyle=solid}\npackage com.demo\n\nclass MyAnnotationSpec extends spock.lang.Specification {\n\n    void 'test code'() {\n        expect:\n        Widget.getDeclaredField('name').getAnnotation(MyAnnotation).code() == 'alpha'\n    }\n}\n\nclass Widget {\n    @MyAnnotation(code='alpha')\n    String name\n}\n{code}\n\nThat test compiles and passes.  I expected the compiler to fail on the Widget class since the annotation does not provide a value for the \"value\" attribute.\n\nAm I overlooking something simple or is this broken?",
        "Groovyc doesn't check annotations for missing attributes if variable is annotated Groovyc should fail on '@X' annotation because attribute 'foo' is missed\n{code}\n@interface X {\n    int foo()\n}\n\n@X  //I expect an error here \nint g = 5\n\nprint g\n\n{code}\n\n\nif I declare a type definition with @X Groovyc fails:\n\n{code}\n@interface X {\n    int foo()\n}\n\n@X  //An error is here\nclass Bar {}\n{code}\n\n"
    ],
    [
        "GROOVY-6829",
        "GROOVY-6815",
        "Groovy implementationVersion == 2.3.1.SNAPSHOT Class.forName(\"groovy.lang.GroovyObject\").package.implementationVersion) is 2.3.1.SNAPSHOT\n\nThe version given by\n\nhttp://repo1.maven.org/maven2/org/codehaus/groovy/groovy-all/maven-metadata.xml\n\nis 2.3.1.\n\nOur QA tests currently assume reasonable version numbers (e.g. 2.3.1) that match the version in the Maven repository and therefore fail.\n\nIs there an official versioning scheme for Groovy?",
        "IntelliJ sees proper 2.3.1 release as 'groovy-2.3.1.SNAPSHOT' Just downloaded a fresh copy of 2.3.1 \"Combined binary / source / documentation bundle: Distribution bundle\"\n\nIn intelliJ, when I make a new project, I make a new Groovy library pointed at this fresh download\n\nAs attached image shows, IntelliJ displays the library name as 'groovy-2.3.1.SNAPSHOT.'\n\nTaking a look inside groovy-2.3.1.jar/META-INF/groovy-release-info.properties, I see:\n\n{code}\nImplementationVersion=2.3.1\nBundleVersion=2.3.1.SNAPSHOT\nBuildDate=19-May-2014\nBuildTime=02:50 PM\n{code}\n\nI ASSUME (rightly or wrongly) that this is where IntelliJ is getting it's version info from?\n\nIn any case, something doesn't seem quite correct."
    ],
    [
        "GROOVY-6959",
        "GROOVY-6951",
        "java.lang.VerifyError: Bad <init> method call from inside of a branch This error appears to not be Groovy specific as I was able to reproduce it with Groovy 2.2.1 up to 2.3.4 when JDK7u65 was in use. There's no error with JDK7u60.\n\nStacktrace\n\n{code}\njava.lang.VerifyError: Bad <init> method call from inside of a branch\nException Details:\n  Location:\n    org/opendolphin/server/adapter/MockPrintWriter.<init>()V @126: invokespecial\n  Reason:\n    Error exists in the bytecode\n  Bytecode:\n    0000000: b800 184c 04bd 001a 5903 121c 5359 10ff\n    0000010: 1204 b800 222a 5fab 0000 0138 0000 0009\n    0000020: 8355 379f 0000 0051 aad3 b1ff 0000 006d\n    0000030: d9ca eaf6 0000 0080 daf2 35d5 0000 009f\n    0000040: e925 fa09 0000 00b4 0a30 63a7 0000 00d1\n    0000050: 1030 b9ba 0000 00e6 3bdc c40d 0000 0107\n    0000060: 4ad1 f42c 0000 0123 5f5a 5903 3212 24b8\n    0000070: 0028 c000 245f 5904 32b8 002e 5f57 b700\n    0000080: 31a7 00d8 5f5a 5903 32b8 0037 c000 395f\n    0000090: 57b7 003c a700 c55f 5a59 0332 123e b800\n    00000a0: 28c0 003e 5f59 0432 b800 37c0 0039 5f57\n    00000b0: b700 41a7 00a6 5f5a 5903 3212 24b8 0028\n    00000c0: c000 245f 57b7 0044 a700 915f 5a59 0332\n    00000d0: b800 37c0 0039 5f59 0432 b800 37c0 0039\n    00000e0: 5f57 b700 47a7 0074 5f5a 5903 3212 49b8\n    00000f0: 0028 c000 495f 57b7 004c a700 5f5f 5a59\n    0000100: 0332 124e b800 28c0 004e 5f59 0432 123e\n    0000110: b800 28c0 003e 5f57 b700 51a7 003e 5f5a\n    0000120: 5903 3212 49b8 0028 c000 495f 5904 32b8\n    0000130: 002e 5f57 b700 54a7 0022 5f5a 5903 3212\n    0000140: 3eb8 0028 c000 3e5f 57b7 0057 a700 0dbb\n    0000150: 0059 5912 5bb7 005c bf57 2ab6 0060 4d2c\n    0000160: 2a5f b500 622c 57b1                    \n  Stackmap Table:\n    full_frame(@104,{UninitializedThis,Object[#102]},{Object[#104],UninitializedThis})\n    full_frame(@132,{UninitializedThis,Object[#102]},{Object[#104],UninitializedThis})\n    full_frame(@151,{UninitializedThis,Object[#102]},{Object[#104],UninitializedThis})\n    full_frame(@182,{UninitializedThis,Object[#102]},{Object[#104],UninitializedThis})\n    full_frame(@203,{UninitializedThis,Object[#102]},{Object[#104],UninitializedThis})\n    full_frame(@232,{UninitializedThis,Object[#102]},{Object[#104],UninitializedThis})\n    full_frame(@253,{UninitializedThis,Object[#102]},{Object[#104],UninitializedThis})\n    full_frame(@286,{UninitializedThis,Object[#102]},{Object[#104],UninitializedThis})\n    full_frame(@314,{UninitializedThis,Object[#102]},{Object[#104],UninitializedThis})\n    full_frame(@335,{UninitializedThis,Object[#102]},{Object[#104],UninitializedThis})\n    full_frame(@345,{Object[#2],Object[#102]},{Object[#104]})\n\n\tat java.lang.Class.privateGetDeclaredConstructors(Class.java:2532)\n\tat java.lang.Class.getDeclaredConstructors(Class.java:1901)\n\tat org.codehaus.groovy.util.LazyReference.getLocked(LazyReference.java:46)\n\tat org.codehaus.groovy.util.LazyReference.get(LazyReference.java:33)\n\tat org.opendolphin.server.adapter.InvalidationServletSpec.mockServlet_closure4(InvalidationServletSpec.groovy:41)\n\tat groovy.lang.Closure.call(Closure.java:423)\n\tat org.opendolphin.server.adapter.InvalidationServlet.doPost(InvalidationServlet.groovy:29)\n\tat org.opendolphin.server.adapter.InvalidationServletSpec.with 'invalidate' in the path info, the session should be invalidated(InvalidationServletSpec.groovy:18)\n{code}\n\nSteps to reproduce\n\n1. clone the open-dolphin repository located at https://github.com/canoo/open-dolphin/\n2. switch to the 'update_gradle_build' branch\n3. make sure you have JDK7u65 as your current JDK\n4. gradlew test (subproject/server should have a failing test)\n\nSwitch to JDK7u60 to see the error disappear.",
        "java.lang.VerifyError: Bad <init> method call from inside of a branch {panel:title=Edit by blackdrag}\nKnown JVM versions with this problem: \n1.7.0 update 55\n1.7.0 update 65\n1.7.0 update 67\n1.8.0 update 11\n1.8.0 update 20 (build 31 would fix it, release build is 36 though)\n\nJVM versions older than that should not be a problem\n\nUnverified JVM versions with this fixed:\n1.7.0 update 72\n1.8.0 update 25\nAnd of course all versions after.\n\nDetails can be found here: https://bugs.openjdk.java.net/browse/JDK-8051012\n{panel}\n\n{code}\nclass MyGroovyFile extends File {    \n    MyGroovyFile(String p) {\n        super(p)\n    }\n}\n\nclass MyGroovyFileTest extends GroovyTestCase {\n    void testCtor() {\n        def mgf = new MyGroovyFile(\"/tmp/abc123\")\n    }\n}\n{code}\n\nrunning above results in:\n\n{noformat}\nException in thread \"main\" java.lang.VerifyError: Bad <init> method call from inside of a branch\nException Details:\n  Location:\n    MyGroovyFile.<init>(Ljava/lang/String;)V @93: invokespecial\n  Reason:\n    Error exists in the bytecode\n  Bytecode:\n    0000000: b800 174d 04bd 0019 5903 2b53 5910 ff12\n    0000010: 04b8 001f 2a5f ab00 0000 00d7 0000 0006\n    0000020: aad3 b1ff 0000 003a afa3 00e4 0000 004d\n    0000030: d9ca eaf6 0000 0067 e925 fa09 0000 0086\n    0000040: 53cd d136 0000 00a3 60fa 8f17 0000 00c2\n    0000050: 5f5a 5903 32b8 0025 c000 275f 57b7 0029\n    0000060: a700 975f 5a59 0332 b800 25c0 0027 5f59\n    0000070: 0432 b800 2f5f 57b7 0032 a700 7d5f 5a59\n    0000080: 0332 1204 b800 36c0 0004 5f59 0432 b800\n    0000090: 25c0 0027 5f57 b700 39a7 005e 5f5a 5903\n    00000a0: 32b8 0025 c000 275f 5904 32b8 0025 c000\n    00000b0: 275f 57b7 003c a700 415f 5a59 0332 b800\n    00000c0: 25c0 0027 5f59 0432 1204 b800 36c0 0004\n    00000d0: 5f57 b700 3fa7 0022 5f5a 5903 3212 41b8\n    00000e0: 0036 c000 415f 57b7 0044 a700 0dbb 0046\n    00000f0: 5912 48b7 0049 bf57 2ab6 004d 4e2d 2a5f\n    0000100: b500 4f2d 57b1                         \n  Stackmap Table:\n    full_frame(@80,{UninitializedThis,Object[#39],Object[#85]},{Object[#87],UninitializedThis})\n    full_frame(@99,{UninitializedThis,Object[#39],Object[#85]},{Object[#87],UninitializedThis})\n    full_frame(@125,{UninitializedThis,Object[#39],Object[#85]},{Object[#87],UninitializedThis})\n    full_frame(@156,{UninitializedThis,Object[#39],Object[#85]},{Object[#87],UninitializedThis})\n    full_frame(@185,{UninitializedThis,Object[#39],Object[#85]},{Object[#87],UninitializedThis})\n    full_frame(@216,{UninitializedThis,Object[#39],Object[#85]},{Object[#87],UninitializedThis})\n    full_frame(@237,{UninitializedThis,Object[#39],Object[#85]},{Object[#87],UninitializedThis})\n    full_frame(@247,{Object[#2],Object[#39],Object[#85]},{Object[#87]})\n\n\tat java.lang.Class.getDeclaredMethods0(Native Method)\n\tat java.lang.Class.privateGetDeclaredMethods(Class.java:2570)\n\tat java.lang.Class.getMethod0(Class.java:2813)\n\tat java.lang.Class.getMethod(Class.java:1663)\n\tat sun.launcher.LauncherHelper.getMainMethod(LauncherHelper.java:494)\n\tat sun.launcher.LauncherHelper.checkAndLoadMain(LauncherHelper.java:486)\n:run FAILED\n\nFAILURE: Build failed with an exception.\n{noformat}\n\n"
    ],
    [
        "GROOVY-6994",
        "GROOVY-6203",
        "GroovyScriptEngine does not honor\u00c2\u00a0CompilerConfiguration for delegateScriptClass java-fragment:\n-----------------------------------------------------\nGroovyScriptEngine groovyScriptEngine = new GroovyScriptEngine(resourceConnector);\n\nCompilerConfiguration cc = new CompilerConfiguration();\ncc.setScriptBaseClass(DelegatingScript.class.getName());\ngroovyScriptEngine.setConfig(cc);\n\nDelegatingScript delegatingScript = (DelegatingScript)groovyScriptEngine.createScript(scriptPath, groovyBinding);\n\ndelegatingScript.setDelegate(delegate);\n\nObject returnValue = delegatingScript.run();\n-----------------------------------------------------\n\nthe error is that createScript() will not create a DelegatingScript and will cause a classcastexception",
        "GroovyScriptEngine does not take script base class into account When configuring GroovyScriptEngine with a custom script base class, the script engine does not take it account:\n\n{code}\nCompilerConfiguration cc = new CompilerConfiguration();\n\ncc.setScriptBaseClass(ScriptBase.class.getName());\n\nGroovyScriptEngine engine = new GroovyScriptEngine(\"file://.\");\n\nengine.setConfig(cc);\n\nScript script = engine.createScript(\"test.groovy\", new Binding());\n\nassertTrue(script instanceof ScriptBase); // fails\n\n{code}\n\nThis has been discussed here: http://groovy.329449.n5.nabble.com/setScriptBaseClass-does-not-work-for-GroovyScriptEngine-td5710646.html\nThe workaround with setting the CompilerConfiguration on the GroovyClassLoader works.\nAlso related: GROOVY-3281"
    ],
    [
        "GROOVY-7073",
        "GROOVY-6454",
        "Delegating methods are not generated when using @Delegate and there is $ character in method name The following throws a missing method exception:\n{code}\nclass HasDollar {\n    void $() {\n        println '$'\n    }\n}\n\nclass Delegating {\n\n    @Delegate\n    HasDollar hasDollar = new HasDollar()\n}\n\nnew Delegating().$()\n{code}\n\nIf on the other hand we change the method name not to contain dollar character then there is no exception thrown:\n{code}\nclass HasDollar {\n    void dollar() {\n        println '$'\n    }\n}\n\nclass Delegating {\n\n    @Delegate\n    HasDollar hasDollar = new HasDollar()\n}\n\nnew Delegating().dollar()\n{code}\n\nThis is a *blocking issue* for Geb. It's impossible to compile it using latest Groovy which prevents us from updating the version used to build it - it's still using 1.8.9.",
        "Can't delegate (with the @Delegate annotation) to a method whose name contains a dollar ($) character As of 2.2.0 it's no longer possible to delegate (via the @Delegate annotation) to a method whose name contains a dollar ($) character. The attached test case compiles and runs without error under Groovy 2.1.3 and 2.1.6, but fails to compile with the following error under 2.2.0:\n\n> Caught: groovy.lang.MissingMethodException: No signature of method: Delegating.te$t() is applicable for argument types: (java.lang.Integer) values: [42]\n> Possible solutions: test(java.lang.Integer), wait(), getAt(java.lang.String), wait(long), wait(long, int), dump()\n"
    ],
    [
        "GROOVY-7080",
        "GROOVY-7079",
        "Cycle in Eclipse Try to follow guide from https://github.com/groovy/groovy-core#building\nImporting groovy-core and groovy-test gives the error\nA cycle was detected in the build path of project 'groovy'. The cycle consists \nof projects {groovy, groovy-test}\n\nWhy not just merge groovy-test in groovy-core? The subprojects of Groovy depend on both anyway, and groovy-test is small.",
        "Cycle in Eclipse Following the guide at https://github.com/groovy/groovy-core#building\nImporting groovy-core and groovy-test in Eclipse gives \nA cycle was detected in the build path of project 'groovy'. The cycle consists \nof projects {groovy, groovy-test}\n\nWhy not just put all classes of groovy-test into groovy-core? Groovy subprojects depend on groovy-core and groovy-test anyway, and groovy-test is very small."
    ],
    [
        "GROOVY-7093",
        "GROOVY-6984",
        "VerifyError at CompileStatic {code}\nimport groovy.transform.CompileStatic\n\n@CompileStatic\nclass Test {\n    static void test() {\n        def map = [:]\n        println(map[0] ?: (map[0] = 1))\n    }\n}\n\nTest.test()\n{code}\n\n{code}\nCaught: java.lang.VerifyError: (class: Test, method: test signature: ()V) Inconsistent stack height 3 != 2\njava.lang.VerifyError: (class: Test, method: test signature: ()V) Inconsistent stack height 3 != 2\n        at test.run(test.groovy:11)\n{code}\n",
        "VerifyError for CompileStatic This is happening in my code and I was able to pull it out and run it on the groovyconsole.appspot.com and get the same error:\n\n@groovy.transform.CompileStatic\ndef doit() {\nString whoops = \"one,TWO, , three\"\nwhoops.tokenize(',')*.trim().findAll({String tok -> return tok.size()>0})*.toLowerCase()\n}\n\ndoit()\u00e2\u0080\u008b\u00e2\u0080\u008b\u00e2\u0080\u008b\n\nit returns\njava.lang.VerifyError: (class: Script1, method: doit signature: ()Ljava/lang/Object;) Inconsistent stack height 3 != 2\n\nIt appears to be the last *.toLowerCase() - if I turn that into a collect, its all happy.\n"
    ],
    [
        "GROOVY-7105",
        "GROOVY-6703",
        "Oracle Thin Driver Fails with an Exception in Groovy 2.3.x Trying to load the Oracle driver in Groovy fails with the following error:\n\njava.lang.NoClassDefFoundError: oracle/xdb/XMLType\n\tat java_sql_Connection$getMetaData.call(Unknown Source)\n\tat db_test.printMetaData(db_test.groovy:9)\n\tat db_test.printMetaData(db_test.groovy)\n\tat db_test$printMetaData$0.callCurrent(Unknown Source)\n\tat db_test.run(db_test.groovy:45)\nCaused by: java.lang.ClassNotFoundException: oracle.xdb.XMLType\n\t... 5 more\n\nThis works in Groovy 2.1.x.  This is loading the thin driver which doesn't require extra libraries.  It appears that Groovy loads Oracle's OCI driver which requires these additional jar files and fails.\n\n{code}\nimport groovy.sql.Sql\nimport java.sql.ResultSet\nimport java.sql.DatabaseMetaData\n\nvoid printMetaData( Sql sql, catalog = null, schema = null ) {\n    try {\n        DatabaseMetaData metadata = sql.connection.getMetaData()\n        \n        ResultSet rs = metadata.getCatalogs()\n        while( rs.next() ) {\n           String catalogName = rs.getString(\"TABLE_CAT\")\n           println(\"${catalogName}\")\n        }\n        rs.close()\n        \n        rs = metadata.getSchemas()\n        while( rs.next() ) {\n           String catalogName = rs.getString(\"TABLE_CAT\")\n           String schemaName = rs.getString(\"TABLE_SCHEM\")\n           \n           println(\"${catalogName}.${schemaName}\")\n        }\n        rs.close()\n        \n        def types = [ \"TABLE\" ]\n        rs = metadata.getTables( catalog, schema, null, types.toArray( new String[types.size()]) )\n        while( rs.next() ) {\n           String catalogName = rs.getString(\"TABLE_CAT\")\n           String schemaName = rs.getString(\"TABLE_SCHEM\")\n           String tableName = rs.getString(\"TABLE_NAME\")\n           println(\"${catalogName}.${schemaName}.${tableName}\")\n        }\n        rs.close()\n    } finally {\n        sql.close()\n    }\n}\n\noracle = Sql.newInstance(\"jdbc:oracle:thin:@//localhost:1521/PDB1\", \"someUser\", \"somePassword\", \"oracle.jdbc.driver.OracleDriver\")\n\nprintMetaData( oracle )\n{code}",
        "Strange problems with EhCache from Groovy This code works fine in Java (\"test\" is a simple cache defined in ehcache.xml)\n\nnet.sf.ehcache.CacheManager.getInstance().getCache(\"test\").getSize()\n\nbut in Groovy:\n\nCaught: java.lang.NoClassDefFoundError: javax/transaction/TransactionManager\njava.lang.NoClassDefFoundError: javax/transaction/TransactionManager\n\tat test.run(test.groovy:1)\n\n"
    ],
    [
        "GROOVY-7132",
        "GROOVY-7028",
        "JsonSlurper throws exception if reader does not fill complete char buffer The method JsonSlurper.parse(Reader) throws the following exception:\n{code}\ngroovy.json.JsonException: expecting '}' or ',' but got current char '' with an int value of 0\n\nThe current character read is '' with an int value of 0\n{code}\n\nif the reader does not always fill the complete char buffer at the method:\n{code}\npublic int read(char[] cbuf, int off, int len) throws IOException\n{code}\nbut returns a {{value < len}} on certain points.\n\nI have provided a test case at \nhttps://github.com/effrafax/jsonslurp\n\n A standard use case where this exception occurs:\nif you use a http-builder with JSON contentType where the server returns the response chunked (Transfer-Encoding: chunked). The InputStreamReader of the apache http client does not fill the complete char buffer at chunk borders.\n",
        "Chunked input stream incorrectly handled in IO.read() When JSON is going to be parsed from chunked input stream (Transfer-Encoding: chunked), it may happen that JSON is not parsed correctly since the read data is prematurely ended. The problem lies in IO class in read method. The assumption that the fact that number of bytes read is lower than the size of destination buffer in Reader.read(char[]) method implicates the end of stream is wrong. Please also find a test case attached - the former test with plain byte stream passes, the latter with chunked input stream reads only 16 first bytes (first chunk). When IO.read() is used in BaseJsonParser on chunked stream the parser may fail with exception then."
    ],
    [
        "GROOVY-7167",
        "GROOVY-7055",
        "can't create list of strings {code}\ngroovy:000> [\"asdf\"]\nERROR java.lang.IllegalArgumentException:\nMissing closing \"\n        at java_lang_Runnable$run.call (Unknown Source)\ngroovy:000> [ \"asdf\"]\n===> [asdf]\ngroovy:000> ['asdf']\nERROR java.lang.IllegalArgumentException:\nMissing closing '\n        at java_lang_Runnable$run.call (Unknown Source)\ngroovy:000> [ 'asdf']\n===> [asdf]\n{code}\n\npretty sure this bug was introduced with https://github.com/groovy/groovy-core/pull/491/files - I tried to figure it out what's the problem by starring at the code, but wasn't able to see it ...",
        "Groovysh: Command hyphen checker breaks sane code cases To reproduce, start groovysh\n\ngroovy:000> map = [:]\n===> [:]\ngroovy:000> map.put('a', 77)\nERROR java.lang.IllegalArgumentException:\nMissing closing '\n\nThis is due to some tiny oversight from GROOVY 6942.\nPR is ready. I suggest merging into 2.4.0, as groovysh is unusable else. "
    ],
    [
        "GROOVY-7331",
        "GROOVY-7008",
        "JsonOutput does not escape double quotes in map keys Double quotes (\") should be escaped in JSON.\n\n{{JsonOutput}} does not perform this escaping for map keys:\n\n{code}\nassert groovy.json.JsonOutput.toJson(['the \"quoted\" key':'bug']) == /{\"the \\\"quoted\\\" key\":\"bug\"}/\n                              |                                  |\n                              {\"the \"quoted\" key\":\"bug\"}         false\n{code}",
        "JsonOutput / Groovy JSON Builder do not escape special characters in map keys When creating JSON from maps, the keys are not properly quoted. The result ist invalid JSON.\n\nExample code:\n\ndef o = [\n    'a \"Test\"': \"test1\",\n    'test2': 'Test \"2\"'\n];\n\nprintln JsonOutput.toJson(o);\nprintln JsonOutput.prettyPrint(JsonOutput.toJson(o));\n\nExample code output:\n\n{\"a \"Test\"\":\"test1\",\"test2\":\"Test \\\"2\\\"\"}\nCaught: groovy.json.JsonException: Lexing failed on line: 1, column: 6, while reading 'T', no possible valid JSON value or punctuation could be recognized.\n\nAs you see, 'Test \"2\"' is being quoted correctly, but 'a \"Test\"' is not. The pretty printing fails parsing the invalid JSON in the second println line.\nThis happens with JsonBuilder as well."
    ],
    [
        "GROOVY-7389",
        "GROOVY-7388",
        "DefaultGroovyMethods class's plus(T[] left, xxxx<T> right) have ambiguous errors Trying to use the `groovy.transform.etc` for the first time. When I run it, all works well until it gets to `org.codehaus.groovy.runtime.DefaultGroovyMethods.java`\r\n\r\nThere are a few problems with how the `public static <T> T[] plug(T[] left, xxx right)` method. Where xxx is T[], Iterable<T> right, or Collection<T> right.\r\n\r\nIn all of these cases, you just need to change the `return (T[]) plus(...).toArray();`  to   `return (T[]) plus((Collection<T>)...).toArray();\r\n\r\nProblem solved.",
        "DefaultGroovyMethods class's plus(T[] left, xxxx<T> right) have ambiguous errors Trying to use the `groovy.transform.etc` for the first time. When I run it, all works well until it gets to `org.codehaus.groovy.runtime.DefaultGroovyMethods.java`\r\n\r\nThere are a few problems with how the {{public static <T> T[] plus(T[] left, xxx right)}} method. Where xxx is T[], Iterable<T> right, or Collection<T> right.\r\n\r\nIn all of these cases, you just need to change the `return (T[]) plus(...).toArray();`  to   `return (T[]) plus((Collection<T>)...).toArray();\r\n\r\nProblem solved if you follow these instructions."
    ],
    [
        "GROOVY-7441",
        "GROOVY-7416",
        "Problem With CompileStatic And Trait Methods In Abstract Subclass This issue was created to attach files to this bug: https://issues.apache.org/jira/browse/GROOVY-7416\r\n\r\n@CompileStatic should compile the following:\r\n{code}\r\nabstract class ABaseClass implements SomeInterface, SomeTrait, TraitWithSomeOtherInterface {\r\n\r\n}\r\nabstract class ASubClass extends ABaseClass {\r\n  void someMethod() { \r\n    someInterfaceMethod() \r\n    someTraitMethod() \r\n    someOtherInterfaceMethod() \r\n  }\r\n}\r\ninterface SomeInterface { \r\n  void someInterfaceMethod() \r\n}\r\ninterface SomeOtherInterface { \r\n  void someOtherInterfaceMethod() \r\n}\r\ntrait SomeTrait { \r\n  abstract void someTraitMethod() \r\n}\r\ntrait TraitWithSomeOtherInterface implements SomeOtherInterface {\r\n\r\n}\r\n{code}\r\n\r\nNow that I've had time to think about this some more, the above isn't complete because there's an infinite number of possibilities with traits:\r\n\r\n1) traits can extend other traits.  For example,\r\ntrait A extend B {\r\n}\r\ntrait B extend C {\r\n}\r\n... etc\r\n1) traits can implement other traits/interfaces.  For example,\r\ntrait A implements B, C, D {\r\n}\r\ntrait B extend E {\r\n}\r\ntrait C implements F {\r\n}\r\n... and so on \r\n\r\nThe main value of traits, aside from (implementation w/ interface) is the behavior of \"stackable traits.\"  So as long as we can get that to work, then all\r\nother permutations aren't as important imho.  For example:\r\n\r\n{code}\r\nABaseClass implements TraitA, TraitB, TraitC {\r\n\r\n}\r\n\r\nASubClass extends ABaseClass {\r\n   someMethod() {\r\n     doSomething() // this method is equivalent to calling TraitC.super.doSomething(), then TraitB.super.doSomething(), then TraitA.super.doSomething()\r\n  }\r\n}\r\n\r\ninterface IDoSomething {\r\n  void doSomething()\r\n}\r\n\r\ntrait TraitA implements IDoSomething {\r\n  void doSomething() {\r\n    if (forA) {\r\n      // call for us\r\n    } else {\r\n      // pass the call on\r\n      try { // we wrap this in try/catch because we won't assume the implements order\r\n        super.doSomething() \r\n      } catch(e) {\r\n      }\r\n    }\r\n  }\r\n}\r\ntrait TraitB implements IDoSomething {\r\n    if (forB) {\r\n      // call for us\r\n    } else {\r\n      // pass the call on\r\n      try { // we wrap this in try/catch because we won't assume the implements order\r\n        super.doSomething() \r\n      } catch(e) {\r\n      }\r\n    }\r\n}\r\ntrait TraitC implements IDoSomething {\r\n    if (forC) {\r\n      // call for us\r\n    } else {\r\n      // pass the call on\r\n      try { // we wrap this in try/catch because we won't assume the implements order\r\n        super.doSomething() \r\n      } catch(e) {\r\n      }\r\n    }\r\n}\r\n{code}\r\n",
        "Problem With CompileStatic And Interface Methods In Abstract Subclass The attached abstractcompilestatic.zip contains the following:\r\n\r\n{code:borderStyle=solid|title=src/main/groovy/demo/SomeInterface.groovy}\r\npackage demo\r\n\r\ninterface SomeInterface {\r\n    void someInterfaceMethod()\r\n}\r\n{code}\r\n\r\n{code:borderStyle=solid|title=src/main/groovy/demo/AbstractSuperClass.groovy}\r\npackage demo\r\n\r\nabstract class AbstractSuperClass implements SomeInterface {}\r\n{code}\r\n\r\n{code:borderStyle=solid|title=src/main/groovy/demo/AbstractSubClass.groovy}\r\npackage demo\r\n\r\nimport groovy.transform.CompileStatic\r\n\r\n@CompileStatic\r\nabstract class AbstractSubClass extends AbstractSuperClass {\r\n\r\n    void someMethod() {\r\n        someInterfaceMethod()\r\n    }\r\n}\r\n{code}\r\n\r\nThe code will not compile.\r\n\r\n{noformat}\r\n $ ./gradlew clean compileGroovy\r\n:clean\r\n:compileJava UP-TO-DATE\r\n:compileGroovy\r\nstartup failed:\r\n/Users/jeff/abstractcompilestatic/src/main/groovy/demo/AbstractSubClass.groovy: 9: [Static type checking] - Cannot find matching method demo.AbstractSubClass#someInterfaceMethod(). Please check if the declared type is right and if the method exists.\r\n @ line 9, column 9.\r\n           someInterfaceMethod()\r\n           ^\r\n\r\n1 error\r\n\r\n:compileGroovy FAILED\r\n\r\nFAILURE: Build failed with an exception.\r\n\r\n* What went wrong:\r\nExecution failed for task ':compileGroovy'.\r\n> Compilation failed; see the compiler error output for details.\r\n\r\n* Try:\r\nRun with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output.\r\n\r\nBUILD FAILED\r\n\r\nTotal time: 4.045 secs\r\n{noformat}\r\n\r\nIf the AbstractSubClass is modified to implement the interface as shown below the code will compile:\r\n\r\n\r\n{code:borderStyle=solid|title=src/main/groovy/demo/AbstractSubClass.groovy}\r\npackage demo\r\n\r\nimport groovy.transform.CompileStatic\r\n\r\n@CompileStatic\r\nabstract class AbstractSubClass extends AbstractSuperClass implements SomeInterface {\r\n\r\n    void someMethod() {\r\n        someInterfaceMethod()\r\n    }\r\n}\r\n{code}\r\n"
    ],
    [
        "GROOVY-7454",
        "GROOVY-7420",
        "[Static type checking] - Reference to method is ambiguous This issue has a number of seeming duplicates marked as \"fixed\", but I'm reliably seeing it in 2.4.3 when calling `findAll()` on any Spring `CrudRepository`:\r\n\r\n{code}\r\nGroovy:[Static type checking] - Reference to method is ambiguous. Cannot choose between [java.util.List <T> org.springframework.data.mongodb.repository.MongoRepository#findAll(), java.util.List <T> org.springframework.data.mongodb.repository.MongoRepository#findAll()]\r\n{code}\r\n\r\nNo idea whether this is triggered in particular by the name of the method, which Groovy defines on {{Object}}.",
        "Cannot choose between primitive and object variants of an overloaded method The static type checked cannot choose which variant of a overloaded method with both primitive and object parameters (e.g. {{long}} and {{Long}}) to use when the actual type of the parameter is the object type (e.g. {{Long}}):\r\n\r\n{code}\r\nclass A {\r\n    static String m(long p) {\r\n        \"primitive\"\r\n    }\r\n\r\n    static String m(Long p) {\r\n        \"object\"\r\n    }\r\n}\r\n\r\nLong l = 42L\r\nA.m(l)\r\n{code}\r\nyields the following compilation error:\r\n{noformat}\r\n[Static type checking] - Reference to method is ambiguous. Cannot choose between [java.lang.String A#m(java.lang.Long), java.lang.String A#m(long)]\r\n{noformat}\r\n\r\nThe problem can be worked around by explicitely calling {{.longValue()}} on the {{Long}}."
    ],
    [
        "GROOVY-7483",
        "GROOVY-6922",
        "JSONSlurper returns wrong value for floating point in Groovy 2.4.3 I'm upgrading groovy 2.4.3. But i see blocking issues causes test case failures.\r\n\r\nJSONSlurper returns wrong value.\r\n\r\nFor example:\r\nWhen i pass the value 5.0, then it is returned as 5.\r\nnew JsonSlurper.parseText(obj). \r\n\r\nI hope, this issue was reported by the earlier version of groovy. \r\n\r\nI need to know what is the workaround for this issue?\r\n\r\n\r\nThanks,\r\nVijay\r\n\r\n\r\n",
        "JsonSlurper loses trailing 0's in numbers (regression in Groovy 2.3) In previous versions of Grails before JsonSlurper was significantly changed, this test passed. However, it fails in Groovy 2.3.x (tested up to 2.3.3).\n\n{code}\nvoid testParseNumWithDecimals() {\n   def i = parser.parseText('123.40')\n   BigDecimal i2 = 123.40G\n   assert i instanceof BigDecimal\n   assert i == i2\n}\n{code}\nThis test should be added to https://github.com/groovy/groovy-core/blob/GROOVY_2_3_X/subprojects/groovy-json/src/test/groovy/groovy/json/JsonSlurperTest.groovy\n\nIn Groovy 2.3.3, the assertion fails as i = 123.4G, not 123.40G."
    ],
    [
        "GROOVY-7531",
        "GROOVY-7509",
        "Aliased static imports wrong in stubs I believe GROOVY-7366 didn't account for aliasing in imports.  For example, if I have\r\n{code:java|title=Application.groovy}\r\nimport static Util.hello as hi\r\n\r\nclass Application {\r\n  static void main(def args) {\r\n    hi\r\n  }\r\n}\r\n{code}\r\n\r\n{code:java|title=Util.groovy}\r\nclass Util {\r\n  static void sayHello() {\r\n    println \"Hello\"\r\n  }\r\n}\r\n{code}\r\n\r\nThe generated stub looks like\r\n{code:java|title=Application.java}\r\nimport java.lang.*;\r\nimport java.io.*;\r\nimport java.net.*;\r\nimport java.util.*;\r\nimport groovy.lang.*;\r\nimport groovy.util.*;\r\nimport static Util.hi;\r\n\r\npublic class Application\r\n  extends java.lang.Object  implements\r\n    groovy.lang.GroovyObject {\r\n;\r\npublic  groovy.lang.MetaClass getMetaClass() { return (groovy.lang.MetaClass)null;}\r\npublic  void setMetaClass(groovy.lang.MetaClass mc) { }\r\npublic  java.lang.Object invokeMethod(java.lang.String method, java.lang.Object arguments) { return null;}\r\npublic  java.lang.Object getProperty(java.lang.String property) { return null;}\r\npublic  void setProperty(java.lang.String property, java.lang.Object value) { }\r\npublic static  void main(java.lang.String... args) { }\r\n}\r\n{code}\r\n\r\nWhen it should be like\r\n{code:java|title=Application.java}\r\nimport java.lang.*;\r\nimport java.io.*;\r\nimport java.net.*;\r\nimport java.util.*;\r\nimport groovy.lang.*;\r\nimport groovy.util.*;\r\nimport static Util.hello;\r\n\r\npublic class Application\r\n  extends java.lang.Object  implements\r\n    groovy.lang.GroovyObject {\r\n;\r\npublic  groovy.lang.MetaClass getMetaClass() { return (groovy.lang.MetaClass)null;}\r\npublic  void setMetaClass(groovy.lang.MetaClass mc) { }\r\npublic  java.lang.Object invokeMethod(java.lang.String method, java.lang.Object arguments) { return null;}\r\npublic  java.lang.Object getProperty(java.lang.String property) { return null;}\r\npublic  void setProperty(java.lang.String property, java.lang.Object value) { }\r\npublic static  void main(java.lang.String... args) { }\r\n}\r\n{code}",
        "Problem With Stub Generator And Static Import Aliases The attached staticimportalias.zip contains the following:\r\n\r\n{code:borderStyle=solid|title=src/main/groovy/demo/helper/SomeHelper.java}\r\npackage demo.helper;\r\n\r\npublic class SomeHelper {\r\n    public static final int ANSWER = 42;\r\n}\r\n{code}\r\n\r\n{code:borderStyle=solid|title=src/main/groovy/demo/SomeClass.groovy}\r\npackage demo\r\n\r\nimport static demo.helper.SomeHelper.ANSWER as MAGIC_NUMBER\r\n\r\nclass SomeClass {\r\n\r\n    static int getMagicNumber() {\r\n        MAGIC_NUMBER\r\n    }\r\n}\r\n{code}\r\n\r\n{code:borderStyle=solid|title=src/main/groovy/demo/SomeJavaClass.java}\r\npackage demo;\r\n\r\npublic class SomeJavaClass {\r\n    SomeClass sc;\r\n}\r\n{code}\r\n\r\nThe code will not compile with Groovy 2.4.4:\r\n\r\n{noformat}\r\n$ ./gradlew clean cG\r\n:clean\r\n:compileJava UP-TO-DATE\r\n:compileGroovy\r\n/Users/jeff/staticimportalias/build/tmp/groovy-java-stubs/demo/SomeClass.java:9: error: cannot find symbol\r\nimport static demo.helper.SomeHelper.MAGIC_NUMBER;\r\n^\r\n  symbol:   static MAGIC_NUMBER\r\n  location: class\r\n1 error\r\nstartup failed:\r\nCompilation failed; see the compiler error output for details.\r\n\r\n1 error\r\n\r\n:compileGroovy FAILED\r\n\r\nFAILURE: Build failed with an exception.\r\n\r\n* What went wrong:\r\nExecution failed for task ':compileGroovy'.\r\n> Compilation failed; see the compiler error output for details.\r\n\r\n* Try:\r\nRun with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output.\r\n\r\nBUILD FAILED\r\n\r\nTotal time: 4.467 secs\r\n{noformat}\r\n\r\nIf I edit the top level build.gradle to use Groovy 2.4.3, the code compiles.\r\n"
    ],
    [
        "GROOVY-7539",
        "GROOVY-6862",
        "Traits break if method name has $ sign trait TestTrait {\r\n    public void 'testmethod $problem'() {\r\n        println(\"test\")\r\n    }\r\n}\r\n\r\nIf we use this trait as (implements TestTrait) we get:\r\nCan't have an abstract method in a non-abstract class. The class 'SomeClass' must be declared abstract or the method 'someMethod()' must be implemented.\r\n\r\nSince Groovy supports method names as strings this is unexpected. \r\n",
        "Traits dont allow $ in identifiers where normal classes do looks like traits are stricter than the \"normal\" groovy when an identifier happens to contain the dollar sign:\n\n{code}\n252 /tmp> <q.groovy\ntrait Test {\n static foo_ok() { println 'trait non-$ OK' }\n static foo$oops() { println 'trait $ OK' }\n}\nclass Foo implements Test {\n static foo$ok() { println 'class $ OK' }\n}\nFoo.foo$ok()\nFoo.foo_ok()\nFoo.foo$oops()\n253 /tmp> groovy q\nclass $ OK\ntrait non-$ OK\nCaught: groovy.lang.MissingMethodException: No signature of method: static Foo.foo$oops() is applicable for argument types: () values: []\nPossible solutions: foo$ok(), foo_ok()\n...\n{code}"
    ],
    [
        "GROOVY-7597",
        "GROOVY-7376",
        "Static Compiler tries to cast delegate to target type of property accessor I've been able to finally isolate a static compiler issue with accessing properties on delegates that occur within our projects:\r\n\r\n{code}\r\nclass Calculation {\r\n  boolean isValid() { true }\r\n}\r\n\r\nclass Entity {\r\n  Calculation getCalculation(String name) { new Calculation() }\r\n}\r\n\r\nclass Feature extends Entity {\r\n}\r\n\r\nvoid DoWithFeature(@DelegatesTo(Feature) Closure c) {\r\n  new Feature().with(c)\r\n}\r\n\r\n@groovy.transform.CompileStatic\r\nvoid doIt() {\r\n  DoWithFeature() {\r\n    println getCalculation(\"whatever\").valid\r\n  }\r\n}\r\n\r\ndoIt()\r\n{code}\r\n\r\nThe result is {{java.lang.ClassCastException: Feature cannot be cast to Calculation}}\r\n\r\nWorkarounds:\r\n* change the property access into a method access \"valid\" -> \"isValid()\"\r\n* Remove CompileStatic annotation\r\n\r\nAs seen in the following bytecode, the static compiler tries to cast the delegate to Calculation (which always fails), then tries to call ScriptBytecodeAdapter.castToType to try to cast the \"Calculation\" back to an Entity to properly call getCalculation(\"\").isValid() on it.\r\n\r\n{code}\r\n  // access flags 0x1\r\n  public doCall(Ljava/lang/Object;)Ljava/lang/Object;\r\n   L0\r\n    LINENUMBER 19 L0\r\n    ALOAD 0\r\n    CHECKCAST script1442861431462$_doIt_closure1\r\n    INVOKEVIRTUAL script1442861431462$_doIt_closure1.getThisObject ()Ljava/lang/Object;\r\n    LDC Lgroovy/lang/Script;.class\r\n    INVOKESTATIC org/codehaus/groovy/runtime/ScriptBytecodeAdapter.castToType (Ljava/lang/Object;Ljava/lang/Class;)Ljava/lang/Object;\r\n    CHECKCAST groovy/lang/Script\r\n    ALOAD 0\r\n    CHECKCAST script1442861431462$_doIt_closure1\r\n    INVOKEVIRTUAL script1442861431462$_doIt_closure1.getDelegate ()Ljava/lang/Object;\r\n    CHECKCAST Calculation\r\n    LDC LEntity;.class\r\n    INVOKESTATIC org/codehaus/groovy/runtime/ScriptBytecodeAdapter.castToType (Ljava/lang/Object;Ljava/lang/Class;)Ljava/lang/Object;\r\n    CHECKCAST Entity\r\n    LDC \"whatever\"\r\n    INVOKEVIRTUAL Entity.getCalculation (Ljava/lang/String;)LCalculation;\r\n    INVOKEVIRTUAL Calculation.isValid ()Z\r\n    INVOKESTATIC java/lang/Boolean.valueOf (Z)Ljava/lang/Boolean;\r\n    INVOKEVIRTUAL groovy/lang/Script.println (Ljava/lang/Object;)V\r\n    ACONST_NULL\r\n    ARETURN\r\n   L1\r\n    ACONST_NULL\r\n    ARETURN\r\n    LOCALVARIABLE this Lscript1442861431462$_doIt_closure1; L0 L1 0\r\n    LOCALVARIABLE it Ljava/lang/Object; L0 L1 1\r\n    MAXSTACK = 3\r\n    MAXLOCALS = 2\r\n{code}\r\n",
        "ClassCastException when searching for a property inside a with closure I know this is not ideal, but I couldn't isolate this in a small test case.\nHowever, my real case is something like this:\n\n{code}\npackage test\n\nimport groovy.transform.CompileStatic;\n\n@CompileStatic\nclass Test {\n\n\tString testProperty\n\t\n\tvoid doSomething(Foo f) {\n\t\tf.with {\n\t\t\tpropertyA = testProperty\n\t\t\tbar(testProperty)\n\t\t}\n\t}\n\t\n \n\tstatic void main(String[] args) {\n\t\tdef t = new Test()\n\t\tdef f = new Foo()\n\t\tt.testProperty = 'test'\n\t\tt.doSomething(f)\n\t\tprintln f.propertyA\n\t}\n}\n\n@CompileStatic\nclass Foo {\n\n\tString propertyA\n\n\tvoid bar(String param) {\n\t\tprintln(\"bar $param\")\n\t}\n\t\n\tstatic class Nested {\n\t\tString propertyB\n\t}\t\n}\n{code}\n\nIt happens that the row with {{t.testProperty = 'test'}} or the one with {{bar(testProperty)}} (it depends on how I change the code in ways that in theory *should* be equivalent with each other) throw a {{ClassCastException}} with the following stack trace:\n\n{noformat}\n(when calling bar(...))\nClassCastException.<init>(String) line: 58\t\nGeneratedMethodAccessor1279.invoke(Object, Object[]) line: not available\t\nMethod.invoke(Object, Object...) line: 606\t\nCachedMethod.invoke(Object, Object[]) line: 90\t\nMetaClassImpl.invokeMissingProperty(Object, String, Object, boolean) line: 873\t\nMetaClassImpl.getProperty(Class, Object, String, boolean, boolean) line: 1852\t\nMetaClassImpl.getProperty(Object, String) line: 3689\t\nInvoiceIdto.getProperty(String) line: not available\t\nInvokerHelper.getProperty(Object, String) line: 168\t\nTest$_doSomething_closure2(Closure).getPropertyTryThese(String, Object, Object) line: 321\t\n{noformat}\n\nOr:\n{noformat}\n(when trying to set propertyA value)\nClassCastException.<init>(String) line: 58\t\nGeneratedMethodAccessor1287.invoke(Object, Object[]) line: not available\t\nMethod.invoke(Object, Object...) line: 606\t\nCachedMethod.invoke(Object, Object[]) line: 90\t\nCachedMethod(MetaMethod).doMethodInvoke(Object, Object[]) line: 324\t\nMetaClassImpl.setProperty(Class, Object, String, Object, boolean, boolean) line: 2661\t\nMetaClassImpl.setProperty(Object, String, Object) line: 3701\t\nInvoiceIdto.setProperty(String, Object) line: not available\t\nInvokerHelper.setProperty(Object, String, Object) line: 191\t\nInvoiceListService$_refreshInvoice_closure2(Closure).setPropertyTryThese(String, Object, Object, Object) line: 388\t\n{noformat}\n\nThe {{ClassCastException}} message is that {{Foo$Nested}} cannot be cast to {{Foo}}. In fact, in the following row of the stack trace:\n{noformat}\nMetaClassImpl.setProperty(Object, String, Object) line: 3701\t\n{noformat}\nI see the following values for variables:\n- {{object}} is my {{Foo}} instance\n- {{property}} is either {{'propertyA'}} or {{'testProperty'}} (depends on cases)\n- but {{this}} is an instance of {{MetaClassImpl}} for {{Foo$Nested}} rather than for {{Foo}} (the toString() is something like {{groovy.lang.MetaClassImpl@6c720cf6[class test.Foo$Nested]}}).\n\nI hope this can give you an idea on what may be going on.\nRemoving the static compilation with {{@TypeChecked(TypeCheckingMode.SKIP)}} on the equivalent of {{Test.doSomething}} does not solve the problem, neither it does if I remove the {{@CompileStatic}} from the {{Foo}} class declaration."
    ]
]