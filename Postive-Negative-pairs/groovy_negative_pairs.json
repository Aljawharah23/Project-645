[
    [
        "GROOVY-3291",
        "GROOVY-1853",
        "Allow File.append and File.leftShift to handle binary data. Currently, the DGM method File.append() only works for text data.  File.append(Object) can technically accept an InputStream, but it assumes that both the streaming data and the output file are using the platform-default character encoding.   In any other case, the data will be mangled.\n\nI propose creating a method File.append(InputStream) which will basically delegate to InputStream.leftShift(InputStream).  This maintains backward-compatibility since all InputStreams that happen to be text will be piped through un-interpreted, which AFAIK would be identical to the current behavior of reading the stream and writing it back out using the same encoding.  But in this case, if the source data is binary or happens to have an encoding that is not the platform default, it will not get mashed by a reader using the incorrect encoding.  Patch is attached.\n\n",
        "Groovy in maven(m2) repository does not have pom.xml The groovy artifacts installed in the maven repository do not have a pom.xml, and they should.  As a result, any maven project that depends on groovy tries to download the POM each time mvn is run.\n\nhttp://repo1.maven.org/maven2/groovy/"
    ],
    [
        "GROOVY-1559",
        "GROOVY-6524",
        "MissingMethodException should report whether the missing method is static or not MissingMethodException should report whether the missing method is static or not",
        "Implicit closure coercion conflicts with DGM methods in type checked mode The problem is highlighted with Java 8, where a {{Collection.sort(Comparator)}} method has been added. Given the following code:\n\n{code}\nlist.sort { a,b -> a<=>b }\n{code}\n\nwhich takes a closure, then the type checker chooses the default method from {{Collection}}, {{Collection.sort(Comparator)}} because an implicit coercion of {{Closure}} to {{Comparator}} is possible.\n\nHowever, there's a {{DGM#sort(Collection,Closure)}} method which should have been preferred.\n\nThe result is a build failure as seen in http://148.251.23.208:8111/viewLog.html?buildId=35&tab=buildResultsDiv&buildTypeId=Groovy_Jdk8Build"
    ],
    [
        "GROOVY-756",
        "GROOVY-4666",
        "improve GroovyShell This is a meta task. This means this task should not be closed nor is it for error reporting, wishes or improvements. If you have any of them related to this task please fill a normal issue and link it to this.",
        "support @Composite annotations I'd like to see Groovy support an @Composite annotation that is just a facade on a bunch of other annotations. \n\nThis was a Project Coin proposal at one point, and Spring has this type of functionality. \nIt sounds fairly easy to write as an AST Transformation. \n\nExample: \nYour class has something like this: \n{code}\n@groovy.transform.ToString\n@groovy.transform.Immutable\n@com.example.MyXForm('someparam')\nclass Person {\n    String firstName\n}\n{code}\n\nThen you can define a composite annotation somewhere: \n{code}\n@Composite  \n@groovy.transform.ToString\n@groovy.transform.Immutable\n@com.example.MyXForm('someparam')\n@Target(TYPE)  \npublic @interface MyStandardBean  {    \n}\n{code}\n\nThen your original code can be simplified to: \n{code}\n@MyStandardBean\nclass Person {\n    String firstName\n}\n{code}\nAnd the compiler gives this Person class a ToString, Immutable, and MyXForm annotations. \n\nFor other examples, see: http://kingsfleet.blogspot.com/2010/04/composite-annotations.html"
    ],
    [
        "GROOVY-1329",
        "GROOVY-6550",
        "handle null more gracefully in switch/case allow\n\nswitch(null) {\n    case null : ...\n}\n\nwithout throwing exceptions",
        "VerifyError when instantiating class that has Java 8 default method in its ancestry I've created a simple repro here: https://bitbucket.org/marshallpierce/java8-groovy-verifyerror \n\nThe README has full details; I'll copy a trimmed version here.\n\nIt looks like every available groovy version (1.8.9, 2.0.8, 2.1.9, 2.2.1) all have issues with generating bytecode for classes that extend interfaces that have default method implementations (new in Java 8).\n\nUnder Java 7, `./gradlew clean build` succeeds. Under Java 8, it fails with a VerifyError:\n\n{code}\njava.lang.VerifyError: (class: org/mpierce/groovy/GroovySetSubclass, method: super$1$parallelStream signature: ()Ljava/util/stream/Stream;) Illegal use of nonvirtual function call\n\tat java.lang.Class.forName0(Native Method)\n\tat java.lang.Class.forName(Class.java:259)\n\tat org.mpierce.groovy.GroovySetSubclassTest.class$(GroovySetSubclassTest.groovy)\n\tat org.mpierce.groovy.GroovySetSubclassTest.$get$$class$org$mpierce$groovy$GroovySetSubclass(GroovySetSubclassTest.groovy)\n\tat org.mpierce.groovy.GroovySetSubclassTest.testGroovySubclass(GroovySetSubclassTest.groovy:9)\n{code}\n\nGroovySetSubclass is a trivial subclass of HashSet. Java analogs are "
    ],
    [
        "GROOVY-462",
        "GROOVY-4226",
        "ClassGenerator patches for a few VerifyErrors, primitive uses as parameters and local vars I have taken a few days to study the various bugs that seemed to be associated with bad bytecode. The bugs fell under two groups:\n\n1. Primitives used as function/closure parameters and local variables. \n\n2. Scope introducing constructs in clsures, such as if, switch and while. Those constructs would generate inconsistent stack height. \n\nOther related problems were\n\n-- +=\n-- return void from functions\n-- bad constructor bytecode for scripts\n\nAfter some hair-pulling and losing time with JVM spec, disassemblers and decompilers, I believe most of these problems are gone with the patches attached here. \n\nI also have created a test case that tests the above issues (see ClassGeneratorFixes.groovy)\n\nAmong the changes in the ClassGenerator are:\n\n-- reflowing the code to create fields. \n-- tuning the primitive types hanlding\n-- setting optionl attributes to generate better looking decompiled \ncode. (now I can get clean JAD decompiled source files with realtively simple groovy code)\n-- adding variables to localVariableTable to provide better debugging info in the bytecode. \n-- renaming some local variables to avoid warnings from compiler about hiding instance variables. \n\n\n\nA couple of helper functions were added to related classes and the patches are in the attached patch files. \n\nI have run all the changes through a full maven build and test (with the latest code from CVS HEAD) and came out clean. \n\nNoticing that some of these bugs are really critical for releasing groovy as version 1, I thought I'd uploaded these patches for other developers to test them and imrpove them. \n\nThanks.",
        "Autoconverting [\"aa\",\"bb\"] to String[] fails I have following code\n\ndef marshaller = new org.springframework.oxm.jaxb.Jaxb2Marshaller()\nmarshaller.setContextPaths ([\"com.foois.ws.whois\",\"com.foois.ws.types\"])\n\nit should work setContextPaths takes one String[] argument and Groovy should autoconvert to it.\n\nBut conversion fails with Exception Message: [Ljava.util.ArrayList; cannot be cast to java.util.List\n"
    ],
    [
        "GROOVY-3071",
        "GROOVY-3041",
        "include example of observing and editing compilation phase during class loading I've attached an example of observing the compilation process. \nThis came out of the discussion here: http://www.nabble.com/Groovy-as-arithmetic-expression-evaluator--to19459935.html\n\nThis example code is in /src/examples/groovyShell\n\nThe class is called ArithmeticShell. \"The arithmetic shell is similar to a GroovyShell in that it can evaluate text as code and return a result. It is not a subclass of GroovyShell because it does not widen the contract of GroovyShell, instead it narrows it. Using one of these shells like a GroovyShell would result in many runtime errors.\" It should how to observe the compilation process and how to walk the AST. \n\nI did not do a static import on java.lang.Math because it was a hassle to test. I did not extend CodeVisitorSupport for reasons stated in the Javadoc. \n\nIt includes a GroovyTestCase but does _not_ include an Ant script to build it. \n\nPerhaps this can help someone. ",
        "Support for adding default imports It would be nice if users could customize the default imports by adding packages."
    ],
    [
        "GROOVY-5626",
        "GROOVY-5648",
        "Remove buildSrc's target and .gradle directories from the source distribution The source distribution package contains the buildSrc/target directory as well as the buildSrc/.gradle directory.\n\nBoth should be removed.",
        "Close Issue update does not work without problems:\n\nMutableIssue mutableParentIssue = issueManager.getIssueObject(id);\nmutableParentIssue.setEstimate(120);\nissueManager.updateIssue(mutableParentIssue.getAssignee(), mutableParentIssue, EventDispatchOption.ISSUE_UPDATED, false)\n\ndoesn\u00c2\u00b4t work:\n\nMutableIssue mutableParentIssue = issueManager.getIssueObject(id);\nmutableParentIssue.setStatusId(\"6\"); // closed\nissueManager.updateIssue(mutableParentIssue.getAssignee(), mutableParentIssue, EventDispatchOption.ISSUE_UPDATED, false)\n\nwhy?"
    ],
    [
        "GROOVY-3793",
        "GROOVY-80",
        "unable to resolve class when multiple classes in the same script Sdklib.groovy :\n\npackage odilib\npublic class Sdklib extends Framework {\ndef test() {\n  throw new ObjectAlreadyExists ('some text')\n} \n}\npublic class ObjectAlreadyExists extends Exception {}\n=========================================\n\nmy_script.groovy :\n\nimport odilib.*\ndef x = new Sdklib ()\ntry { x.test() } catch (ObjectAlreadyExists e) {}\n\nRun as :\n\ngroovy my_script.groovy\n\nError :\n\norg.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed, my_script.groovy: xx: unable to resolve class ObjectAlreadyExists\n @ line xx, column 5.\n     } catch (ObjectAlreadyExists e) {\n       ^\n\n1 error\n\nAs you could see, Sdklib.groovy has 2 classes that belong to package odilib, the second one defines exception.\nFrom the outside script the first class named after the script Sdklib is visible, but not the second one corresponding to the exception. \n",
        "Add neater python style import statements I do wish Groovy would add some extra (Python like) syntax sugar for less verbose imports, along the lines of: \n\nimport Xxxxx, Yyyyy, Zzzz from java.util; \n\nor \n\nfrom java.util import Xxxxx, Yyyyy, Zzzzz;"
    ],
    [
        "GROOVY-7548",
        "GROOVY-5102",
        "@Grab should provide a way to set system properties @Grab provides no mechanism for setting system properties which might be required for downloading dependencies via SSL or a proxy. With an increasing number of services moving to the cloud, this greatly reduces the usefulness of scripts to enterprise organizations. Such a mechanism could easily be added by adding an extra attribute, e.g. {{systemProperties}} to @GrabConfig and supplying a constant list of property name, property value pairs.",
        "Unrelated changes cause BigDecimal division to return Double In Groovy 1.8.3 the first test passes while the second fails.  The return type of the second operation (and third, if it were to get to it) becomes a Double.\n\nThe tests both pass in 1.8.2.\n\n{code}\nclass BigDecimalTest extends GroovyTestCase{\n    public void testMath1() {\n        assert BigDecimal == (3/2).getClass()\n        assert BigDecimal == (7.0/8.0).getClass()\n        assert BigDecimal == (new BigDecimal(3.0)/new BigDecimal(2.0)).getClass()\n        true\n    }\n\n    public void testMath2() {\n        assert BigDecimal == (3/2).getClass()\n        assert BigDecimal == (7.0/8.0).getClass()\n        assert BigDecimal == (new BigDecimal(3.0)/new BigDecimal(2.0)).getClass()\n    }\n}\n{code}"
    ],
    [
        "GROOVY-1335",
        "GROOVY-5394",
        "AntBuilder doesn't instantiate Tasks the Ant way AntBuilder instantiates task objects directly whereas Ant creates in a first time UnknownElement and RuntimeConfigurable to really create and configure the tasks when they are executed. Tasks may ask these classes to know how they have been configured what is not currently possible using the AntBuilder.\n\nProposed patch (not in unified diff format as my computer can't access cvs) removes all the instantiation logic to call the Handler Ant uses when it parses an xml file. This reduces drastically the complexity and ensures that the AntBuilder doesn't reinvent the wheel.\n\nProvided unit tests compare the execution of the AntBuilder and the one of Ant to ensure that expectations are correct.\n\nFileScanner is promoted to a real Ant task to make it better fit in the AntBuilder.\n\nPatch fixes Issues 824 too (http://jira.codehaus.org/browse/GROOVY-824) (unit test included),\n",
        "Grape's Grab ignores 'ext' when classifier is not set The value of ext (and also type) in Grab is only taken into account if classifier is set, I believe this to be a mistake. For example Grape cannot be used to retrieve the following artifact, which has packaging=orbit but an artifact with the extension .jar:\n{code}\n@Grab(group='org.eclipse.jetty.orbit', module='javax.servlet', version='3.0.0.v201112011016', ext='jar')\n{code}\nTherefore Grab should respect the value of ext even if classifier is not set. (And in any case it should at least report that there are some arguments that are ignored.)\n\nSteps to reproduce:\n{code}\n$ groovysh\ngroovy:000> org.apache.ivy.util.Message.setDefaultLogger(new org.apache.ivy.util.DefaultMessageLogger(org.apache.ivy.util.Message.MSG_DEBUG));\ngroovy:000> groovy.grape.Grape.grab(autoDownload: true, group: 'org.eclipse.jetty.orbit', module: 'javax.servlet', version: '3.0.0.v201112011016', ext: 'jar')\n{code}\nSee https://github.com/groovy/groovy-core/blob/master/src/main/groovy/grape/GrapeIvy.groovy#L298"
    ],
    [
        "GROOVY-6169",
        "GROOVY-6578",
        "Compiler loses import for slf4j logger factory. There are several components involved here, but the symptoms point to the Groovy compiler.  Gradle uses BND to populate the OSGi 'Import-Package' manifest header.  The import from Groovy source is lost and does not appear in the OSGi manifest.  This causes problems when deploying the bundle to OSGi.\n\nThere's a repro package attached.  It includes two Gradle projects, one using Java, one using Groovy.  They use the same source file contents, but with different file types.  They produce different manifest files, one that imports slf4j and one that doesn't.\n\nYou can tweak the build.gradle to use different Groovy releases.  I first discovered this problem using v1.8.7, but saw the same results with v1.8.9.  The problem was apparently fixed in v2.1, using a groovy-all-2.1.0 a correct manifest file is created.\n",
        "Groovyc compiler significantly slower than groovy-elcipse compiler We have a large multi-module maven project that uses a mixture of java and groovy. We tried switch to the groovyc compiler so that we could use the latest version and indy. We have been using the groovy-eclipse compiler. \n\nWe noticed a horrible performance degradation with our build system when we made the change and were forced to switch back to the groovy-eclipse compiler.  It took about 7 minutes using groovyc vs 1 minute to build using groovy-eclipse. \n\nIt would be great if you could improve the performance of the compiler. Here was our maven configuration for it in case we had something misconfigured.\n\n<plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-antrun-plugin</artifactId>\n                <version>1.7</version>\n                <executions>\n                    <execution>\n                        <id>compile</id>\n                        <phase>compile</phase>\n                        <configuration>\n                            <target>\n                                <mkdir dir=\"${basedir}/src/main/java\"/>\n                                <taskdef name=\"groovyc\"\n                                         classname=\"org.codehaus.groovy.ant.Groovyc\">\n                                    <classpath refid=\"maven.compile.classpath\"/>\n                                </taskdef>\n                                <mkdir dir=\"${project.build.outputDirectory}\"/>\n                                <groovyc destdir=\"${project.build.outputDirectory}\"\n                                         includeJavaRuntime=\"true\"\n                                         memoryMaximumSize=\"512M\"\n                                         srcdir=\"${basedir}/src/main/java/\"\n                                         listfiles=\"false\"\n                                         indy=\"false\">\n                                    <classpath refid=\"maven.compile.classpath\"/>\n                                    <javac source=\"${javac}\" target=\"${javac}\" debug=\"off\" />\n                                </groovyc>\n\n                            </target>\n                        </configuration>\n                        <goals>\n                            <goal>run</goal>\n                        </goals>\n                    </execution>\n                    <execution>\n                        <id>test-compile</id>\n                        <phase>test-compile</phase>\n                        <configuration>\n                            <target>\n                                <mkdir dir=\"${basedir}/src/test/java\"/>\n                                <taskdef name=\"groovyc\"\n                                         classname=\"org.codehaus.groovy.ant.Groovyc\">\n                                    <classpath refid=\"maven.test.classpath\"/>\n                                </taskdef>\n                                <mkdir dir=\"${project.build.testOutputDirectory}\"/>\n                                <groovyc destdir=\"${project.build.testOutputDirectory}\"\n                                         srcdir=\"${basedir}/src/test/java/\"\n                                         includeJavaRuntime=\"true\"\n                                         memoryMaximumSize=\"512M\"\n                                         listfiles=\"false\"\n                                         indy=\"false\">\n                                    <classpath refid=\"maven.test.classpath\"/>\n                                    <javac source=\"${javac}\" target=\"${javac}\" debug=\"off\" />\n                                </groovyc>\n                            </target>\n                        </configuration>\n                        <goals>\n                            <goal>run</goal>\n                        </goals>\n                    </execution>\n                </executions>\n</plugin>\nThank you "
    ],
    [
        "GROOVY-2303",
        "GROOVY-2902",
        "Upgrading to Groovy 1.1 final snapshot causes LinkageError in Grails I have a clean Grails project with the following changeset where the Groovy jar is the latest build of 1.1 final:\n\nthe project i have has the following svn changeset\nA      lib/groovy-all-1.1-final-SNAPSHOT.jar\nD      lib/groovy-all-1.1-rc-1.jar\nM      bin/startGrails\n\nWhen I run any Gant script in Grails (such as grails list-plugins) that depends on a W3C DOM class i get the error\n\n{code}\njava.lang.LinkageError: Class org/w3c/dom/UserDataHandler violates loader constraints\n   at java.lang.ClassLoader.defineClass1(Native Method)\n   at java.lang.ClassLoader.defineClass(ClassLoader.java:675)\n   at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:124)\n   at java.net.URLClassLoader.defineClass(URLClassLoader.java:260)\n   at java.net.URLClassLoader.access$100(URLClassLoader.java:56)\n   at java.net.URLClassLoader$1.run(URLClassLoader.java:195)\n   at java.security.AccessController.doPrivileged(Native Method)\n   at java.net.URLClassLoader.findClass(URLClassLoader.java:188)\n   at org.codehaus.groovy.tools.RootLoader.oldFindClass(RootLoader.java:142)\n   at org.codehaus.groovy.tools.RootLoader.loadClass(RootLoader.java:114)\n   at java.lang.ClassLoader.loadClass(ClassLoader.java:251)\n   at java.lang.ClassLoader.loadClassInternal(ClassLoader.java:374)\n   at java.lang.Class.getDeclaredMethods0(Native Method)\n   at java.lang.Class.privateGetDeclaredMethods(Class.java:2395)\n   at java.lang.Class.getDeclaredMethods(Class.java:1763)\n   at org.codehaus.groovy.reflection.CachedClass.getMethods(CachedClass.java:131)\n   at groovy.lang.MetaClassImpl.populateMethods(MetaClassImpl.java:238)\n   at groovy.lang.MetaClassImpl.fillMethodIndex(MetaClassImpl.java:217)\n   at groovy.lang.MetaClassImpl.initialize(MetaClassImpl.java:2380)\n   at groovy.lang.ExpandoMetaClass.initialize(ExpandoMetaClass.java:355)\n   at org.codehaus.groovy.runtime.metaclass.MetaClassRegistryImpl.getMetaClass(MetaClassRegistryImpl.java:164)\n   at org.codehaus.groovy.runtime.Invoker.getProperty(Invoker.java:172)\n   at org.codehaus.groovy.runtime.InvokerHelper.getProperty(InvokerHelper.java:157)\n   at org.codehaus.groovy.runtime.ScriptBytecodeAdapter.getProperty(ScriptBytecodeAdapter.java:500)\n   at ListPlugins_groovy.run(ListPlugins_groovy:61)\n{code}\n\nIt appears to originate from a MetaClass look-up. This was not a problem before upgrading Groovy.",
        "StreamingSAXBuilder fails on attribute values with type other than String StreamingSAXBuilder fails if an attribute value has a type other than String. Changed tagClosure the way that it now calls attributes.addAttributes() with value being of type String."
    ],
    [
        "GROOVY-5203",
        "GROOVY-6378",
        "Strange parse conventions for dollar-slashy strings These code snippets run well:\n{code}\n$/abc/$\n{code}\n{code}\nfoo 1, $/abc/$\n\ndef foo(a, b){}\n{code}\n{code}\ndef $a = 2\nfoo $a\n\nfoo(a){}\n{code}\n\nWhy does this code fail on compilation?\n{code}\nfoo $/abc/$, 1\ndef foo(a, b){}\n{code}",
        "Assignment of values from Map to another causes \"Incompatible generic argument types.\" when using @TypeChecked The following script causes a compilation error since Groovy 2.2.\n\nThe error occurs as soon as you start putting 'mixed' types in the Maps (e.g. Integer and String). I checked it again in Groovy 2.1.3 and it compiled fine.\n\n{code}\nimport groovy.transform.TypeChecked\n\n@TypeChecked\ndef myFunction() {\n  Map mapA=[e:1,et:'Error',ev:'Hello']\n  Map mapB=[e:0,et:'No Error',ev:'World']\n  \n  mapB.e=mapA.e  \n\n// causes compilation error: [Static type checking] - Incompatible generic argument types. Cannot assign java.io.Serializable <? extends java.io.Serializable> to: java.io.Serializable <? extends java.io.Serializable>\n\n  println \"${mapB.e}\"\n}\n\nmyFunction()\n{code}"
    ],
    [
        "GROOVY-5497",
        "GROOVY-6511",
        "Returning \"null\" in a function reports an invalid type checking error The following code is valid, but it reports some compilation errors:\n\n{code}\n@groovy.transform.CompileStatic\nclass Test {\n \n  List getList() {\n    null\n  }\n  \n}\n{code}\n\n\n1 compilation error:\n\n[Static type checking] - Cannot return value of type java.lang.Object on method returning type java.util.List -> java.util.List <E extends java.lang.Object -> java.lang.Object>\n at line: 5, column: 5\n",
        "Illegal use of non virtual function call when compiling with JDK 8 When compiling Groovy with JDK 8, lots of tests fail with \"Illegal use of non virtual function call\", due to the introduction of virtual extension methods."
    ],
    [
        "GROOVY-4830",
        "GROOVY-7197",
        "GroovyConsole: Decompiled View should show method and class annotations GroovyConsole: Decompiled View should show method and class annotations\nCUrrently it does not show the annotations. ",
        "Strange behaviour during parent() method invocation on the non existent node (XmlSlurper). I've migrated from Grails 2.2.5 (Groovy 2.0.8) to Grails 2.4.4 (Groovy 2.3.7) and some of my tests related to XmlSlurper start fail. \n\nMaybe it's normal behavior for now, but doesn't look so. Here is an simple example which easily can be run in groovy console. \n{code:java}\ndef testedXml = '''\n<a>\n  <b>\n    <c>some cool text</c>\n  </b>\n</a>\n'''\n\ndef root = new XmlSlurper().parseText(testedXml)\n\ndef dNode = root.b.c.d\n\n//Use-case #1\nassert dNode.isEmpty()\nassert dNode.parent().name() == 'c'\ndef cNode = dNode.parent()\nassert cNode.name() == 'c'\n// assume that node 'c' has node 'b' as parent\nassert cNode.parent().name() == 'b' // FAILED!\n\n//Use-case #2\n// Even if we try to convert from NodeParents to exect node.\ncNode = dNode.parent().getAt(0)\nassert cNode.name() == 'c'\n// assume that parent for node 'c' is 'b'\nassert cNode.parent().name() == 'b'// FAILED!\n{code}"
    ],
    [
        "GROOVY-2702",
        "GROOVY-3312",
        "Duplicated promt in groovysh I am trying to run Groovy Shell from Eclipse.\nIt prints:\nGroovy Shell (1.6-beta-1-SNAPSHOT, JVM: 1.6.0_03-b05)\nType 'help' or '\\h' for help.\n-------------------------------------------------------------------------------\ngroovy:000>\n\nThen I enter any expression, and shell displays:\n\nGroovy Shell (1.6-beta-1-SNAPSHOT, JVM: 1.6.0_03-b05)\nType 'help' or '\\h' for help.\n-------------------------------------------------------------------------------\ngroovy:000> 1==2\n===> false\ngroovy:000> groovy:000>\n\n\nThe last promt is duplicated.\n\nYou can reproduce this behaviour if you run groovy with following parameters:\n$ groovysh --terminal=none --color=false",
        "java.lang.SecurityException: Prohibited package name: java.rmi I get the a package prohibited error when executing the following script:\n{code}\nimport groovyx.net.ws.WSClient\n\nprintln 'Creating proxy for service' \ndef testProxy = new WSClient(\"http://localhost:9080/ws/services/WSDHZSProductService?wsdl\", this.class.classLoader)\n\ndef aesClient = testProxy.create()\n\n//aesClient.retrieveCP()\n\n//aesClient.metaClass.methods.each {\n //println it\n//}\n\nprintln 'done'\n{code}\n\n( I don't know how to access the local file (shame shame), so I'll hope this will be sufficient to reproduce)\n"
    ],
    [
        "GROOVY-3887",
        "GROOVY-2121",
        "Convert varargs to list Groovy has lots of methods to use with lists that can't be used with arrays. When I declare a function using varargs, internally I get an array with all args. In most cases I will convert it to a list to use one of the many groovy functions for collections:\n\n{code}\nstatic int sum(...nums) {\t\n\treturn nums.toList().sum(); //nums is an array. I have to convert to list\n}\n{code}\n\nI think it would be a nice idea to convert the array into a list automatically (only when using varargs, not when I explicitly declare an array):\n\n{code}\nstatic int sum(...nums) {\t\n\treturn nums.sum(); //nums is a list\n}\n{code}\n\nThere may be some cases when I need an array, but I think they are a minority. In that cases I may use the .toArray() method",
        "change the groovyc ant task to enable embedding the javac ant task instead of using the jointCompilation property and providing the options for the compiler in a command line like manner it would be nice to be able to reuse the ant javac task to run the joint compilation process.\n\nExample \n{code:xml}\n<groovyc srcdir=\"${testSourceDirectory}\" destdir=\"${testClassesDirectory}\">\n  <javac source=\"1.4\" target=\"1.4\"/>\n</groovyc>\n{code}"
    ],
    [
        "GROOVY-3254",
        "GROOVY-3384",
        "code clean up in 1.7 ",
        "XML NodeList.add(index, Node) does not work as expected The following test fails - the new node is always inserted at the end of the list\n\n{noformat}\ndef xml = \"<parent><child id=\\\"1\\\"/></parent>\"\ndef parent = new XmlParser().parseText(xml)\ndef node = new Node(parent, \"child\", [id:\"2\"])\nparent.child.add(0, node)\nassert parent.child[0] == node\n{noformat}\n\nThe following test fails too - In this case, the second assertions fails - the node is inserted twice!\n\n{noformat}\ndef xml = \"<parent><child id=\\\"1\\\"/></parent>\"\ndef parent = new XmlParser().parseText(xml)\ndef node = new Node(parent, \"child\", [id:\"2\"])\nparent.children().add(0, node)\nassert parent.children()[0] == node\nassert parent.children()[2] != node\n{noformat}"
    ],
    [
        "GROOVY-5648",
        "GROOVY-2370",
        "Close Issue update does not work without problems:\n\nMutableIssue mutableParentIssue = issueManager.getIssueObject(id);\nmutableParentIssue.setEstimate(120);\nissueManager.updateIssue(mutableParentIssue.getAssignee(), mutableParentIssue, EventDispatchOption.ISSUE_UPDATED, false)\n\ndoesn\u00c2\u00b4t work:\n\nMutableIssue mutableParentIssue = issueManager.getIssueObject(id);\nmutableParentIssue.setStatusId(\"6\"); // closed\nissueManager.updateIssue(mutableParentIssue.getAssignee(), mutableParentIssue, EventDispatchOption.ISSUE_UPDATED, false)\n\nwhy?",
        "1.5 Causes StackOverflowError with Ant Java Task After call of groovy-Task, java-Task fails with StackOverflowError.\nExample is attached."
    ],
    [
        "GROOVY-5024",
        "GROOVY-1536",
        "Reduce groovyc command line length On Windows, the command line length is restricted to 32Kb or somesuch.\n\nFileSystemCompiler builds a command line that includes the classpath twice, which makes it prone to failure on Windows. See http://issues.gradle.org/browse/GRADLE-1420\n\nThe attatched patch reduces the problem by passing one of the classpath strings via the CLASSPATH environment variable instead of the -cp argument.\n\nA further improvement would be to add @-handling to FileSystemCompiler's --classpath argument parser.",
        "I added some additional tests for the GString class I added some additional tests to GStringTest.groovy and GStringTest.java.  \n\nI also added an additional GStringMockTest.java which extends org.jmock.MockObjectTestCase and uses jMock to test GString.build(). \n\nI made a few minor changes to GString.java.  \n\nI made it return and store a copy of its \"values\" array instead of storing the array passed in and returning the internal array from getValues().  The expected behavior wasn't documented, but this way seems better to me for a few reasons.  A user can't unintentionally modify a GString by storing the a different value in the value array after creating a GString.  It also allows for the internal implementation to change more easily in the future.  Instead of storing an array of values, for example, it could use an ArrayList, etc., and only convert to an array in getValues().  If users are expecting to be able to directly modify the contents of the array, this kind of change is difficult to make.\n\nI checked the source, and the only class using GString.getValues() is groovy.sql.Sql.getParameters(), and it is not trying to change the contents of the values array.  Since getValues() is so rarely used, an alternative might be to make Sql.getParameters() call GString.getValue(int) and deprecate GString.getValues().\n\nI also added some additional JavaDoc and a little argument validation to GString.java.\n\n"
    ],
    [
        "GROOVY-4645",
        "GROOVY-108",
        "Convariant returns causes compiler to fail when generating property getters When attempting to compile the following groovy code I get the compiler error under groovy 1.7.6 and 1.8.3-beta-3.  This has to do with defining an interface (or class) with getters and then defining properties (or final members variables) on a subclass using covariant returns.  I can work around this issue by explicitly defining the required getter in the subclass which is rather annoying b/c I like groovy getter generation and in our codebase we are running into this a lot.  This is also a problem when using \"def\" types.  I would be glad to assist in any way if I can.  Thanks.\n\n\nFor example:\n{code}\ninterface CovariantReturns {\n  Foo getGood()\n  Object getBad()\n}\n\nclass Foo {}\n\nclass CovariantReturnsImpl implements CovariantReturns {\n  //getter is generated by groovy as required by the interface\n  final Foo good\n\n  //this variable is defined as the subtype of Object\n  final Foo bad\n\n  /*\n   I would expect that the following method would be generated by groovy\n   which is using Java's covariant returns feature.  Including the method below\n   will allow the groovy compiler to succeed but is annoying that it has to be explicitly\n   defined in code.\n\n   public Foo getBad() { return bad }\n   */\n}\n{code}\n\n{noformat}\norg.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed:\nCovariantReturns.groovy: 8: Can't have an abstract method in a non-abstract class. The class 'CovariantReturns\nImpl' must be declared abstract or the method 'java.lang.Object getBad()' must be implemented.\n @ line 8, column 1.\n   class CovariantReturnsImpl implements CovariantReturns {\n   ^\n\n1 error\n{noformat}\n",
        "Profile the compiler - somethings really slowed down We should profile the compiler and look for hotspots. It looks like somethings really slowed down lately & uses lots of CPU and about 2 minutes to compile all the test cases.\n\nThis should be pretty fast - would be nice to fix."
    ],
    [
        "GROOVY-2583",
        "GROOVY-3533",
        "\"object is not an instance of declaring class\" thrown invoking a method on Groovy class, wrapped in a Spring proxy I suspect this is connected with GROOVY-2006, here is the case:\nI have two Spring-loaded groovy scripts, marked with refresh-check-delay, which loads them as CGLIB proxies. Invoking a method on the proxy instance, I get \n{code:none}\nException in thread \"main\" java.lang.IllegalArgumentException: object is not an instance of declaring class\n        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n        at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)\n        at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)\n        at java.lang.reflect.Method.invoke(Unknown Source)\n        at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:86)\n        at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:226)\n        at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:899)\n        at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:740)\n        at org.codehaus.groovy.runtime.InvokerHelper.invokePogoMethod(InvokerHelper.java:777)\n        at org.codehaus.groovy.runtime.InvokerHelper.invokeMethod(InvokerHelper.java:757)\n        at org.codehaus.groovy.runtime.ScriptBytecodeAdapter.invokeMethodN(ScriptBytecodeAdapter.java:167)\n        at org.codehaus.groovy.runtime.ScriptBytecodeAdapter.invokeMethod0(ScriptBytecodeAdapter.java:195)\n        at X.doIt(script1.groovy]:5)\n        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n        at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)\n        at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)\n        at java.lang.reflect.Method.invoke(Unknown Source)\n        at org.springframework.aop.support.AopUtils.invokeJoinpointUsingReflection(AopUtils.java:301)\n        at org.springframework.aop.framework.ReflectiveMethodInvocation.invokeJoinpoint(ReflectiveMethodInvocation.java:182)\n        at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:149)\n        at org.springframework.aop.support.DelegatingIntroductionInterceptor.doProceed(DelegatingIntroductionInterceptor.java:131)\n        at org.springframework.aop.support.DelegatingIntroductionInterceptor.invoke(DelegatingIntroductionInterceptor.java:119)\n        at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:171)\n        at org.springframework.aop.framework.JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:204)\n        at $Proxy1.doIt(Unknown Source)\n        at TestMe.main(TestMe.java:20)\n{code}\n\n{code:title=script1.groovy}\nclass X implements Doable {\n    def prop\n    void doIt() {\n        println prop.getClass().getName();\n        prop.doIt(); \n    }\n}\n{code}\n\n{code:title=script2.groovy}\nclass Y {\n    void doIt() { println \"OK\"; }\n}\n{code}\n\n{code:title=Doable.java}\npublic interface Doable {\n    void doIt();\n}\n{code}\n\n{code:xml|title=spring.xml}\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:lang=\"http://www.springframework.org/schema/lang\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd\n       http://www.springframework.org/schema/lang http://www.springframework.org/schema/lang/spring-lang-2.5.xsd\">\n    \n    <lang:groovy id=\"y\" script-source=\"classpath:groovy/script2.groovy\" refresh-check-delay=\"1000\"/>\n    <lang:groovy id=\"x\" script-source=\"classpath:groovy/script1.groovy\" refresh-check-delay=\"1000\">\n        <lang:property name=\"prop\" ref=\"y\"/>\n    </lang:groovy>\n</beans>\n{code}\n\n{code:title=TestMe.java}\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\npublic class TestMe {\n    public static void main(String[] args) {\n        ClassPathXmlApplicationContext ctxt = new ClassPathXmlApplicationContext(\"spring.xml\");\n        Doable o = (Doable)ctxt.getBean(\"x\");\n        o.doIt();\n    }\n}\n{code}\n",
        "GroovyConsole AST Viewer does not display the accessedVariable property of Variable nodes VariableExpression nodes have a field called accessedVariable. The field is of type ASTNode. \n\nThe GroovyConsole ASTViewer does not display this field in the tree pane, you can only see the toString form of the field in the table. \n\nYou can  reproduce this by viewing the ast for this script: \n\n  foo = \"\"\n\nWhich creates a DynamicVariable in the VariableExpression's accessedVariable field. \n\nA junit test case should be simple to create. "
    ],
    [
        "GROOVY-2193",
        "GROOVY-78",
        "Method invocation that returns no value should evaluate to a known constant instead of null Currently, a method invocation that returns no value evaluates to null. But sometimes it's important to know whether the method actually returned a value or not (e.g. DSLs come to mind). Therefore I propose that method invocations that return no value evaluate to a known constant (e.g. Constants.NO_RETURN_VALUE) instead of null. Apart from making the language more consistent, this would fit in nicely with Groovy's dynamic style, where the return type of a method is generally not known at compile time, and a method might only sometimes return a value.\n\nRelated discussions on the mailing list:\nhttp://www.nabble.com/Void-the-same-as-null--tf3535287.html#a9867884\nhttp://www.nabble.com/Ways-to-differentiate-between-methods-that-return-nothing%2C-and-methods-that-return-null-tf4574659.html#a13057848",
        "create a single uber-jar with all the stuff you need to run groovy To make it easier for folks; consider making a groovy-full.jar which includes commons-logging & asm inside it rather like other folks do (e.g. beanshell)."
    ],
    [
        "GROOVY-2262",
        "GROOVY-1001",
        "groovy.lang.MetaClassRegistry$MetaClassCreationHandle.create() causing java.lang.StackOverflowError I was attempting to create a custom delegate class for a third party library. Researching this, I found the following page:\nhttp://docs.codehaus.org/display/GROOVY/Using+the+Delegating+Meta+Class\n\nWhen I tried to follow the \"Package Name Convention Solution\", by creating a FuzzyVariableMetaClass file in groovy.runtime.metaclass.ncr.fuzzyj.FuzzyVariableMetaClass, I got a java.lang.StackOverflowError. This was with no inherited methods. I only created the shell of the class and constructor.\n\nAs a test, I followed the instructions on the page, creating a StringMetaClass as documented on the page. This also gave me the java.lang.StackOverflowError. When I ran this in the Eclipse debugger, the problem appears to occur during the groovy.lang.MetaClassRegistry$MetaClassCreationHandle.create(Class theClass, MetaClassRegistry registry) call.\n\nSpecifically, this method does the following\n--------------------\nfinal Class customMetaClass = Class.forName(\"groovy.runtime.metaclass.\" + theClass.getName() + \"MetaClass\");\n\t           final Constructor customMetaClassConstructor = customMetaClass.getConstructor(new Class[]{MetaClassRegistry.class, Class.class});\n\t           return (MetaClass)customMetaClassConstructor.newInstance(new Object[]{registry, theClass});\n---------------------\nThis calls the constructor on the new MetaClass we are creating, which calls DelegateMetaClass's constructor,  which calls GroovySystem.getMetaClassRegistry().getMetaClass(...),  which calls getMetaClassFor(theClass), which calls metaClassCreationHandle.create(theClass, this), completing the infinite loop.\n\nI have NOT tested this under Groovy 1.0. But I imagine it worked then since the webpage has not been updated since Jan 28, 2007.\n\n------------------------\nI also ran into issues when I tried the \"InvokeHelper Solution \" on the same page. Those errors were different and will be entered as a separate bug.\n\n",
        "Allow junit.framework.TestCase to be run by groovy command Allow junit.framework.TestCase to be run by the groovy command. Currently on groovy.util.GroovyTestCase is supported."
    ],
    [
        "GROOVY-4482",
        "GROOVY-953",
        "Closure.memoize fails on Google App Engine Running the following code on the Groovy Web Console:\n\n{code}\ncl = {a, b ->\n    sleep(3000) // simulate some time consuming processing\n    a + b\n}\nmem = cl.memoize()\n\ndef callClosure(a, b) {\n    def start = System.currentTimeMillis()\n\n    mem(a, b)\n\n    println \"Inputs(a = $a, b = $b) - took ${System.currentTimeMillis() - start} msecs.\"\n}\n\ncallClosure(1, 2)\ncallClosure(1, 2)\ncallClosure(2, 3)\ncallClosure(2, 3)\ncallClosure(3, 4)\ncallClosure(3, 4)\n\ncallClosure(1, 2)\ncallClosure(2, 3)\ncallClosure(3, 4)\n{code}\n(taken from http://roshandawrani.wordpress.com/2010/10/18/groovy-new-feature-closures-can-now-memorize-their-results/)\n\nThrows the following exception (when caught and printed to stdout)\n\n{code}\njava.security.AccessControlException: access denied (java.lang.RuntimePermission accessDeclaredMembers)\n\tat com.google.appengine.runtime.Request.process-<unknown>(Request.java)\n\tat java.security.AccessControlContext.checkPermission(AccessControlContext.java:355)\n\tat java.security.AccessController.checkPermission(AccessController.java:567)\n\tat java.lang.SecurityManager.checkPermission(SecurityManager.java:549)\n\tat java.lang.SecurityManager.checkMemberAccess(SecurityManager.java:1679)\n\tat java.lang.Class.checkMemberAccess(Class.java:2174)\n\tat java.lang.Class.getDeclaredMethods(Class.java:1807)\n\tat java.lang.Class.getEnclosingMethod(Class.java:919)\n\tat sun.reflect.generics.scope.ClassScope.computeEnclosingScope(ClassScope.java:50)\n\tat sun.reflect.generics.scope.AbstractScope.getEnclosingScope(AbstractScope.java:74)\n\tat sun.reflect.generics.scope.AbstractScope.lookup(AbstractScope.java:90)\n\tat sun.reflect.generics.factory.CoreReflectionFactory.findTypeVariable(CoreReflectionFactory.java:109)\n\tat sun.reflect.generics.visitor.Reifier.visitTypeVariableSignature(Reifier.java:165)\n\tat sun.reflect.generics.tree.TypeVariableSignature.accept(TypeVariableSignature.java:43)\n\tat sun.reflect.generics.visitor.Reifier.reifyTypeArguments(Reifier.java:68)\n\tat sun.reflect.generics.visitor.Reifier.visitClassTypeSignature(Reifier.java:138)\n\tat sun.reflect.generics.tree.ClassTypeSignature.accept(ClassTypeSignature.java:49)\n\tat sun.reflect.generics.repository.ClassRepository.getSuperclass(ClassRepository.java:84)\n\tat java.lang.Class.getGenericSuperclass(Class.java:694)\n\tat com.sun.beans.TypeResolver.prepare(TypeResolver.java:274)\n\tat com.sun.beans.TypeResolver.<init>(TypeResolver.java:243)\n\tat com.sun.beans.TypeResolver.resolve(TypeResolver.java:172)\n\tat com.sun.beans.TypeResolver.resolveInClass(TypeResolver.java:93)\n\tat java.beans.FeatureDescriptor.getParameterTypes(FeatureDescriptor.java:385)\n\tat java.beans.MethodDescriptor.setMethod(MethodDescriptor.java:116)\n\tat java.beans.MethodDescriptor.<init>(MethodDescriptor.java:74)\n\tat java.beans.MethodDescriptor.<init>(MethodDescriptor.java:58)\n\tat java.beans.Introspector.getTargetMethodInfo(Introspector.java:1181)\n\tat java.beans.Introspector.getBeanInfo(Introspector.java:408)\n\tat java.beans.Introspector.getBeanInfo(Introspector.java:180)\n\tat groovy.lang.MetaClassImpl$15.run(MetaClassImpl.java:2937)\n\tat java.security.AccessController.doPrivileged(AccessController.java:63)\n\tat groovy.lang.MetaClassImpl.addProperties(MetaClassImpl.java:2935)\n\tat groovy.lang.MetaClassImpl.initialize(MetaClassImpl.java:2918)\n\tat org.codehaus.groovy.reflection.ClassInfo.getMetaClassUnderLock(ClassInfo.java:166)\n\tat org.codehaus.groovy.reflection.ClassInfo.getMetaClass(ClassInfo.java:182)\n\tat org.codehaus.groovy.runtime.metaclass.MetaClassRegistryImpl.getMetaClass(MetaClassRegistryImpl.java:214)\n\tat org.codehaus.groovy.runtime.InvokerHelper.getMetaClass(InvokerHelper.java:751)\n\tat groovy.lang.GroovyObjectSupport.<init>(GroovyObjectSupport.java:32)\n\tat groovy.lang.Closure.<init>(Closure.java:106)\n\tat groovy.lang.Closure.<init>(Closure.java:117)\n\tat org.codehaus.groovy.runtime.memoize.Memoize$1.<init>(Memoize.java:55)\n\tat org.codehaus.groovy.runtime.memoize.Memoize.buildMemoizeFunction(Memoize.java:55)\n\tat groovy.lang.Closure.memoize(Closure.java:530)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:43)\n\tat org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:88)\n\tat groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:233)\n\tat org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:272)\n\tat groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:885)\n\tat org.codehaus.groovy.runtime.callsite.PogoMetaClassSite.call(PogoMetaClassSite.java:39)\n\tat org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:40)\n\tat org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:116)\n\tat org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:120)\n\tat Script1.run(Script1.groovy:7)\n\tat groovy.lang.GroovyShell.evaluate(GroovyShell.java:576)\n\tat groovy.lang.GroovyShell.evaluate(GroovyShell.java:614)\n\tat groovy.lang.GroovyShell.evaluate(GroovyShell.java:585)\n\tat groovy.lang.GroovyShell$evaluate.call(Unknown Source)\n\tat org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:40)\n\tat org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:116)\n\tat org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:124)\n\tat executor.run(executor.groovy:25)\n\tat groovy.util.GroovyScriptEngine.run(GroovyScriptEngine.java:515)\n\tat groovy.servlet.GroovyServlet$1.call(GroovyServlet.java:120)\n\tat org.codehaus.groovy.runtime.GroovyCategorySupport$ThreadCategoryInfo.use(GroovyCategorySupport.java:99)\n\tat org.codehaus.groovy.runtime.GroovyCategorySupport$ThreadCategoryInfo.access$300(GroovyCategorySupport.java:61)\n\tat org.codehaus.groovy.runtime.GroovyCategorySupport.use(GroovyCategorySupport.java:239)\n\tat groovy.servlet.GroovyServlet.service(GroovyServlet.java:129)\n\tat groovyx.gaelyk.GaelykServlet.super$5$service(GaelykServlet.groovy)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:43)\n\tat org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:88)\n\tat groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:233)\n\tat groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:1055)\n\tat org.codehaus.groovy.runtime.ScriptBytecodeAdapter.invokeMethodOnSuperN(ScriptBytecodeAdapter.java:127)\n\tat groovyx.gaelyk.GaelykServlet$_service_closure1.doCall(GaelykServlet.groovy:68)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:43)\n\tat org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:88)\n\tat groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:233)\n\tat org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:272)\n\tat groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:885)\n\tat org.codehaus.groovy.runtime.callsite.PogoMetaClassSite.callCurrent(PogoMetaClassSite.java:66)\n\tat org.codehaus.groovy.runtime.callsite.AbstractCallSite.callCurrent(AbstractCallSite.java:149)\n\tat groovyx.gaelyk.GaelykServlet$_service_closure1.doCall(GaelykServlet.groovy)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:43)\n\tat org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:88)\n\tat groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:233)\n\tat org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:272)\n\tat groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:885)\n\tat groovy.lang.Closure.call(Closure.java:288)\n\tat groovy.lang.Closure.call(Closure.java:282)\n\tat org.codehaus.groovy.runtime.GroovyCategorySupport$ThreadCategoryInfo.use(GroovyCategorySupport.java:111)\n\tat org.codehaus.groovy.runtime.GroovyCategorySupport.use(GroovyCategorySupport.java:250)\n\tat org.codehaus.groovy.runtime.DefaultGroovyMethods.use(DefaultGroovyMethods.java:415)\n\tat org.codehaus.groovy.runtime.dgm$740.invoke(Unknown Source)\n\tat org.codehaus.groovy.runtime.callsite.PogoMetaMethodSite$PogoMetaMethodSiteNoUnwrapNoCoerce.invoke(PogoMetaMethodSite.java:307)\n\tat org.codehaus.groovy.runtime.callsite.PogoMetaMethodSite.callCurrent(PogoMetaMethodSite.java:51)\n\tat org.codehaus.groovy.runtime.callsite.AbstractCallSite.callCurrent(AbstractCallSite.java:153)\n\tat groovyx.gaelyk.GaelykServlet.service(GaelykServlet.groovy:67)\n\tat javax.servlet.http.HttpServlet.service(HttpServlet.java:806)\n\tat org.mortbay.jetty.servlet.ServletHolder.handle(ServletHolder.java:511)\n\tat org.mortbay.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1166)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:43)\n\tat org.codehaus.groovy.runtime.callsite.PojoMetaMethodSite$PojoCachedMethodSiteNoUnwrapNoCoerce.invoke(PojoMetaMethodSite.java:229)\n\tat org.codehaus.groovy.runtime.callsite.PojoMetaMethodSite.call(PojoMetaMethodSite.java:52)\n\tat org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:128)\n\tat groovyx.gaelyk.routes.RoutesFilter.doFilter(RoutesFilter.groovy:156)\n\tat org.mortbay.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1157)\n\tat org.mortbay.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1157)\n\tat org.mortbay.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1157)\n\tat org.mortbay.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1157)\n\tat org.mortbay.jetty.servlet.ServletHandler.handle(ServletHandler.java:388)\n\tat org.mortbay.jetty.security.SecurityHandler.handle(SecurityHandler.java:216)\n\tat org.mortbay.jetty.servlet.SessionHandler.handle(SessionHandler.java:182)\n\tat org.mortbay.jetty.handler.ContextHandler.handle(ContextHandler.java:765)\n\tat org.mortbay.jetty.webapp.WebAppContext.handle(WebAppContext.java:418)\n\tat org.mortbay.jetty.handler.HandlerWrapper.handle(HandlerWrapper.java:152)\n\tat org.mortbay.jetty.Server.handle(Server.java:326)\n\tat org.mortbay.jetty.HttpConnection.handleRequest(HttpConnection.java:542)\n\tat org.mortbay.jetty.HttpConnection$RequestHandler.headerComplete(HttpConnection.java:923)\n\tat org.mortbay.jetty.HttpConnection.handle(HttpConnection.java:404)\n\tat com.google.net.rpc.impl.BlockingApplicationHandler.handleRequest(BlockingApplicationHandler.java:24)\n\tat com.google.net.rpc.impl.RpcUtil.runRpcInApplication(RpcUtil.java:418)\n\tat com.google.net.rpc.impl.Server$RpcTask.runInContext(Server.java:572)\n\tat com.google.tracing.TraceContext$TraceContextRunnable$1.run(TraceContext.java:448)\n\tat com.google.tracing.TraceContext.runInContext(TraceContext.java:688)\n\tat com.google.tracing.TraceContext$AbstractTraceContextCallback.runInInheritedContextNoUnref(TraceContext.java:326)\n\tat com.google.tracing.TraceContext$AbstractTraceContextCallback.runInInheritedContext(TraceContext.java:318)\n\tat com.google.tracing.TraceContext$TraceContextRunnable.run(TraceContext.java:446)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1110)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:603)\n\tat java.lang.Thread.run(Thread.java:636)\n{code}\n\nSeems to go bang when {{GroovyObjectSupport}} calls {{InvokerHelper.getMetaClass}} in the constructor on line 32",
        "adding namespaces to node navigation GPath syntax doesn't support xml with namespaces. The XmlParser class creates special names for xml elements with namespaces (e.g., \"{namespace-uri-here}elementName\"). GPath node selection doesn't support this format.\n\nAs xml namespaces are commonly used all over the xml world, Gpath would benefit using in a transparent way all nodes, whether with binded namespaces or not."
    ],
    [
        "GROOVY-4640",
        "GROOVY-6302",
        "Groovy compilation problem: BUG! exception in phase 'semantic analysis' in source unit I have introduced some groovy code into an existing Java web application as a first step to beginning using Groovy. I have adapted a struts interceptor by simply changing the extension to .groovy, inserting a simple line of groovy and adding the groovyc Ant task to the build process.\n\nHere is the Groovy code added as a simple hello world:\n\n{code}\n10.times() {logger.fine(\"groovy test\")}\n{code}\n\nDuring compilation the following exception is thrown. I decided to post it on JIRA as the exception message marked it as a bug.\n\n{code}\nBUG! exception in phase 'semantic analysis' in source unit '/Users/neilbeveridge/TGC/roadrunner/WebAdmin/src/java/eu/smartscheme/webadmin/interceptor/impl/AuthenticationInterceptor.groovy' groovy.runtime.metaclass.java.util.ArrayListMetaClass.<init>(groovy.lang.MetaClass)\n        at org.codehaus.groovy.control.CompilationUnit.applyToSourceUnits(CompilationUnit.java:822)\n        at org.codehaus.groovy.control.CompilationUnit.doPhaseOperation(CompilationUnit.java:515)\n        at org.codehaus.groovy.control.CompilationUnit.processPhaseOperations(CompilationUnit.java:491)\n        at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:468)\n        at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:447)\n        at org.codehaus.groovy.tools.FileSystemCompiler.compile(FileSystemCompiler.java:57)\n        at org.codehaus.groovy.tools.FileSystemCompiler.doCompilation(FileSystemCompiler.java:170)\n        at org.codehaus.groovy.ant.Groovyc.compile(Groovyc.java:903)\n        at org.codehaus.groovy.ant.Groovyc.execute(Groovyc.java:605)\n        at org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:288)\n        at sun.reflect.GeneratedMethodAccessor899.invoke(Unknown Source)\n        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n        at java.lang.reflect.Method.invoke(Method.java:597)\n        at org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:106)\n        at org.apache.tools.ant.Task.perform(Task.java:348)\n        at org.apache.tools.ant.Target.execute(Target.java:357)\n        at org.apache.tools.ant.Target.performTasks(Target.java:385)\n        at org.apache.tools.ant.Project.executeSortedTargets(Project.java:1337)\n        at org.apache.tools.ant.Project.executeTarget(Project.java:1306)\n        at org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:41)\n        at org.apache.tools.ant.Project.executeTargets(Project.java:1189)\n        at org.apache.tools.ant.module.bridge.impl.BridgeImpl.run(BridgeImpl.java:278)\n        at org.apache.tools.ant.module.run.TargetExecutor.run(TargetExecutor.java:498)\n        at org.netbeans.core.execution.RunClassThread.run(RunClassThread.java:151)\nCaused by: java.lang.NoSuchMethodException: groovy.runtime.metaclass.java.util.ArrayListMetaClass.<init>(groovy.lang.MetaClass)\n        at java.lang.Class.getConstructor0(Class.java:2706)\n        at java.lang.Class.getConstructor(Class.java:1657)\n        at groovy.lang.MetaClassRegistry$MetaClassCreationHandle.createWithCustomLookup(MetaClassRegistry.java:129)\n        at groovy.lang.MetaClassRegistry$MetaClassCreationHandle.create(MetaClassRegistry.java:122)\n        at org.codehaus.groovy.reflection.ClassInfo.getMetaClassUnderLock(ClassInfo.java:165)\n        at org.codehaus.groovy.reflection.ClassInfo.getMetaClass(ClassInfo.java:195)\n        at org.codehaus.groovy.runtime.metaclass.MetaClassRegistryImpl.getMetaClass(MetaClassRegistryImpl.java:214)\n        at org.codehaus.groovy.runtime.InvokerHelper.getMetaClass(InvokerHelper.java:747)\n        at org.codehaus.groovy.runtime.callsite.CallSiteArray.createPojoSite(CallSiteArray.java:107)\n        at org.codehaus.groovy.runtime.callsite.CallSiteArray.createCallSite(CallSiteArray.java:148)\n        at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:40)\n        at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:116)\n        at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:124)\n        at org.codehaus.groovy.ast.builder.AstBuilderInvocationTrap.<init>(AstBuilderTransformation.groovy:140)\n        at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)\n        at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:39)\n        at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:27)\n        at java.lang.reflect.Constructor.newInstance(Constructor.java:513)\n        at org.codehaus.groovy.reflection.CachedConstructor.invoke(CachedConstructor.java:77)\n        at org.codehaus.groovy.runtime.callsite.ConstructorSite$ConstructorSiteNoUnwrapNoCoerce.callConstructor(ConstructorSite.java:102)\n        at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCallConstructor(CallSiteArray.java:52)\n        at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callConstructor(AbstractCallSite.java:190)\n        at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callConstructor(AbstractCallSite.java:210)\n        at org.codehaus.groovy.ast.builder.AstBuilderTransformation.visit(AstBuilderTransformation.groovy:62)\n        at org.codehaus.groovy.transform.ASTTransformationVisitor$3.call(ASTTransformationVisitor.java:302)\n        at org.codehaus.groovy.control.CompilationUnit.applyToSourceUnits(CompilationUnit.java:818)\n        ... 23 more\n{code}\n\nMany thanks.",
        "Stub generator chokes on multi-dimensional arrays {code}\nclass GroovyClass {\n    Map<String, String[][]> foo() { null }\n}\n\n{code}\n\nStub (note the foo method at the end):\n\n{code}\nimport java.lang.*;\nimport java.io.*;\nimport java.net.*;\nimport java.util.*;\nimport groovy.lang.*;\nimport groovy.util.*;\n\npublic class GroovyClass\n  extends java.lang.Object  implements\n    groovy.lang.GroovyObject {\npublic  groovy.lang.MetaClass getMetaClass() { return (groovy.lang.MetaClass)null;}\npublic  void setMetaClass(groovy.lang.MetaClass mc) { }\npublic  java.lang.Object invokeMethod(java.lang.String method, java.lang.Object arguments) { return null;}\npublic  java.lang.Object getProperty(java.lang.String property) { return null;}\npublic  void setProperty(java.lang.String property, java.lang.Object value) { }\npublic  java.util.Map<java.lang.String, [Ljava.lang.String;[]> foo() { return (java.util.Map<java.lang.String, [Ljava.lang.String;[]>)null;}\n}\n{code}\n"
    ],
    [
        "GROOVY-1486",
        "GROOVY-7367",
        "groovy task: Allow classpath specification The <groovy> task doesn't allow to specify a classpath (or it's not taken into account) what is absolutely necessary when calling groovy from ant",
        "ArrayIndexOutOfBoundsException in getCreateArraySignature on too many function parameters When trying to pass too many arguments to a function Groovy crashes. This crashes even if the code is never called.\nDiscovered when trying to automatically generate a Gradle project configuration from a different build system. Ended up listing over 280 directories in a single argument list.\nTested only against 2.3.9.\nSetting priority to Critical only because it's the suggested priority for crashes.\n\n{code}$ groovy params.groovy \norg.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed:\nGeneral error during class generation: 255\n\njava.lang.ArrayIndexOutOfBoundsException: 255\n\tat org.codehaus.groovy.classgen.asm.CallSiteWriter.getCreateArraySignature(CallSiteWriter.java:55)\n\tat org.codehaus.groovy.classgen.asm.CallSiteWriter.makeCallSite(CallSiteWriter.java:314)\n\tat org.codehaus.groovy.classgen.asm.InvocationWriter.makeCachedCall(InvocationWriter.java:281)\n\tat org.codehaus.groovy.classgen.asm.InvocationWriter.makeCall(InvocationWriter.java:366)\n\tat org.codehaus.groovy.classgen.asm.InvocationWriter.makeCall(InvocationWriter.java:99)\n\tat org.codehaus.groovy.classgen.asm.InvocationWriter.makeInvokeMethodCall(InvocationWriter.java:83)\n\tat org.codehaus.groovy.classgen.asm.InvocationWriter.writeInvokeMethod(InvocationWriter.java:433)\n\tat org.codehaus.groovy.classgen.AsmClassGenerator.visitMethodCallExpression(AsmClassGenerator.java:749)\n\tat org.codehaus.groovy.ast.expr.MethodCallExpression.visit(MethodCallExpression.java:64)\n\tat org.codehaus.groovy.classgen.asm.StatementWriter.writeReturn(StatementWriter.java:582)\n\tat org.codehaus.groovy.classgen.asm.OptimizingStatementWriter.writeReturn(OptimizingStatementWriter.java:316)\n\tat org.codehaus.groovy.classgen.AsmClassGenerator.visitReturnStatement(AsmClassGenerator.java:606)\n\tat org.codehaus.groovy.ast.stmt.ReturnStatement.visit(ReturnStatement.java:47)\n\tat org.codehaus.groovy.classgen.asm.StatementWriter.writeBlockStatement(StatementWriter.java:81)\n\tat org.codehaus.groovy.classgen.asm.OptimizingStatementWriter.writeBlockStatement(OptimizingStatementWriter.java:155)\n\tat org.codehaus.groovy.classgen.AsmClassGenerator.visitBlockStatement(AsmClassGenerator.java:556)\n\tat org.codehaus.groovy.ast.stmt.BlockStatement.visit(BlockStatement.java:69)\n\tat org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClassCodeContainer(ClassCodeVisitorSupport.java:101)\n\tat org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitConstructorOrMethod(ClassCodeVisitorSupport.java:112)\n\tat org.codehaus.groovy.classgen.AsmClassGenerator.visitStdMethod(AsmClassGenerator.java:420)\n\tat org.codehaus.groovy.classgen.AsmClassGenerator.visitConstructorOrMethod(AsmClassGenerator.java:377)\n\tat org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitMethod(ClassCodeVisitorSupport.java:123)\n\tat org.codehaus.groovy.classgen.AsmClassGenerator.visitMethod(AsmClassGenerator.java:497)\n\tat org.codehaus.groovy.ast.ClassNode.visitContents(ClassNode.java:1064)\n\tat org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClass(ClassCodeVisitorSupport.java:50)\n\tat org.codehaus.groovy.classgen.AsmClassGenerator.visitClass(AsmClassGenerator.java:231)\n\tat org.codehaus.groovy.control.CompilationUnit$16.call(CompilationUnit.java:805)\n\tat org.codehaus.groovy.control.CompilationUnit.applyToPrimaryClassNodes(CompilationUnit.java:1047)\n\tat org.codehaus.groovy.control.CompilationUnit.doPhaseOperation(CompilationUnit.java:583)\n\tat org.codehaus.groovy.control.CompilationUnit.processPhaseOperations(CompilationUnit.java:561)\n\tat org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:538)\n\tat groovy.lang.GroovyClassLoader.doParseClass(GroovyClassLoader.java:286)\n\tat groovy.lang.GroovyClassLoader.parseClass(GroovyClassLoader.java:259)\n\tat groovy.lang.GroovyShell.parseClass(GroovyShell.java:674)\n\tat groovy.lang.GroovyShell.run(GroovyShell.java:501)\n\tat groovy.lang.GroovyShell.run(GroovyShell.java:491)\n\tat groovy.ui.GroovyMain.processOnce(GroovyMain.java:650)\n\tat groovy.ui.GroovyMain.run(GroovyMain.java:381)\n\tat groovy.ui.GroovyMain.process(GroovyMain.java:367)\n\tat groovy.ui.GroovyMain.processArgs(GroovyMain.java:126)\n\tat groovy.ui.GroovyMain.main(GroovyMain.java:106)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:606)\n\tat org.codehaus.groovy.tools.GroovyStarter.rootLoader(GroovyStarter.java:106)\n\tat org.codehaus.groovy.tools.GroovyStarter.main(GroovyStarter.java:128)\n\n1 error\n{code}"
    ],
    [
        "GROOVY-4498",
        "GROOVY-1669",
        "Only the root exception in a script is printed  Can be seen by running the following in a script with the `groovy` command.\n\n{code}\nthrow new Exception(\"root\", new Exception(\"cause\"))\n{code}\n\n",
        "when defining a new variable with a map \"[]\" the next line is indented to the first character after \"[\" Quick code example, when typing and hitting enter\ndef attributes = []\n                             //cursor ends up way over here\n\nThis also happens when copy/pasting code that contains \"[]\" and screws with the formatting of all following lines"
    ],
    [
        "GROOVY-3702",
        "GROOVY-7691",
        "Groovlet: depending groovy files are not recompiled If you change file b.groovy which is used by a.groovy, file b.groovy is not recompiled. Both files are in the same (root) directory of a web application. \n\nExample:\na.groovy\n{code}\nprintln \"<html><body>\";\nprintln \"a: test<br/>\";\ndef b = new b();\nprintln b.test();\nprintln \"</body></html>\";\n{code}\n\nb.groovy\n{code}\npublic class b {\n    def String test() {\n        return \"b: test<br/>\";\n    }\n}\n{code}\n\nCalling a.groovy by a URL like this http://localhost:8080/groovy/a.groovy will show this output:\n{code}\na: test\nb: test\n{code}\n\nIf in file b.groovy the return value is changed to \"b: test2<br/>\" you will not see the change when calling a.groovy again.\n",
        "Type checking error on generic property with covariant type in subclass A property declared with a generic type in a superclass is not seen with the correct covariant type in a subclass narrowing the type:\r\n{code}\r\nabstract class AbstractNumberWrapper<S extends Number> {\r\n    protected final S number;\r\n\r\n    AbstractNumberWrapper(S number) {\r\n        this.number = number\r\n    }\r\n}\r\nclass LongWrapper<S extends Long> extends AbstractNumberWrapper<S> {\r\n    LongWrapper(S longNumber) {\r\n        super(longNumber)\r\n    }\r\n\r\n    S getValue() {\r\n        return number;\r\n    }\r\n}\r\nassert new LongWrapper<Long>(42L).value == 42L\r\n{code}\r\nraises the following error when type checked:\r\n{noformat}\r\n[Static type checking] - Cannot return value of type java.lang.Number on method returning type S\r\n @ line 15, column 28.\r\n                       return number;\r\n                              ^\r\n\r\n1 error{noformat}"
    ],
    [
        "GROOVY-110",
        "GROOVY-728",
        "println(true == false) fails println(true == false) fails with the following stack trace :\n\nException in thread \"main\" java.lang.VerifyError: (class: CommandLine1, method:\nrun signature: ()Ljava/lang/Object;) Expecting to find object/array on stack\n        at java.lang.Class.getDeclaredConstructors0(Native Method)\n        at java.lang.Class.privateGetDeclaredConstructors(Class.java:1610)\n        at java.lang.Class.getConstructor0(Class.java:1922)\n        at java.lang.Class.getConstructor(Class.java:1019)\n        at org.codehaus.groovy.runtime.InvokerHelper.createScript(InvokerHelper.\njava:295)\n        at groovy.lang.GroovyShell.evaluate(GroovyShell.java:230)\n        at groovy.lang.GroovyShell.evaluate(GroovyShell.java:210)\n        at groovy.ui.InteractiveShell.run(InteractiveShell.java:100)\n        at groovy.ui.InteractiveShell.main(InteractiveShell.java:71)\n        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.\njava:39)\n        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAcces\nsorImpl.java:25)\n        at java.lang.reflect.Method.invoke(Method.java:324)\n        at org.codehaus.classworlds.Launcher.launchStandard(Launcher.java:410)\n        at org.codehaus.classworlds.Launcher.launch(Launcher.java:344)\n        at org.codehaus.classworlds.Launcher.main(Launcher.java:474)",
        "Error declaring variables in scripts The following code:\n\nimport javax.swing.JFrame\njavax.swing.JFrame foo;\n\nthrows the following exception:\n\nCaught: groovy.lang.MissingPropertyException: No such property: foo for class: test \n\nit should declare a variable."
    ],
    [
        "GROOVY-2497",
        "GROOVY-4422",
        "assertEquals() raises IllegalAccessError for Lists The following test causes an exception ...\n\nvoid testIt() {\n    assertEquals([1,2], [3,4])\n}\n\nThat should fail yes, bit raises the following exception ...\n\njava.lang.IllegalAccessError: tried to access method junit.framework.Assert.failNotEquals(Ljava/lang/String;Ljava/lang/Object;Ljava/lang/Object;)V from class groovy.util.GroovyTestCase\n\tat groovy.util.GroovyTestCase.assertEquals(GroovyTestCase.java:385)\n\tat groovy.util.GroovyTestCase.assertEquals(GroovyTestCase.java:389)\n",
        "An Interface nested within a class fails to parse. Attempting to compile/evalute the following groovy code\n{code:java}\n public class Foo {\n   static public class Bar {}\n   static public interface Baz {}\n }\n{code}\nproduces\n{quote}\n1 compilation error:\n Unknown type: INTERFACE_DEF at line: 3 column: 3. File: ConsoleScript8 at line: 3, column: 3\n{quote}"
    ],
    [
        "GROOVY-93",
        "GROOVY-3043",
        "Class type not honored In the following code\n\nByte b = 3\nprintln(b.class)\n\nb is an instanceof java.lang.Integer instead of java.lang.Byte\n\nThe type defined is not honored.\nCurrently the workaround is to define b as follows\n\nByte b = new Byte(\"3\") // constructor with a String",
        "Command line arguments containing * (asterisk) not passed correctly Groovy does weird things with command line arguments containing *.  Makes it very difficult to pass in things like file specs, ant specs and regex expresssions!!!  A simple program that prints out the length of the args parameter passed into main procedure - a few are correct but most are wrong:\n\n{noformat}\n>groovy fail test\nargs length: 1\n\n>groovy fail *\nargs length: 3\n\n>groovy fail **\nargs length: 0\n\n>groovy fail \"**\"\nargs length: 0\n\n>groovy fail \"test\"  \" *\"\nargs length: 2\n\n>groovy fail \"test\"  \"*\"\nargs length: 1\n\n>groovy fail \"test   *\"\nargs length: 1\n\n>groovy fail \"*test*\"\nargs length: 0\n\n>groovy fail \"*test*\"\nargs length: 0\n\n>groovy fail \" *test*\"\nargs length: 1\n{noformat}"
    ],
    [
        "GROOVY-4739",
        "GROOVY-1412",
        "Ability to throw strings as RuntimeExceptions  In Ruby, you can throw any object and it is automatically wrapped as a runtime exception: http://phrogz.net/programmingruby/tut_exceptions.html#raisingexceptions\n\nIt could be nice to have the same thing in Groovy...\n\n{code}\nif (badThingsHappened) {\n    throw \"bad things have happened\"\n}\n{code}\n\nwhich would be the same as\n\n{code}\nif (badThingsHappened) {\n    throw new RuntimeException(\"bad things have happened\")\n}\n{code}",
        "Ambiguous method overloading for method ... interface parameters - Two interfaces (AIf, BIf), one class, A, implementing both.\n- Two methods named test on B, with respectivly AIf and BIf for argument type.\n- Try to call one of the two B methods with a casted instance of A.\n- Obtain GroovyRuntimeException : \"Ambiguous method overloading for method ...\".\n\nIt seemed to be fixed but (http://jira.codehaus.org/browse/GROOVY-956) but with JSR-06 it doesn't work.\n\nSee attachment to make evidence of the (or my) problem."
    ],
    [
        "GROOVY-2838",
        "GROOVY-7539",
        "Add everyWithIndex, anyWithIndex, collectWithIndex, sumWithIndex  ... or add indexGen The objective is that in any collection methods, the current index shall be available. \n\nRefer to the discussion at: \nhttp://www.nabble.com/Groovy-syntax--API-enhancement-td16796998.html#a16810531\n\nThe discussion was long and the relevant content are extracted as follow for easy of reading:\n- support everyWithIndex, anyWithIndex, collectWithIndex, sumWithIndex etc. it's even better if the original every, any has an implicit variable/syntax for retrieving the index\ne.g. [10,20].collectWithIndex{ it,i -> it*(i+1) } = [ 10, 40 ]\n\n- The problem here is that you are assuming that those methods (every,\nany, collect, etc) are *iterating* over the collection with some\npredetermined order, in sequence. Nothing in the semantics says it\nshould be so. They could be even be doing it in parallel. \n\n- I am against all these withIndex methods... they are polluting the API\nso much. I would like to have a more general solution, but I can't think\nof any yet \n\n- for 4..5, I did assume the collection is in sequence and is iteratable. It seems to me Groovy collections are usually in sequence by default. e.g. [] is ArrayList and [:].getClass() is LinkedHashMap, so in the majority of case, collection have order and have index. e.g. [] as Set is used, then the index will just be unavailable or always return -1. \n\n- Can't you just modify the each/any/collect methods to test how many\nparameters the closure takes?  If the closure only takes one param\nassume it is the item.  If it takes two params, assume (item, index).\nNo? \n\n- That's what we're already doing for some of the methods like each().\nBut it'd be nice to expand this approach to all methods for which it may apply. \n\n- About indexGen, \nhttp://www.nabble.com/Re%3A-Groovy-syntax--API-enhancement-p16811203.html",
        "Traits break if method name has $ sign trait TestTrait {\r\n    public void 'testmethod $problem'() {\r\n        println(\"test\")\r\n    }\r\n}\r\n\r\nIf we use this trait as (implements TestTrait) we get:\r\nCan't have an abstract method in a non-abstract class. The class 'SomeClass' must be declared abstract or the method 'someMethod()' must be implemented.\r\n\r\nSince Groovy supports method names as strings this is unexpected. \r\n"
    ],
    [
        "GROOVY-7373",
        "GROOVY-6945",
        "Interact Closures withing Groovy Trait methods are not recognized by the implementing class Since moving to grails 2.5.0 (groovy 2.4.x) our functional tests (geb/spock) are failing when we try to run interact closures inside of a trait.  I'm not entirely sure who owns this one as there are three or four players groovy, grails, geb/spock, but groovy seemed like the most logical culprit.\n\n{code:Java|title=Example Usage}\ntrait DoStuff {\n   def clickItemOnPage() {\n      interact {\n         moveToElement($('.myDiv'))\n         click()\n      }\n   }\n}\nclass MySpec extends GebReportingSpec  implements DoStuff {\n   def clickItemOnPage2() {\n      interact {\n         moveToElement($('.myDiv'))\n         click()\n      }\n   }\n   def 'Test some stuff' { \n      clickItemOnPage2() //Passes\n      clickItemOnPage() //Fails\n   }\n}\n{code}\nError: groovy.lang.MissingMethodException: No signature of method: geb.navigator.NonEmptyNavigator.moveToElement()\nIt really doesn't matter what you have in the interact closure anything fails...",
        "Some DGM Collection improvements Highlights of the proposed improvements:\n* The {{unique()}} DGM methods follow Java's default of mutate in place when called on for instance a {{Collection}} (but also has a boolean flag for non-mutating behavior). There is no {{Iterable}} variant of the method but if there was one, a mutate flag wouldn't make sense for non-Collection iterables. The {{Iterator}} variant has no flag and it wouldn't make sense anyway. There is no array variant but if there was one it wouldn't make sense to have a mutate flag. Rather than complicating {{unique}} further, this improvement adds Iterable, Iterator and array variants of {{toUnique}}. This method always returns new collection-like structures.\n* A similar situation exists for {{sort()}} as for {{unique}}. This improvement adds Iterable, Iterator, array and Map variants of {{toSorted}}. This method always returns new collection-like structures.\n* Some non-Iterable variants can be deprecated in favor of Iterable variants for: {{collate}}, {{containsAll}}, {{tail}}, {{take}}, {{multiply}} on Iterables, {{disjoint}}, {{minus}} on Iterables.\n* The non-released {{List}} variants for {{init()}}, {{takeRight}} and {{dropRight}} have been elided (they provided only a marginal performance benefit compared to extra API complexity) and {{Iterator}} variants have been added.\n* The returned collection type is kept similar to the original where possible for the Iterable variants of: {{tail}}, {{init}}, {{take}}, {{takeRight}}, {{drop}}, {{dropRight}}, {{takeWhile}}, {{dropWhile}}, {{multiply}} on Iterables.\n* There are two new {{addAll}} variants on Collections: {{addAll(Iterator)}} and {{addAll(Iterable)}}.\n* Where possible Iterator variants of the above mentioned methods have been modified (where necessary) so that they don't create extra copies of collection-like structures (i.e. Iterators are used instead of logic involving for example {{toList}} followed by operations on the list). This makes them work better with (possibly infinite) streams of data, e.g.:\n{code}\nint a = 1\ndef infiniterator = [ hasNext:{ true }, next:{ a++ } ] as Iterator\nassert infiniterator.drop(3).dropWhile{ it < 9 }.toUnique{ it % 100 }.init().tail().take(3).toList() == [10, 11, 12]\n{code}"
    ],
    [
        "GROOVY-1754",
        "GROOVY-6551",
        "ContextClassLoader pollution again Here is another case of ContextClassLoader pollution:\n\n\tat org.eclipse.core.internal.resources.Resource.refreshLocal(Resource.java:1413)\n\tat org.codehaus.groovy.eclipse.core.model.GroovyProject.refreshOutput(GroovyProject.java:834)\n\tat org.codehaus.groovy.eclipse.core.model.GroovyProjectModel.updateClassNameModuleNodeMap(GroovyProjectModel.java:305)\n\tat org.codehaus.groovy.eclipse.core.model.GroovyProject$CompilationReporter.generatedAST(GroovyProject.java:109)\n\tat org.codehaus.groovy.eclipse.core.compiler.GroovyCompiler.reportBuild(GroovyCompiler.java:283)\n\tat org.codehaus.groovy.eclipse.core.compiler.GroovyCompiler.compile(GroovyCompiler.java:210)\n\tat org.codehaus.groovy.eclipse.core.compiler.GroovyCompiler.compile(GroovyCompiler.java:111)\n\nThere is a nice comment in updateClassNameModuleNodeMap():\n\n        // TODO: emp - why is the model updating the project?\n        project.refreshOutput();\n\nWell, \n\na) it must not! One reason: it causes extreme performance problems in Windows because this refreshes the *whole* project for *every* *single* *file* being compiled.\n\nb) If you call anything outside of Groovy, you *must* reset the ContextClassLoader! In my case, the refresh invokes another plugin which is a bit confused because the GroovyClassLoader() can't see it's classes.\n",
        "Groovy Sql API should support stored procedures that return multiple result sets "
    ],
    [
        "GROOVY-872",
        "GROOVY-5663",
        "GregorianCalendar and groovysh not printing or throwing exception The following code typed inside the groovysh:\n\ncal = new GregorianCalendar()\ncal.set(Calendar.DAY_OF_MONTH,1);\nprintln cal.get(Calendar.DAY_OF_MONTH)\n\ndoesn't print any result, and it doesn't throw any exception.\n\n\nclass MyCalendar{\n    /**\n     * Main method\n     */\n    static void main(args) {\n\n        cal = new GregorianCalendar()\n        cal.set(Calendar.DAY_OF_MONTH,1);\n        println cal.get(Calendar.DAY_OF_MONTH)\n\n\n    }\n}\n",
        "Groovy call to Java static method fails with NoSuchMethodError when using @CompileStatic Groovy class compiled with @CompileStatic.\nFails at runtime when calling a static method on a Java class.\nThrows NoSuchMethodError.\nThe Java method uses Generics in its signature.\nRemove the Generics and the issue goes away.\nGroovy and Java classes attached (Groovy calls Java)\n"
    ],
    [
        "GROOVY-6314",
        "GROOVY-6450",
        "ResourceGroovyMethods uses BufferedWriter/BufferedOutputStream {{ResourceGroovyMethods}} uses {{BufferedWriter}} and {{BufferedOutputStream}} to write in-memory data to files. This is bad because it causes 8 K of chars or bytes to be created per-call.\n\nFor example, this\n\n{code}\nnew File('keks') << 'ah'\n{code}\n\ngenerates 16 KB of unnecessary waste.\n\nAffected methods:\n\n* write(File file, String text)\n* write(File file, String text, String charset)\n* append(File file, Object text)\n* append(File file, byte[] bytes)\n* append(File file, Object text, String charset)\n\nSolution:\n\n{code}\n    public static void append(File file, byte[] bytes) throws IOException {\n        BufferedOutputStream stream = null;\n        try {\n            stream = new BufferedOutputStream(new FileOutputStream(file, true));\n            stream.write(bytes, 0, bytes.length);\n            stream.flush();\n\n            OutputStream temp = stream;\n            stream = null;\n            temp.close();\n        } finally {\n            closeWithWarning(stream);\n        }\n    }\n{code}\n\n(Before)\n\n{code}\n    public static void append(File file, byte[] bytes) throws IOException {\n        OutputStream stream = null;\n        try {\n            stream = new FileOutputStream(file, true);\n            stream.write(bytes, 0, bytes.length);\n            stream.flush();\n\n            OutputStream temp = stream;\n            stream = null;\n            temp.close();\n        } finally {\n            closeWithWarning(stream);\n        }\n    }\n{code}\n\n(After)",
        "String.minus(String) and String.minus(Pattern) are inconsistent with List.minus(Collection). The String.minus operations only remove the first occurrence of the equal elements while List.minus removes all occurrences.  This is terribly inconsistent, as shown in these examples:\n\n{code}\n$ groovy -e \"println ('abcabcabc' - 'b')\"\nacabcabc\n\n$ groovy -e \"println ((('abcabcabc' as List) - ('b' as List)).join())\"\nacacac\n{code}\n\nGiven my experience with trying work with multisets, I think I prefer the remove first/only one semantics.  Given String.minus' troubled history it is probably less disruptive to change it yet again.  "
    ],
    [
        "GROOVY-5319",
        "GROOVY-7539",
        "groovyConsole.exe does not always close its process after closing frame or window If I drag a groovy source file into the Groovy Console (DND) the groovyConsole.exe remains open in Windows Task Manager even if I close the frame or click on the Exit menu! The processes have to be killed manually!\n",
        "Traits break if method name has $ sign trait TestTrait {\r\n    public void 'testmethod $problem'() {\r\n        println(\"test\")\r\n    }\r\n}\r\n\r\nIf we use this trait as (implements TestTrait) we get:\r\nCan't have an abstract method in a non-abstract class. The class 'SomeClass' must be declared abstract or the method 'someMethod()' must be implemented.\r\n\r\nSince Groovy supports method names as strings this is unexpected. \r\n"
    ],
    [
        "GROOVY-4782",
        "GROOVY-3532",
        "@Singleton(lazy=true) does not perform the correct double checked locking for Java @Singleton(lazy=true) does not perform the correct double checked locking for Java\n\nIt does the naive version where no local variable is declared. \n\nMore info here: http://groovy.329449.n5.nabble.com/Singleton-double-checked-locking-fix-td4302467.html\n\nI have a patch that I will commit.",
        "GroovyConsole AST Viewer fails when trying to display AST for inner classes and anonymous inner classes GroovyConsole has an AST Viewer. It just comes up blank when I enter the following script: \n{code}\nclass Foo {\n  static class Bar {\n  }\n}\n{code}\n\nThere is no exception and no error, it's just blank. No StatementBlock and no Script class either. Just blank. \n\nThis same things happens for anonymous inner classes: \n{code}\nTimer timer = new Timer()\n\nboolean called = false\n\ntimer.schedule(new TimerTask() {\n  void run() {\n      println \"Task executed\"\n      called = true\n  }\n}, 0)\nsleep 100\n\nassert called\n{code}"
    ],
    [
        "GROOVY-2247",
        "GROOVY-2760",
        "check the new StackMapTable feature for usage in Groovy java 6 has a new verifier, that operates in two faces. the first phase is done by the compiler, which has to store type information in stack maps. the second phase is when loading the class, the verifier will check the usage based on the type information from the first phase. This allows the verifier to run much faster and shortens class loading time. \n\nThis feature should be checked for usage in Groovy. ",
        "groovyc compiles file, but running it fails with java.lang.VerifyError The following file contains a typo.  It builds well with groovyc, but fails to run with groovy and raises an exception:\n\nCaught: java.lang.VerifyError: (class: testCompile, method: aMethod signature: ()Ljava/lang/Object;) Register 4 contains wrong type\n\n\n{code:Java}\n    def aMethod() {\n        try {\n            int i = 0\n        }\n        catch(AssertionError e) {\n                println e\n        }\n        catch(Throwable t) {\n                println e // THIS IS A TYPO, OUTSIDE OF THE SCOPE\n        }\n    }\n\naMethod()\n{code}"
    ],
    [
        "GROOVY-5705",
        "GROOVY-500",
        "STC: calling a closure stored in a property yields an NPE When you run the following example:\n\n{code}\nimport groovy.transform.*\n\nclass Test {\n    Closure c = { it }\n    \n    @TypeChecked\n    void test() {\n        c(\"123\")\n    }\n}\n\nnew Test().test()\n{code}\n\nAn NPE will be thrown:\n{code}\njava.lang.NullPointerException\n\tat org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitMethodCallExpression(StaticTypeCheckingVisitor.java:1717)\n\tat org.codehaus.groovy.ast.expr.MethodCallExpression.visit(MethodCallExpression.java:67)\n\tat org.codehaus.groovy.ast.CodeVisitorSupport.visitExpressionStatement(CodeVisitorSupport.java:69)\n\tat org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitExpressionStatement(ClassCodeVisitorSupport.java:193)\n\tat org.codehaus.groovy.ast.stmt.ExpressionStatement.visit(ExpressionStatement.java:40)\n\tat org.codehaus.groovy.ast.CodeVisitorSupport.visitBlockStatement(CodeVisitorSupport.java:35)\n\tat org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitBlockStatement(ClassCodeVisitorSupport.java:163)\n\tat org.codehaus.groovy.ast.stmt.BlockStatement.visit(BlockStatement.java:69)\n\tat org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClassCodeContainer(ClassCodeVisitorSupport.java:101)\n\tat org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitConstructorOrMethod(ClassCodeVisitorSupport.java:112)\n\tat org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitConstructorOrMethod(StaticTypeCheckingVisitor.java:1224)\n\tat org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitMethod(ClassCodeVisitorSupport.java:123)\n\tat org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.startMethodInference(StaticTypeCheckingVisitor.java:1465)\n\tat org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitMethod(StaticTypeCheckingVisitor.java:1439)\n\tat org.codehaus.groovy.transform.StaticTypesTransformation.visit(StaticTypesTransformation.java:78)\n\tat org.codehaus.groovy.transform.ASTTransformationVisitor.visitClass(ASTTransformationVisitor.java:132)\n\tat org.codehaus.groovy.transform.ASTTransformationVisitor$2.call(ASTTransformationVisitor.java:176)\n\tat org.codehaus.groovy.control.CompilationUnit.applyToPrimaryClassNodes(CompilationUnit.java:1027)\n\tat org.codehaus.groovy.control.CompilationUnit.doPhaseOperation(CompilationUnit.java:564)\n\tat org.codehaus.groovy.control.CompilationUnit.processPhaseOperations(CompilationUnit.java:542)\n\tat org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:519)\n\tat groovy.lang.GroovyClassLoader.doParseClass(GroovyClassLoader.java:283)\n\tat groovy.lang.GroovyClassLoader.parseClass(GroovyClassLoader.java:264)\n\tat groovy.lang.GroovyShell.parseClass(GroovyShell.java:613)\n\tat groovy.lang.GroovyShell.run(GroovyShell.java:480)\n\tat groovy.lang.GroovyShell.run(GroovyShell.java:163)\n\tat groovy.lang.GroovyShell$run.call(Unknown Source)\n\tat groovy.ui.Console$_runScriptImpl_closure17.doCall(Console.groovy:951)\n\tat groovy.ui.Console$_runScriptImpl_closure17.doCall(Console.groovy)\n\tat sun.reflect.GeneratedMethodAccessor242.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n\tat java.lang.reflect.Method.invoke(Method.java:597)\n\tat org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:90)\n\tat groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:233)\n\tat org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:272)\n\tat groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:904)\n\tat groovy.lang.Closure.call(Closure.java:415)\n\tat groovy.lang.Closure.call(Closure.java:409)\n\tat groovy.lang.Closure.run(Closure.java:493)\n\tat java.lang.Thread.run(Thread.java:680)\n{code}",
        "Can't pass this in super() When I invoke the super constructor of a parent class, I cannot pass \"this\":\n\nB.groovy:\n\nclass B {\n    B(x) {}\n}\n\n\nC.groovy:\n\nclass C extends B {\n    C() {\n        super(this)\n    }\n    \n    static void main(args) {\n        cc = new C()\n    }\n}\n\n\nI get this failure:\n\nException in thread \"main\" java.lang.VerifyError: (class: C, method: <init> signature: ()V) Expecting to find object/array on stack\n        at java.lang.Class.getDeclaredConstructors0(Native Method)\n        at java.lang.Class.privateGetDeclaredConstructors(Class.java:1610)\n        at java.lang.Class.getDeclaredConstructors(Class.java:1169)\n        at groovy.lang.MetaClass.<init>(Unknown Source)\n        at groovy.lang.MetaClassRegistry.getMetaClass(MetaClassRegistry.java:100)\n        at org.codehaus.groovy.runtime.Invoker.invokeMethod(Unknown Source)\n        at org.codehaus.groovy.runtime.InvokerHelper.invokeMethod(InvokerHelper.java:106)\n        at groovy.lang.GroovyShell.run(GroovyShell.java:222)\n        at groovy.lang.GroovyShell.main(GroovyShell.java:92)\n        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n        at java.lang.reflect.Method.invoke(Method.java:324)\n        at org.codehaus.classworlds.Launcher.launchStandard(Launcher.java:410)\n        at org.codehaus.classworlds.Launcher.launch(Launcher.java:344)\n        at org.codehaus.classworlds.Launcher.main(Launcher.java:474)\n\n\nIf I change the \"this\" to something else, it works."
    ],
    [
        "GROOVY-4457",
        "GROOVY-2115",
        "generic type declarations leaking across all files in a build Simple file, A.groovy:\n\n{code}\nclass A<String> {\n}\n\nclass B {\n  void foo(String s) {}\n}\n{code}\n\ngroovyc A.groovy\njavap -private B | grep foo\n\nproduces:\n{code}\npublic void foo(java.lang.Object);\n{code}\n\nThe 'String' is treated as a type parameter name.  The reference 'String' in the foo method is mapped to this type parameter (clearly it shouldn't be) and when producing the code, String is erased to its upper bound of Object, hence foo(Object) in the bytecode.\n\nChange it to this:\n{code}\nclass A<T> {\n}\n\nclass B {\n  void foo(String s) {}\n}\n{code}\nand it produces what you expect:\n{code}\n public void foo(java.lang.String);\n{code}\n\nThe problem is the genericParameterNames collection in the ResolveVisitor is never cleared, only augmented with new entries.\n\nMy solution that seems to work in groovy eclipse is to clear the parameter names at the end of visiting a classnode in ResolveVisitor. So at the end of\n\n{code}\npublic void visitClass(ClassNode node) {\n{code}\n\nadd\n{code}\ngenericParameterNames.clear();\n{code}\n",
        "text() method on NodeChild with XmlSlurper returns composite.  Need just local text. I am trying to use XmlSlurper to process and xml with nested elements with text in them.  I need to get the text from just one level at a time but the text() method returns all text for all childrend and I can't see anything that would bring back just the local.\n\nHere is a sample from the console:\n\ngroovy> def model = new XmlSlurper().parseText('<aModel><aParent name=\"bubba\">text<aChild>child text</aChild></aParent></aModel>')\n\ngroovy> model.aParent[0].text()\n\ngroovy> \n\ngroovy> \n\n\nResult: \"textchild text\""
    ],
    [
        "GROOVY-2893",
        "GROOVY-3348",
        "Line-/Column Information of PropertyExpression and FieldExpression The FieldExpression as well as the PropertyExpression had no source position information. Also the ConstantExpression that represents the method name in a MethodPointerExpression had no source position information.\n\nThe following fixes are made:\n \n * in rule pathElement of the grammar: use the create() method of the GroovyRecognizer to create the root node for each operator (SPREAD_DOT, OPTIONAL_DOT, MEMBER_POINTER and DOT) and use the prefix to set the start position of the operator node. The end position is set by using the start position of the next token to parse (LT(1)). Doing that leads to correct source position information for the operator node. This node is later used to set the source position of the PropertyExpression and FieldExpression.\n \n * in the StaticImportVisitor: set the source position from the PropertyExpression before the transformation, to the newly created.\n\n * in the AntlrParserPlugin: call configureAST() to set the source position of the ConstantExpression which represents the method name in a MethodPointerExpression\n \nTests that verify these changes are also included.",
        "groovy-1.6-RC-3 throws MissingPropertyException while 1.6-beta passes fine While retrieving JMX connection:\n{code}\nimport javax.management.remote.JMXConnectorFactory\nimport javax.management.remote.JMXServiceURL\nimport groovy.jmx.builder.JmxBuilder\n\ndef name = \"jmx.test:type=Object\"\nnew JmxBuilder().export {\n    bean(target:new TestMBean(message:\"Hello World\"), name:name)\n}  \n\ntry {\n    def serverUrl = 'service:jmx:rmi:///jndi/rmi://localhost:9004/jmxrmi'\n    def server = JMXConnectorFactory.connect(new JMXServiceURL(serverUrl)).mBeanServerConnection\n    println new GroovyMBean(server, name).Message\n} catch (e) {\n    e.printStackTrace()\n}\n{code}\n\ngroovy-1.6-RC-3, RC-2, RC-1 throw\n\n{code}\ngroovy.lang.MissingPropertyException: No such property: mBeanServerConnection for class: javax.management.remote.rmi.RMIConnector\n    at org.codehaus.groovy.runtime.ScriptBytecodeAdapter.unwrap(ScriptBytecodeAdapter.java:49)\n    at org.codehaus.groovy.runtime.callsite.GetEffectivePojoPropertySite.getProperty(GetEffectivePojoPropertySite.java:59)\n    at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callGetProperty(AbstractCallSite.java:236)\n    at test.run(test.gr:12)\n{code}\n\nwhile Groovy 1.6-beta works fine (prints \"Hello World\").\n\nTest passes if problem line is rewritten as\n{code}\n    def server = JMXConnectorFactory.connect(new JMXServiceURL(serverUrl)).getMBeanServerConnection()\n{code}\n"
    ],
    [
        "GROOVY-3589",
        "GROOVY-4115",
        "cast with as keyword produces error unlike versions 1.5 and before code below can be executed with No problem in the release 1.5.8 but in 1.6.2,1.6.3 we have exception \nsaying:\njava.lang.NumberFormatException:For input string \"V\"\n\ncode tested:\ndef a =  \"V\"\ndef b = a  as int\nprintln b\n\nin 1.5.8 out put is\n86\n\n",
        "StreamingMarkupBuilder should provide an option for using double quotes around attributes {{StreamingMarkupBuilder}} currently only uses single quotes for attributes, e.g.:\n{code}\n<?xml version='1.0'?>\n<root><a a1='one'><b>3 &lt; 5</b><c a2='two'>blah</c></a></root>\n{code}\nit would be good to support double quotes:\n{code}\n<?xml version=\"1.0\"?>\n<root><a a1=\"one\"><b>3 &lt; 5</b><c a2=\"two\">blah</c></a></root>\n{code}\n"
    ],
    [
        "GROOVY-2607",
        "GROOVY-3737",
        "AntBuilder input task error Hi, with new version of groovy-al jar I'm getting a StackOverflowError\n\nI've attached two files - the only difference is the version of groovy jar. Is something changed since 1.0 ?\n\nMore details from the stack trace ( from different build.xml file):\n    [input] test\n: java.lang.StackOverflowError\n        at org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:115)\n        at org.apache.tools.ant.Task.perform(Task.java:348)\n        at groovy.util.AntBuilder.nodeCompleted(AntBuilder.java:178)\n        at groovy.util.BuilderSupport.doInvokeMethod(BuilderSupport.java:153)\n        at groovy.util.AntBuilder.doInvokeMethod(AntBuilder.java:132)\n        at groovy.util.BuilderSupport.invokeMethod(BuilderSupport.java:64)\n        at org.codehaus.groovy.runtime.InvokerHelper.invokePogoMethod(InvokerHelper.java:781)\n        at org.codehaus.groovy.runtime.InvokerHelper.invokeMethod(InvokerHelper.java:757)\n        at org.codehaus.groovy.runtime.ScriptBytecodeAdapter.invokeMethodN(ScriptBytecodeAdapter.java:167)\n        at embedded_script_in__home_piotrus_IdeaProjects_september_vine_build.run(embedded_script_in__home_piotrus_IdeaProjects_september_vine_build.xml:4)\n        at org.codehaus.groovy.ant.Groovy.execGroovy(Groovy.java:348)\n        at org.codehaus.groovy.ant.Groovy.execute(Groovy.java:228)\n        at org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:288)\n        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n        at java.lang.reflect.Method.invoke(Method.java:597)\n        at org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:105)\n        at org.apache.tools.ant.Task.perform(Task.java:348)\n        at org.apache.tools.ant.Target.execute(Target.java:357)\n        at org.apache.tools.ant.Target.performTasks(Target.java:385)\n        at org.apache.tools.ant.Project.executeSortedTargets(Project.java:1329)\n        at org.apache.tools.ant.Project.executeTarget(Project.java:1298)\n        at org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:41)\n        at org.apache.tools.ant.Project.executeTargets(Project.java:1181)\n        at org.apache.tools.ant.Main.runBuild(Main.java:698)\n        at org.apache.tools.ant.Main.startAnt(Main.java:199)\n        at org.apache.tools.ant.launch.Launcher.run(Launcher.java:257)\n        at org.apache.tools.ant.launch.Launcher.main(Launcher.java:104)\nCaused by: java.lang.StackOverflowError\n        at java.lang.ref.ReferenceQueue.poll(ReferenceQueue.java:82)\n        at java.util.WeakHashMap.expungeStaleEntries(WeakHashMap.java:274)\n",
        "groovydoc and other groovy bugs 1.\tgroovydoc doesn't understand {@code xxx}.\n2.\tgroovydoc doesn't handle {@link xxx} correctly.\nIf I'm in a.b.C and I write {@link D} it should work but it doesn't.\nI must write {@link a.b.D} (note: same package).\n3.\tgroovydoc doesn't handle # correctly. If I write \n{@link a.b.C#f()} it displays \"C#f\" instead of \"C.f()\".\nIf I write {@link a.b.C#f() C.f()}, it displays the same thing as\nbefore. Apparently it ignores the second argument.\n4.\tThere is no way to specify a style sheet (CSS file). This is a\nsignificant problem for me and maybe others.\n5. \"<ctrl>2 r\" doesn't work correctly For example if I have a method and I change its argument name, only the argument name is changed. The name in the body of the method and in the mathod's javadoc comment are not changed.\n6. <alt><shift>R doesn't work correctly. For the same experiment as in 5, it changes the body but not the comment. If I try\n<alt<shift>R on a field it bombs with \"Unhandled event loop exception java.lang.StackOverflowError\". This is a high priority since it blows away eclipse.\n7. \"Run as groovy shell\" doesn't work. The shell starts and prints its startup message to the console. It then apparently exits immediately with no error message.\n8. If a class file has a comment (even an empty one) before the package declaration, then it doesn't display the comment before the \"class xxx\" line as it should. I don't think javadoc does this. In fact I think javadoc uses a file named \npackage-doc.java with the comment before the package declaration to generate the package.html file.\n"
    ],
    [
        "GROOVY-5592",
        "GROOVY-548",
        "No recent snapshot for 2.0.1 available from http://snapshots.repository.codehaus.org Latest snapshot is from June 26th, which is before 2.0.0 was released. Having access to the latest snapshot would help a lot, e.g. for Gradle development.",
        "Recursive method calls result in MissingMethodException Calling a method recursively results in a MissingMethodException.  The following script attempts to list all the files in the c:\\temp directory and its subdirectories.  The temp dir contains two files, a and b.  It also contains two subdirs, c and d.   This results in the following:\n\n# \n# script \n#\n#!/usr/bin/env groovy \n\nimport java.io.File\n\nmyfile = new File (\"c:/temp\")\nrecursedirs(myfile)\n\ndef recursedirs(File filedir) {\n\tfiledir.listFiles().each { file |\n\t\tif (file.isFile()) {\n\t\t\tprintln \"filename::\" + file.getPath()\n\t\t} else if (file.isDirectory()) {\n\t\t\tprintln \"directory::\" + file.getPath()\n\t\t\trecursedirs(file)\n\t\t}\n\t}\n}\n\n\n#\n# script output\n#\n$ recursebug\nfilename::c:\\temp\\a\nfilename::c:\\temp\\b\ndirectory::c:\\temp\\c\nCaught: groovy.lang.MissingMethodException: No signature of method recursebug$1.recursedirs() is applicable for argument types: (java.io.Fil\ne) values: [c:\\temp\\c]\ngroovy.lang.MissingMethodException: No signature of method recursebug$1.recursedirs() is applicable for argument types: (java.io.File) value\ns: [c:\\temp\\c]\n        at groovy.lang.MetaClass.invokeMethod(MetaClass.java:317)\n        at groovy.lang.MetaClass.invokeMethod(MetaClass.java:291)\n        at groovy.lang.Closure.doInvokeMethod(Closure.java:90)\n        at groovy.lang.Closure.invokeMethod(Closure.java:75)\n        at org.codehaus.groovy.runtime.Invoker.invokeMethod(Invoker.java:126)\n        at org.codehaus.groovy.runtime.InvokerHelper.invokeMethod(InvokerHelper.java:106)\n        at recursebug$1.doCall(recursebug:14)\n        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n        at java.lang.reflect.Method.invoke(Method.java:324)\n        at org.codehaus.groovy.runtime.ReflectionMetaMethod.invoke(ReflectionMetaMethod.java:63)\n        at groovy.lang.Closure.call(Closure.java:208)\n        at org.codehaus.groovy.runtime.DefaultGroovyMethods.each(DefaultGroovyMethods.java:292)\n        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n        at java.lang.reflect.Method.invoke(Method.java:324)\n        at org.codehaus.groovy.runtime.ReflectionMetaMethod.invoke(ReflectionMetaMethod.java:63)\n        at org.codehaus.groovy.runtime.NewInstanceMetaMethod.invoke(NewInstanceMetaMethod.java:99)\n        at groovy.lang.MetaClass.doMethodInvoke(MetaClass.java:1020)\n        at groovy.lang.MetaClass.invokeMethod(MetaClass.java:314)\n        at org.codehaus.groovy.runtime.Invoker.invokeMethod(Invoker.java:139)\n        at org.codehaus.groovy.runtime.InvokerHelper.invokeMethod(InvokerHelper.java:106)\n        at recursebug.recursedirs(recursebug)\n        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n        at java.lang.reflect.Method.invoke(Method.java:324)\n        at org.codehaus.groovy.runtime.ReflectionMetaMethod.invoke(ReflectionMetaMethod.java:63)\n        at groovy.lang.MetaClass.doMethodInvoke(MetaClass.java:1020)\n        at groovy.lang.MetaClass.invokeMethod(MetaClass.java:314)\n        at groovy.lang.MetaClass.invokeMethod(MetaClass.java:291)\n        at groovy.lang.GroovyObjectSupport.invokeMethod(GroovyObjectSupport.java:73)\n        at org.codehaus.groovy.runtime.Invoker.invokeMethod(Invoker.java:126)\n        at org.codehaus.groovy.runtime.InvokerHelper.invokeMethod(InvokerHelper.java:106)\n        at recursebug.run(recursebug:5)\n        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n        at java.lang.reflect.Method.invoke(Method.java:324)\n        at org.codehaus.groovy.runtime.ReflectionMetaMethod.invoke(ReflectionMetaMethod.java:63)\n        at groovy.lang.MetaClass.doMethodInvoke(MetaClass.java:1020)\n        at groovy.lang.MetaClass.invokeMethod(MetaClass.java:314)\n        at groovy.lang.MetaClass.invokeMethod(MetaClass.java:291)\n        at groovy.lang.GroovyObjectSupport.invokeMethod(GroovyObjectSupport.java:73)\n        at org.codehaus.groovy.runtime.Invoker.invokeMethod(Invoker.java:126)\n        at org.codehaus.groovy.runtime.InvokerHelper.invokeMethod(InvokerHelper.java:106)\n        at org.codehaus.groovy.runtime.InvokerHelper.runScript(InvokerHelper.java:374)\n        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n        at java.lang.reflect.Method.invoke(Method.java:324)\n        at org.codehaus.groovy.runtime.ReflectionMetaMethod.invoke(ReflectionMetaMethod.java:63)\n        at groovy.lang.MetaClass.doMethodInvoke(MetaClass.java:1020)\n        at groovy.lang.MetaClass.invokeStaticMethod(MetaClass.java:375)\n        at org.codehaus.groovy.runtime.Invoker.invokeMethod(Invoker.java:133)\n        at org.codehaus.groovy.runtime.InvokerHelper.invokeMethod(InvokerHelper.java:106)\n        at recursebug.main(recursebug)\n        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n        at java.lang.reflect.Method.invoke(Method.java:324)\n        at org.codehaus.groovy.runtime.ReflectionMetaMethod.invoke(ReflectionMetaMethod.java:63)\n        at groovy.lang.MetaClass.doMethodInvoke(MetaClass.java:1020)\n        at groovy.lang.MetaClass.invokeStaticMethod(MetaClass.java:375)\n        at org.codehaus.groovy.runtime.Invoker.invokeMethod(Invoker.java:133)\n        at org.codehaus.groovy.runtime.InvokerHelper.invokeMethod(InvokerHelper.java:106)\n        at groovy.lang.GroovyShell.run(GroovyShell.java:222)\n        at groovy.lang.GroovyShell.main(GroovyShell.java:92)\n        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n        at java.lang.reflect.Method.invoke(Method.java:324)\n        at org.codehaus.classworlds.Launcher.launchStandard(Launcher.java:410)\n        at org.codehaus.classworlds.Launcher.launch(Launcher.java:344)\n        at org.codehaus.classworlds.Launcher.main(Launcher.java:474)"
    ],
    [
        "GROOVY-3306",
        "GROOVY-1718",
        "NPE from groovydoc Getting a NPE from groovydoc:\n\n{code}\njava.lang.NullPointerException\n\tat org.codehaus.groovy.antlr.java.Java2GroovyConverter.visitDefault(Java2GroovyConverter.java:208)\n\tat org.codehaus.groovy.antlr.treewalker.TraversalHelper.visitNode(TraversalHelper.java:281)\n\tat org.codehaus.groovy.antlr.treewalker.TraversalHelper.openingVisit(TraversalHelper.java:507)\n\tat org.codehaus.groovy.antlr.treewalker.PreOrderTraversal.accept(PreOrderTraversal.java:38)\n\tat org.codehaus.groovy.antlr.treewalker.TraversalHelper.process(TraversalHelper.java:530)\n\tat org.codehaus.groovy.tools.groovydoc.GroovyRootDocBuilder.parseJava(GroovyRootDocBuilder.java:96)\n\tat org.codehaus.groovy.tools.groovydoc.GroovyRootDocBuilder.getClassDocsFromSingleSource(GroovyRootDocBuilder.java:75)\n\tat org.codehaus.groovy.tools.groovydoc.GroovyRootDocBuilder.buildTree(GroovyRootDocBuilder.java:165)\n\tat org.codehaus.groovy.tools.groovydoc.GroovyDocTool.add(GroovyDocTool.java:56)\n\tat org.codehaus.groovy.ant.Groovydoc.execute(Groovydoc.java:277)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n\tat java.lang.reflect.Method.invoke(Method.java:585)\n\tat org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:105)\n\tat org.apache.tools.ant.Task.perform(Task.java:348)\n\tat groovy.util.AntBuilder.nodeCompleted(AntBuilder.java:204)\n\tat groovy.util.BuilderSupport.doInvokeMethod(BuilderSupport.java:147)\n\tat groovy.util.AntBuilder.doInvokeMethod(AntBuilder.java:154)\n\tat groovy.util.BuilderSupport.invokeMethod(BuilderSupport.java:64)\n\tat org.codehaus.gant.GantBuilder.invokeMethod(GantBuilder.java:87)\n\tat org.codehaus.groovy.runtime.callsite.PogoMetaClassSite.call(PogoMetaClassSite.java:45)\n\tat org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:43)\n\tat org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:116)\n\tat org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:124)\n{code}",
        "Named-parameters without parentheses We can omit parentheses for top-level statements.\nFor instance, we can do:\n\nprintln \"foo\"\nfoo.bar 1, 2, 3\n\nBut we can't omit the parentheses for named arguments.\nThe purpose of this feature request is to support things like:\n\nmonster.move x: 5.meters, y: 10.meters\nfund.compare with:bench\ncredit account:\"1234\", amount:500.euros"
    ],
    [
        "GROOVY-1857",
        "GROOVY-3774",
        "Add a check for ant version 1.7 Groovy apparently needs ant version 1.7 to build, or at least ant 1.6.5 rather than ant 1.6.2, so it might be worth adding an explicit version check to the ant build file to prevent the build failing half-way through...\n\n  <target name=\"checkVersion\" description=\"Ensure that we're running ant 1.7\">\n     <fail message=\"Please install using ant 1.7\">\n        <condition>\n           <not>\n              <contains string=\"${ant.version}\" substring=\"1.7\"/>\n           </not>\n       </condition>\n     </fail>\n  </target>\n",
        "Horrified mathamaticians It appears that \"xxx\" * 2 is OK but 2 * \"xxx\" is not defined. If that is correct it means that groovy multiplication\ndoes not satisfy the commutative law. Mathamaticians would be horrified. :-)"
    ],
    [
        "GROOVY-3372",
        "GROOVY-2949",
        "groovy cannot find startGroovy if the groovy executable is a symlink A lot of people like to create symlinks to executable binaries or scripts. For example, many linux systems use the alternatives system to symlink \n\n/usr/bin/progname -> /etc/alternatives/progname -> /path/to/progname\n\nCurrently, groovy does not support this option. If I have:\n\n$ ls -l /home/greg/bin/groovy\nlrwxrwxrwx 1 greg greg 40 2009-02-22 22:49 /home/greg/bin/groovy -> /home/greg/opt/groovy/current/bin/groovy\n\nAnd I try to run:\n\n$ groovy -e 'print(\"HELLO GROOVY\")'\n\n### I get:\n.: 28: Can't open /home/greg/bin/startGroovy\n\nA simple fix would be (adapted from the jruby startup script):\n------------------------------\n1c1\n< #!/bin/sh\n---\n> #!/bin/ksh\n15a16,29\n> get_dirname()\n> {\n>     PRG=$0\n>     while [ -h \"$PRG\" ]; do\n>       link=`expr \"$(ls -l $PRG)\" : '.*-> \\(.*\\)'`\n>       if expr \"$link\" : '/' > /dev/null; then\n>           PRG=$link\n>       else\n>           PRG=\"`dirname $PRG`/$link\"\n>       fi\n>     done\n>     echo -n `dirname $PRG`\n> }\n> \n17c31\n< DIRNAME=`dirname \"$0\"`\n---\n> DIRNAME=`get_dirname $0`\n--------------------\n\nThe above was tested in bash, dash and pdksh.\n\nIdeally, the same patch would be applied to groovyc and groovysh as well",
        "Bug in ProxyGenerator - \"Repetitive method name/signature\" error The following code produces \"Repetitive method name/signature\" error.\n----\npublic abstract class A {\n   abstract protected void doIt()\n}\nclass B extends A {\n   void doIt() {}\n}\nnew ProxyGenerator(debug:true).instantiateDelegateWithBaseClass([:], [], new B())\n----\n\nAfter removing \"protected\" modifier it works properly.\n\n\nFull output:\n\nproxy source:\n------------------\nimport org.codehaus.groovy.runtime.InvokerHelper\nclass B_delegateProxy extends B {\n    private delegate\n    private closureMap\n    B_delegateProxy(map, delegate) {\n        this.closureMap = map\n        this.delegate = delegate\n    }\n    void doIt() { \n        Object[] args = []\n        InvokerHelper.invokeMethod(delegate, 'doIt', args)\n    }\n    void doIt() { \n        Object[] args = []\n        InvokerHelper.invokeMethod(delegate, 'doIt', args)\n    }\n}\nnew B_delegateProxy(map, delegate)\n------------------\nException thrown: groovy.lang.GroovyRuntimeException: Error creating proxy: startup failed, Script1.groovy: 9: Repetitive method name/signature for method 'void doIt()' in class 'B_delegateProxy'.\n @ line 9, column 5.Script1.groovy: 13: Repetitive method name/signature for method 'void doIt()' in class 'B_delegateProxy'.\n @ line 13, column 5.\n2 errors\n"
    ],
    [
        "GROOVY-159",
        "GROOVY-5174",
        "for in where the control variable id used in the range specification doesn't work a = 1\n    b = 5\n\n    for (a in a..b)\n    \tprintln a\n\nprints:\n\n1\n1\n1\n1\n1\n\n\nIt should have printed\n\n1\n2\n3\n4\n5",
        "Regression: JavaStubGenerator does not generate Javadocs In older Groovy-Versions JavaStubGenerator generated Stubs that contained the original Javadocs. Now the created stubs contain all annotations (thats new and solved in GROOVY-4118) but not the Javadocs.\n\nThat is an issue for all Projects using XDoclet (Annotations in Javadocs) like many Apache-Projects including Maven 2.x and 3.x. In Maven the created stubs are not recognized as Maven mojos. The dependent Issue for the GMaven-Plugin ist covered in GMAVEN-68."
    ],
    [
        "GROOVY-6262",
        "GROOVY-1258",
        "Sql.withTransaction setAutoCommit in finally not wrapped in try/catch When using an instance of Sql constructed with a DataSource, I experience a Connection Closed SQLException inside of withTransaction. In the finally clause, calling setAutoCommit(savedAutoCommit) causes another SQLException to be thrown. This means that cacheConnection remains true, and useConnection is still set. The connection is never closed and returned to the DataSource's pool which would allow it to be closed and a new one opened. The next time withTransaction is called, it uses the already set useConnection, which will throw the Connection Closed SQLException again.\n\nThis should be fixable by simply wrapping the setAutoCommit in a try/catch just as the other parts of closeResources wrap their actions.",
        "A extends A causes compiler freeze Following code causes compiler freeze\n\n// this causes freeze of groovy compiler\nclass A extends A { }"
    ],
    [
        "GROOVY-7378",
        "GROOVY-99",
        "Spaces in JAVA_OPTS env var  prevent launching of groovy Set environment variable JAVA_OPTS to have a system property including spaces/quotes/double-quotes.\n\n$ export JAVA_OPTS=\"-Dfoo='bar\\\" baz\\\"'\"\n$ groovy -e 'println System.getProperty(\"foo\"); println args' 'arg space' \"space quote' \" \"\\\"\"\n\nExpected output would be:\n'bar\" baz\"'\n[arg space, space quote' , \"]\n\nActual output is:\nError: Could not find or load main class baz\"'\n\n\nI can not comment on proper way to fix startGroovy.bat (assuming it suffers similarly), but included is diff that fixes startGroovy unix script to handle JAVA_OPTS such that quoted arguments are preserved as expected.\n\nI modeled the attached change which seems to resolve the issue for *nix on the tomcat `catalina.sh run` script block. \n\np.s. A concrete use case that bit me was trying to pass java.io.tmpdir to a groovy script to a path that included a space. There are outside reasons that modifying the script to read the desired value and set the system property is not a practical solution.",
        "modify variables outside closures, then recalling the closure does not use new value a = 0\n\tb = 1\n\t\n\tx = {\n\t\t\tSystem.out.println('on entry to closure a = ' + a)\n\t\t\tSystem.out.println('on entry to closure b = ' + b)\n\t\t\t\n\t\t\ta++\n\t\t\t\n\t\t\tSystem.out.println('on exit from closure a = ' + a)\n\t\t\tSystem.out.println('on exit from closure b = ' + b)\n\t\t}\n\t\t\n\tx.setDelegate(this)\n\t\n\tSystem.out.println('before first call a = ' + a)\n\tSystem.out.println('before first call b = ' + b)\n\t\n\tx.call()\n\t\n\tSystem.out.println('after first call a = ' + a)\n\tSystem.out.println('after first call b = ' + b)\n\tSystem.out.println()\n\t\n\ta *= 2\n\tb *= 2\n\t\n\tSystem.out.println('before second call a = ' + a)\n\tSystem.out.println('before second call b = ' + b)\n\t\n\tx.call()\n\t\n\tSystem.out.println('after second call a = ' + a)\n\tSystem.out.println('after second call b = ' + b)\t\n\t\n\nThis produces:\n\nbefore first call b = 1\non entry to closure a = 0\non entry to closure b = 1\non exit from closure a = 1\non exit from closure b = 1\nafter first call a = 1\nafter first call b = 1\n\nbefore second call a = 2\nbefore second call b = 2\non entry to closure a = 2\non entry to closure b = 1\non exit from closure a = 3\non exit from closure b = 1\nafter second call a = 3\nafter second call b = 2\n\n\nYou will see that b is still 1 in the second call to the closure."
    ],
    [
        "GROOVY-2056",
        "GROOVY-1557",
        "Ant Task GroovyC and IBM BigDecimal When using the groovyc task to compile classes that require IBMS Big decimal will not compile unless you add the -Jclasspath=${classpath} to the joingCompilationOptions.\n\nPlease see attachments\n\nThe compile-groovy target will work, but the compile-groovy-error will not work.",
        "calling getClass() fails if called on a java.lang.Class object calling getClass() fails if called on a java.lang.Class object. See and run the attached testcase."
    ],
    [
        "GROOVY-5204",
        "GROOVY-6157",
        "@Delegate to a method with optional params Groovyc fails to compile this code with a message like 'method foo is already defined in B'\n{code}\nclass A {\n  def foo(a = ''){}\n}\n\nclass B {\n  @Delegate A a = new A()\n  def foo(){}\n}\n{code}\n\nwhile these snippets are compiled pretty well\n{code}\nclass A {\n  def foo(a){}\n  def foo(){}\n}\n\nclass B {\n  @Delegate A a = new A()\n  def foo(){}\n}\n{code}\n\n{code}\nclass A {\n  def foo(a=''){}\n}\n\nclass B extends A{\n  def foo(){}\n}\n{code}\n\nIMHO there should be a warning (or nothing at all) instead of the compilation error.",
        "NPE in method.doMethodInvoke(obj) This will only throw NPE if run as a loaded script, it will work fine in the Groovy Console.\n\nI wanted to have a script where the user can call defined methods/functions \nwith no arguments without the parenthesis:\n\n{code:Java}\n def foo() { println \"Foo\" }\n \nfoo{code}\nI load the script with:\n{code:Java}\n config.setScriptBaseClass(EnvironmentScript.class.getCanonicalName());\n Script script = new GroovyShell(config).parse(source, fileName); \n abstract class EnvironmentScript extends Script {\n ...\n       // is for something else\n       @Override\n       Object invokeMethod(String name, Object args) {\n               try {\n                       return super.invokeMethod(name, args);\n               } catch (MissingMethodException mme) {\n                       return InvokerHelper.invokeMethod(environment, name, args);\n               }\n       }\n ...\n }{code} \n\nI get a NPE in [1]\n{code:Java}\n       @Override\n       Object getProperty(String property) {\n               def method = getMetaClass().getMetaMethod(property)\n               if (method != null) {\n                       return method.doMethodInvoke(this) [1]\n               } else if (environment.hasVariable(property)) {\n                       return environment.getVariable(property);\n               } else {\n                       return super.getProperty(property);\n               }\n       }{code}\nI try to change to:\n{code:Java}return method.doMethodInvoke(this, new Object[0]){code}\n\nBut I get the same NPE. The code is:\n\nDefaultGroovyMethods 12070:\nParameter:\nself    Test  (id=44)\nclosure null\nmetaClass       ExpandoMetaClass  (id=75)\nemc     null\n{code:Java}\n     /**\n     \n      * Sets/updates the metaclass for a given object to a closure.\n      *\n      * @param self the object whose metaclass we wish to update\n      * @param closure the closure representing the new metaclass\n      * @return the new metaclass value\n      * @throws GroovyRuntimeException if the metaclass can't be set for this\n      object * @since 1.6.0\n      */\n     \n     public static MetaClass metaClass (Object self, Closure closure){\n     \n         MetaClass emc = hasPerInstanceMetaClass(self);\n         if (emc == null) {\n         \n             final ExpandoMetaClass metaClass = new\n             ExpandoMetaClass(self.getClass(), false, true);\n             metaClass.initialize();\n             metaClass.define(closure);\n{code}\nExpandoMetaClass (795)\nParameter:\nthis    ExpandoMetaClass  (id=78)\nclosure null\n{code:Java}\n     public ExpandoMetaClass define(Closure closure) {\n     \n         final DefiningClosure definer = new DefiningClosure();\n         Object delegate = closure.getDelegate();\n         closure.setDelegate(definer);\n{code}\n{code}\n java.lang.NullPointerException\n       at groovy.lang.ExpandoMetaClass.define(ExpandoMetaClass.java:797)\n       at org.codehaus.groovy.runtime.DefaultGroovyMethods.metaClass(DefaultGroovyMethods.java:12084)\n       at org.codehaus.groovy.runtime.dgm$332.doMethodInvoke(Unknown Source) \n       at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n       at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57) \n       at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n       at java.lang.reflect.Method.invoke(Method.java:601)\n       at org.codehaus.groovy.runtime.callsite.PojoMetaMethodSite$PojoCachedMethodSite.invoke(PojoMetaMethodSite.java:189)\n       at org.codehaus.groovy.runtime.callsite.PojoMetaMethodSite.call(PojoMetaMethodSite.java:53)\n       at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:45)\n       at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:108)\n       at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:116)\n       at com.anrisoftware.mongoose.parser.EnvironmentScript.getProperty(EnvironmentScript.groovy:63)\n{code}"
    ],
    [
        "GROOVY-2091",
        "GROOVY-364",
        "enum support allow the definition of enums in groovy",
        "Class names can not have dot Class names like HTMLEditorKit.ParserCallback and HTML.Tag don't work. For example this script gives an error.\n\n#!/usr/bin/env groovy\ntest1 = new javax.swing.text.html.HTMLEditorKit.ParserCallback()\ntest2 = new javax.swing.text.html.HTML.Tag()\n\nCaught: groovy.lang.MissingClassException: No such class: javax.swing.text.html.HTMLEditorKit.ParserCallback in constructor call. At [2:8] MyParser.groovy\ngroovy.lang.MissingClassException: No such class: javax.swing.text.html.HTMLEditorKit.ParserCallback in constructor call. At [2:8]...\n\nJust to test that the class paths are right this script does not give an error.\n\n#!/usr/bin/env groovy\ntest = new javax.swing.text.html.HTML"
    ],
    [
        "GROOVY-2421",
        "GROOVY-1467",
        "edit command doesn't work on Mac When I try to edit the buffer in an external editor on a Mac, it just goes off into space and never returns:\n\nGroovy Shell (1.5.0, JVM: 1.5.0_13-119)\nType 'help' or '\\h' for help.\n---------------------------------------------------------------------------------------------------------------------------------------------------------------\ngroovy:000> set verbosity DEBUG\ngroovy:000> class Foo {\nDEBUG [org.codehaus.groovy.tools.shell.InteractiveShellRunner] Read line: class Foo {\nDEBUG [org.codehaus.groovy.tools.shell.Groovysh] Parsing: class Foo {\nDEBUG [org.codehaus.groovy.tools.shell.Groovysh] Parse incomplete\ngroovy:001> def bar\nDEBUG [org.codehaus.groovy.tools.shell.InteractiveShellRunner] Read line: def bar\nDEBUG [org.codehaus.groovy.tools.shell.Groovysh] Parsing: class Foo {\ndef bar\nDEBUG [org.codehaus.groovy.tools.shell.Groovysh] Parse incomplete\ngroovy:002> }\nDEBUG [org.codehaus.groovy.tools.shell.InteractiveShellRunner] Read line: }\nDEBUG [org.codehaus.groovy.tools.shell.Groovysh] Parsing: class Foo {\ndef bar\n}\nDEBUG [org.codehaus.groovy.tools.shell.Groovysh] Parse complete\nDEBUG [org.codehaus.groovy.tools.shell.Groovysh] Evaluating buffer...\nDEBUG [org.codehaus.groovy.tools.shell.Groovysh] Compiled script: groovysh_evaluate@eb41e5\nDEBUG [org.codehaus.groovy.tools.shell.Groovysh] Evaluation result: true (class java.lang.Boolean)\n===> true\ngroovy:000> display\nDEBUG [org.codehaus.groovy.tools.shell.InteractiveShellRunner] Read line: display\nDEBUG [org.codehaus.groovy.tools.shell.Groovysh] Executing command(display): org.codehaus.groovy.tools.shell.commands.DisplayCommand@b9dc79; w/args: []\nBuffer is empty\nDEBUG [org.codehaus.groovy.tools.shell.Groovysh] Result: null\ngroovy:000> edit\nDEBUG [org.codehaus.groovy.tools.shell.InteractiveShellRunner] Read line: edit\nDEBUG [org.codehaus.groovy.tools.shell.Groovysh] Executing command(edit): org.codehaus.groovy.tools.shell.commands.EditCommand@dc3491; w/args: []\nDEBUG [org.codehaus.groovy.tools.shell.commands.EditCommand.edit] Executing: vi /tmp/groovysh-buffer9051.groovy\nDEBUG [org.codehaus.groovy.tools.shell.commands.EditCommand.edit] Waiting for process: java.lang.UNIXProcess@ff557a\n\n\n",
        "Default method parameters A method declarator in an interface may include one or more default parameters.\nThese defaults should apply to only the parameters at the end of the parameter list.\nJSR-06 permits them to appear anywhere.\n\nQuestion: Do defaults in interfaces make sense? Could a class implementing the interface\noffer a different default value? This leads to ambiguity."
    ],
    [
        "GROOVY-1127",
        "GROOVY-5976",
        "align naming of the  newXxxStream and the toXxxWriter methods generally, the newXxxStream and the toXxxWriter methods\nare not consistently named regarding 'new' vs 'to'\n",
        "Type checker not able to choose best method I am also having problems when calling i.e. the StringBuilder.append() method:\n{code:Java}\nList<java.lang.String> listString = new ArrayList<java.lang.String>();\nlistString.add(\"A\");\nlistString.add(\"B\");\n\nStringBuilder strBuilder = new StringBuilder();\nfor(String str : listString){\n   strBuilder = strBuilder.append(str.toString());\n}\n{code}\n\n{code:Java}\nErrors:\n[ERROR] Script.groovy: 57: [Static type checking] - Reference to method is ambiguous. Cannot choose between [MethodNode@849099069[java.lang.StringBuilder append(java.lang.String)], MethodNode@779218368[java.lang.StringBuilder append(java.lang.CharSequence)], MethodNode@967831570[java.lang.AbstractStringBuilder append(java.lang.String)], MethodNode@1304054612[java.lang.AbstractStringBuilder append(java.lang.CharSequence)], MethodNode@27762602[java.lang.Appendable append(java.lang.CharSequence)]]\n\n[ERROR] Script.groovy: 57: [Static type checking] - Cannot assign value of type java.lang.Object to variable of type java.lang.StringBuilder\n{code}\n\nI am aware of the workaround of deactivating TypeChecking for certain areas of my code. However i suppose this is not the requested behaviour of @TypeChecked?\n\nBR"
    ],
    [
        "GROOVY-5712",
        "GROOVY-2763",
        "@TypeChecked and \"Charset ISO_8859_1_CHARSET = Charset.forName(\"ISO-8859-1\")\": Cannot assign value of type java.lang.Class to variable of type java.nio.charset.Charset {code}\npackage example\n\nimport groovy.transform.TypeChecked\n\nimport java.nio.charset.Charset\n\n@TypeChecked\nclass PotentialTypeCheckerIssueExample {\n        private static Charset ISO_8859_1_CHARSET = Charset.forName(\"ISO-8859-1\")\n\n        static void main(String[] args) {\n                new PotentialTypeCheckerIssueExample().printCharset()\n        }\n\n        def printCharset(){\n                println ISO_8859_1_CHARSET\n        }\n}\n{code}\nThe type checker reports\n{code}\nGroovy:[Static type checking] - Cannot assign value of type\njava.lang.Class to variable of type\njava.nio.charset.Charset        PotentialTypeCheckerIssueExample.groovy /GroovyTests/src/example        line\n9       Java Problem\n{code}\nThe code runs fine without @TypeChecked, the IDE shows the right\nreturn type (Charset).\n\nWhat's wrong here?",
        "derived class can not inherit its parent method \nThe following code can not be executed in Groovy Console, which complains:\n{code}\nException thrown: java.lang.NullPointerException: Cannot invoke method add() on null object\n\njava.lang.NullPointerException: Cannot invoke method add() on null object\n\tat Demo.<init>(Script7:82)\n{code}\n\n{code}\nimport java.awt.BorderLayout;\nimport java.awt.Container;\nimport java.awt.Dimension;\nimport java.awt.Toolkit;\n\nimport javax.swing.ImageIcon;\nimport javax.swing.JButton;\nimport javax.swing.JCheckBox;\nimport javax.swing.JComboBox;\nimport javax.swing.JFrame;\nimport javax.swing.JLabel;\nimport javax.swing.JPanel;\nimport javax.swing.JPasswordField;\nimport javax.swing.JTextField;\n\npublic class Demo extends JFrame{\n\n    Container contentPane;\n    ImageIcon img = new ImageIcon(\"002.jpg\");\n   \n    JPanel paneTop = new JPanel();\n    JPanel paneMid = new JPanel();\n    JPanel paneBut = new JPanel();\n    JPanel paneAll = new JPanel();\n   \n    JLabel lblTop = new JLabel();\n    JLabel lblName = new JLabel();\n    JLabel lblPwd = new JLabel();\n    JLabel lblApply = new JLabel();\n    JLabel lblForget = new JLabel();\n    JLabel lblModel = new JLabel();\n    JLabel lblNull = new JLabel();\n   \n    JTextField txtName = new JTextField(15);\n    JPasswordField txtPwd = new JPasswordField(15);\n   \n    JComboBox cmb = new JComboBox();\n   \n    JCheckBox chk = new JCheckBox();\n   \n    JButton btnKill = new JButton(\"&#26597;&#26432;&#26408;&#39532;\");\n    JButton btnSet = new JButton(\"&#35774;&#32622;\");\n    JButton btnLogin = new JButton(\"&#30331;&#24405;\");\n   \n   \n   \n    public Demo(){\n        lblTop.setIcon(img);\n        paneTop.add(lblTop);\n       \n        lblName.setText(\"QQ&#24080;&#21495;:\");\n        lblApply.setText(\"&#30003;&#35831;&#24080;&#21495;   \");\n        lblPwd.setText(\"QQ&#23494;&#30721;:\");\n        lblForget.setText(\"&#24536;&#35760;&#23494;&#30721;?\");\n        lblModel.setText(\"&#29366;&#24577;:\");\n       \n        String[] s1 = [\"&#38544;&#36523;\",\"&#22312;&#32447;\",\"&#24537;&#30860;\"] as String[];\n        cmb.addItem(s1[0]);\n        cmb.addItem(s1[1]);\n        cmb.addItem(s1[2]);\n       \n        chk.setText(\"&#33258;&#21160;&#30331;&#24405;\");\n       \n        paneMid.add(lblName);\n        paneMid.add(txtName);\n        paneMid.add(lblApply);\n       \n        paneMid.add(lblPwd);\n        paneMid.add(txtPwd);\n        paneMid.add(lblForget);\n       \n        paneMid.add(lblModel);\n        paneMid.add(cmb);\n        paneMid.add(chk);\n       \n        paneBut.add(btnKill);\n        paneBut.add(btnSet);\n        paneBut.add(btnLogin);\n       \n       contentPane = this.getContentPane();\n       \n       contentPane.add(paneTop,BorderLayout.NORTH);\n       contentPane.add(paneMid,BorderLayout.CENTER);\n       contentPane.add(paneBut,BorderLayout.SOUTH);\n       \n       \n       \n        setTitle(\"&#27426;&#36814;&#20351;&#29992;QQ\");\n        setSize(330,240);\n        Dimension screen = Toolkit.getDefaultToolkit().getScreenSize();\n        setLocation((screen.width - getSize().width)/2,(screen.height - getSize().height)/2 );\n        setVisible(true);\n        setResizable(false);\n        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);       \n    }\n   \n    public static void main(String[] args){\n        Demo d = new Demo();\n    }\n   \n}\n{code}\n\n\nAfter I commented the codes about contentPane variable,  the code can not be executed too, the error message suggest us that the inheritance in Groovy does not work:\n{code}\nException thrown: groovy.lang.MissingMethodException: No signature of method: Demo.setLocation() is applicable for argument types: (java.lang.Double, java.lang.Double) values: {475.0, 280.0}\n\ngroovy.lang.MissingMethodException: No signature of method: Demo.setLocation() is applicable for argument types: (java.lang.Double, java.lang.Double) values: {475.0, 280.0}\n\tat Demo.invokeMethod(Script8)\n\tat Demo.<init>(Script8:91)\n\n{code}\n\n\n{code}\nimport java.awt.BorderLayout;\nimport java.awt.Container;\nimport java.awt.Dimension;\nimport java.awt.Toolkit;\n\nimport javax.swing.ImageIcon;\nimport javax.swing.JButton;\nimport javax.swing.JCheckBox;\nimport javax.swing.JComboBox;\nimport javax.swing.JFrame;\nimport javax.swing.JLabel;\nimport javax.swing.JPanel;\nimport javax.swing.JPasswordField;\nimport javax.swing.JTextField;\n\npublic class Demo extends JFrame{\n\n    Container contentPane;\n    ImageIcon img = new ImageIcon(\"002.jpg\");\n   \n    JPanel paneTop = new JPanel();\n    JPanel paneMid = new JPanel();\n    JPanel paneBut = new JPanel();\n    JPanel paneAll = new JPanel();\n   \n    JLabel lblTop = new JLabel();\n    JLabel lblName = new JLabel();\n    JLabel lblPwd = new JLabel();\n    JLabel lblApply = new JLabel();\n    JLabel lblForget = new JLabel();\n    JLabel lblModel = new JLabel();\n    JLabel lblNull = new JLabel();\n   \n    JTextField txtName = new JTextField(15);\n    JPasswordField txtPwd = new JPasswordField(15);\n   \n    JComboBox cmb = new JComboBox();\n   \n    JCheckBox chk = new JCheckBox();\n   \n    JButton btnKill = new JButton(\"&#26597;&#26432;&#26408;&#39532;\");\n    JButton btnSet = new JButton(\"&#35774;&#32622;\");\n    JButton btnLogin = new JButton(\"&#30331;&#24405;\");\n   \n   \n   \n    public Demo(){\n        lblTop.setIcon(img);\n        paneTop.add(lblTop);\n       \n        lblName.setText(\"QQ&#24080;&#21495;:\");\n        lblApply.setText(\"&#30003;&#35831;&#24080;&#21495;   \");\n        lblPwd.setText(\"QQ&#23494;&#30721;:\");\n        lblForget.setText(\"&#24536;&#35760;&#23494;&#30721;?\");\n        lblModel.setText(\"&#29366;&#24577;:\");\n       \n        String[] s1 = [\"&#38544;&#36523;\",\"&#22312;&#32447;\",\"&#24537;&#30860;\"] as String[];\n        cmb.addItem(s1[0]);\n        cmb.addItem(s1[1]);\n        cmb.addItem(s1[2]);\n       \n        chk.setText(\"&#33258;&#21160;&#30331;&#24405;\");\n       \n        paneMid.add(lblName);\n        paneMid.add(txtName);\n        paneMid.add(lblApply);\n       \n        paneMid.add(lblPwd);\n        paneMid.add(txtPwd);\n        paneMid.add(lblForget);\n       \n        paneMid.add(lblModel);\n        paneMid.add(cmb);\n        paneMid.add(chk);\n       \n        paneBut.add(btnKill);\n        paneBut.add(btnSet);\n        paneBut.add(btnLogin);\n       \n      // contentPane = this.getContentPane();\n       \n       //contentPane.add(paneTop,BorderLayout.NORTH);\n      // contentPane.add(paneMid,BorderLayout.CENTER);\n      // contentPane.add(paneBut,BorderLayout.SOUTH);\n       \n       \n       \n        setTitle(\"&#27426;&#36814;&#20351;&#29992;QQ\");\n        setSize(330,240);\n        Dimension screen = Toolkit.getDefaultToolkit().getScreenSize();\n        setLocation((screen.width - getSize().width)/2,(screen.height - getSize().height)/2 );\n        setVisible(true);\n        setResizable(false);\n        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);       \n    }\n   \n    public static void main(String[] args){\n        Demo d = new Demo();\n    }\n   \n}\n{code}"
    ],
    [
        "GROOVY-7073",
        "GROOVY-1563",
        "Delegating methods are not generated when using @Delegate and there is $ character in method name The following throws a missing method exception:\n{code}\nclass HasDollar {\n    void $() {\n        println '$'\n    }\n}\n\nclass Delegating {\n\n    @Delegate\n    HasDollar hasDollar = new HasDollar()\n}\n\nnew Delegating().$()\n{code}\n\nIf on the other hand we change the method name not to contain dollar character then there is no exception thrown:\n{code}\nclass HasDollar {\n    void dollar() {\n        println '$'\n    }\n}\n\nclass Delegating {\n\n    @Delegate\n    HasDollar hasDollar = new HasDollar()\n}\n\nnew Delegating().dollar()\n{code}\n\nThis is a *blocking issue* for Geb. It's impossible to compile it using latest Groovy which prevents us from updating the version used to build it - it's still using 1.8.9.",
        "Confusing error message when using : instead of \"extends\" In the following class definition:\n\nclass Foo : OutputStream { }\n\nthe parser complains about \"class,\" but the problem is the :, which is C++ syntax; it should be \"extends.\""
    ],
    [
        "GROOVY-4697",
        "GROOVY-36",
        "Allow @Synchonized to be used in fields that contain a closure {{@Synchronized}} can only annotate methods at the moment but it would be great if it were able to annotate closure properties too, for example Grails/Griffon controller actions\n\n{code}\nclass GriffonController = {\n   @groovy.transform.Synchronized // fails :-(\n   def someAction = { ... }\n}\n{code}\n\nI propose for @Synchronized to be applied to Fields. The AST transformation must check that a field has an initial value of type ClosureExpression, if not then a compile error should be thrown.",
        "Create some javadoc of all the new methods added to the JDK We have various new methods we've added to the JDK inside Groovy. e.g. on Object we have inspect(), each(), find(), findAll() and so forth.\n\nWe should create some kind of javadoc that shows all the new methods added by Groovy so folks can easily see what's available. Maybe we could take the JDK javadoc and adorn all the new Groovy methods are & host it on the groovy site?\n\nOr just show the new methods added by Groovy (which might be easier).\n\nRight now the new methods are all in org.codehaus.groovy.runtime.DefaultGroovyMethods"
    ],
    [
        "GROOVY-5808",
        "GROOVY-5258",
        "Cannot inline Closure when using \"with\" and CompileStatic This code works:\n\n{code}\n@groovy.transform.CompileStatic\nString fn( List<String> a ) {\n  Closure<String> fn = { String x, String y ->\n    \"$x $y\".toString()\n  }\n  a.with fn\n}\n\nassert fn( [ 'a', 'b' ] ) == 'a b'\n{code}\n\nHowever, if we try to inline the Closure\n\n{code}\n@groovy.transform.CompileStatic\nString fn( List<String> a ) {\n  a.with { String x, String y ->\n    \"$x $y\".toString()\n  }\n}\n\nassert fn( [ 'a', 'b' ] ) == 'a b'\n{code}\n\nwe get:\n\n{code}\n[Static type checking] - Unexpected number of parameters for a with call\n at line: 3, column: 10\n{code}\n\nGetting rid of {{@groovy.transform.CompileStatic}} makes this second form work again",
        "Static type checker incorrectly handles assignments of variables used as parameters in control structures Imagine the following code:\n{code}\nDouble foo(Integer x) { x+1 }\nInteger foo(Double x) { x+1 }\ndef x = 0\nfor (int i=0;i<10;i++) {\n   // there are two possible target methods. This is not a problem for STC, but it is for static compilation\n   x = foo(x)\n}\n{code}\n\nThe type checker should not allow this to compile. There are more cases (even more complex) like this in the patch ({{groovy.transform.stc.LoopsSTCTest}})."
    ],
    [
        "GROOVY-5993",
        "GROOVY-7124",
        "Compiler fails on valid override of Object#finalize(), incorrectly reporting vsibility Compiling my project with Gradle, I get this:\n\n{code}\npaul@windowbox:~/ws/MetaWeb$ grb\nversionStamp=0.0.1-dev+svn363:402M\n:Dios:compileJava UP-TO-DATE\n:Dios:compileGroovy UP-TO-DATE\n:Dios:processResources UP-TO-DATE\n:Dios:classes UP-TO-DATE\n:Dios:jar UP-TO-DATE\n:MetaWeb:compileJava UP-TO-DATE\n:MetaWeb:compileGroovy\nstartup failed:\n/Users/paul/ws/MetaWeb/src/main/groovy/com/metaficient/web/gui/core/DynamicallyTypedBeanItem.groovy: 42: The method finalize should be public as it implements the corresponding method from interface java.lang.Object\n. At [42:2]  @ line 42, column 2.\n   \t@Override\n    ^\n\n/Users/paul/ws/MetaWeb/src/main/groovy/com/metaficient/web/gui/core/CollectionContainer.groovy: 82: The method finalize should be public as it implements the corresponding method from interface java.lang.Object\n. At [82:2]  @ line 82, column 2.\n   \t@Override\n    ^\n\n2 errors\n\n:MetaWeb:compileGroovy FAILED\n\nFAILURE: Build failed with an exception.\n\n* What went wrong:\nExecution failed for task ':MetaWeb:compileGroovy'.\n> Compilation failed; see the compiler error output for details.\n\n* Try:\nRun with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output.\n\nBUILD FAILED\n\nTotal time: 9.951 secs\n{code}\n\nThe build file is set to use Groovy 1.8.8.\n\nThe thing here is that the declaration of Object#finalize() is *\"protected\"*, not \"public\", as the compiler reports. My overrides are correct in that sense, so it would seem the compiler is mistaken.\n\nI have seen this before under GRECLIPSE, and filed a Jira for that (https://jira.codehaus.org/browse/GRECLIPSE-1430), but now this is happening outside of the IDE - so it would seem to be a Groovy compiler issue.\n\nAndrew Eisenberg has reported having a test case for this which I will add as soon as I can get it from him\n\nI have not tested with 2.x, as my codebase will not compile under that version.\n",
        "Issue when a the version of a class in local SDK is different from compiled one As of Android 5.0 (API 21), Bundle (http://developer.android.com/reference/android/os/Bundle.html) class now inherits from BaseBundle (http://developer.android.com/reference/android/os/BaseBundle.html), which was added on API 21.\n\nAs now `putInt()`, `putString()`, etc. - former *Bundle* methods - are methods of *BaseBundle* which *Bundle* inherits *but not override*, for some reason on API versions lower than 21 when you try to call those methods from a *Bundle object* it will throw:\n\njava.lang.NoClassDefFoundError: android.os.BaseBundle\n\nIf you call its constructor, which in API 21 only does:\n\npublic Bundle() {\n    super();\n}\n\nIt will work as Groovy still looks for the constructor on that class and while on API lower than 21 the code is different, there is no problem.\n\nSo even when the *BaseBundle* class is not there Groovy still tries to call it. If you try to use those methods on a `.java` file they will work flawlessly."
    ],
    [
        "GROOVY-6959",
        "GROOVY-5887",
        "java.lang.VerifyError: Bad <init> method call from inside of a branch This error appears to not be Groovy specific as I was able to reproduce it with Groovy 2.2.1 up to 2.3.4 when JDK7u65 was in use. There's no error with JDK7u60.\n\nStacktrace\n\n{code}\njava.lang.VerifyError: Bad <init> method call from inside of a branch\nException Details:\n  Location:\n    org/opendolphin/server/adapter/MockPrintWriter.<init>()V @126: invokespecial\n  Reason:\n    Error exists in the bytecode\n  Bytecode:\n    0000000: b800 184c 04bd 001a 5903 121c 5359 10ff\n    0000010: 1204 b800 222a 5fab 0000 0138 0000 0009\n    0000020: 8355 379f 0000 0051 aad3 b1ff 0000 006d\n    0000030: d9ca eaf6 0000 0080 daf2 35d5 0000 009f\n    0000040: e925 fa09 0000 00b4 0a30 63a7 0000 00d1\n    0000050: 1030 b9ba 0000 00e6 3bdc c40d 0000 0107\n    0000060: 4ad1 f42c 0000 0123 5f5a 5903 3212 24b8\n    0000070: 0028 c000 245f 5904 32b8 002e 5f57 b700\n    0000080: 31a7 00d8 5f5a 5903 32b8 0037 c000 395f\n    0000090: 57b7 003c a700 c55f 5a59 0332 123e b800\n    00000a0: 28c0 003e 5f59 0432 b800 37c0 0039 5f57\n    00000b0: b700 41a7 00a6 5f5a 5903 3212 24b8 0028\n    00000c0: c000 245f 57b7 0044 a700 915f 5a59 0332\n    00000d0: b800 37c0 0039 5f59 0432 b800 37c0 0039\n    00000e0: 5f57 b700 47a7 0074 5f5a 5903 3212 49b8\n    00000f0: 0028 c000 495f 57b7 004c a700 5f5f 5a59\n    0000100: 0332 124e b800 28c0 004e 5f59 0432 123e\n    0000110: b800 28c0 003e 5f57 b700 51a7 003e 5f5a\n    0000120: 5903 3212 49b8 0028 c000 495f 5904 32b8\n    0000130: 002e 5f57 b700 54a7 0022 5f5a 5903 3212\n    0000140: 3eb8 0028 c000 3e5f 57b7 0057 a700 0dbb\n    0000150: 0059 5912 5bb7 005c bf57 2ab6 0060 4d2c\n    0000160: 2a5f b500 622c 57b1                    \n  Stackmap Table:\n    full_frame(@104,{UninitializedThis,Object[#102]},{Object[#104],UninitializedThis})\n    full_frame(@132,{UninitializedThis,Object[#102]},{Object[#104],UninitializedThis})\n    full_frame(@151,{UninitializedThis,Object[#102]},{Object[#104],UninitializedThis})\n    full_frame(@182,{UninitializedThis,Object[#102]},{Object[#104],UninitializedThis})\n    full_frame(@203,{UninitializedThis,Object[#102]},{Object[#104],UninitializedThis})\n    full_frame(@232,{UninitializedThis,Object[#102]},{Object[#104],UninitializedThis})\n    full_frame(@253,{UninitializedThis,Object[#102]},{Object[#104],UninitializedThis})\n    full_frame(@286,{UninitializedThis,Object[#102]},{Object[#104],UninitializedThis})\n    full_frame(@314,{UninitializedThis,Object[#102]},{Object[#104],UninitializedThis})\n    full_frame(@335,{UninitializedThis,Object[#102]},{Object[#104],UninitializedThis})\n    full_frame(@345,{Object[#2],Object[#102]},{Object[#104]})\n\n\tat java.lang.Class.privateGetDeclaredConstructors(Class.java:2532)\n\tat java.lang.Class.getDeclaredConstructors(Class.java:1901)\n\tat org.codehaus.groovy.util.LazyReference.getLocked(LazyReference.java:46)\n\tat org.codehaus.groovy.util.LazyReference.get(LazyReference.java:33)\n\tat org.opendolphin.server.adapter.InvalidationServletSpec.mockServlet_closure4(InvalidationServletSpec.groovy:41)\n\tat groovy.lang.Closure.call(Closure.java:423)\n\tat org.opendolphin.server.adapter.InvalidationServlet.doPost(InvalidationServlet.groovy:29)\n\tat org.opendolphin.server.adapter.InvalidationServletSpec.with 'invalidate' in the path info, the session should be invalidated(InvalidationServletSpec.groovy:18)\n{code}\n\nSteps to reproduce\n\n1. clone the open-dolphin repository located at https://github.com/canoo/open-dolphin/\n2. switch to the 'update_gradle_build' branch\n3. make sure you have JDK7u65 as your current JDK\n4. gradlew test (subproject/server should have a failing test)\n\nSwitch to JDK7u60 to see the error disappear.",
        "The spread-call syntax is statically compiled for collections, but not for arrays {code}\n@groovy.transform.CompileStatic\nclass Test {\n    def passing = 'a,b,c'.split(/,/).toList()*.trim()\n    def failing = 'a,b,c'.split(/,/)*.trim()\n}\n{code}"
    ],
    [
        "GROOVY-3309",
        "GROOVY-1515",
        "comparisons with NaN should always return false The following assertions should all pass; the third fails.\n\nassert !(Double.NaN == 0)\nassert !(Double.NaN < 0)\nassert !(Double.NaN > 0)\n\nA NaN should also not equal a NaN.\n\nassert Double.NaN != Double.NaN\n\n\n",
        "Node.breadthFirst() Ordering problem Node.breadthFirst() displays the wrong order after the first two levels.\nPatch and Test attached.\nThe test relies on the XmlTraversalTestUtil.groovy file attached to GROOVY-1514."
    ],
    [
        "GROOVY-4",
        "GROOVY-5689",
        "name parameter arguments in method calls and ctors support named parameter arguments such as\n\n    foo(a:1234, b:542)\n\nUses NamedArgumentListExpression which is-a MapExpression.\n\nRight now we implement the above to match a method\n\n    foo(Map map)\n    foo(Object object)\n\nthough we should also allow it to invoke any Java method (or at least any groovy method). Though we need metadata of the names of the parameters to be able to do this.",
        "ClassCastException Double->Float with -= += operators and closures The ClassCastException is thrown only in combination of a -= (or +=) operator and a closure.\n{code} \nvoid doesNotWork() {\n  float myFloat = 40f\n  myFloat -= 20f\n  println \"doesNotWork() $myFloat\" // the exception is thrown here, but because of the combination of the -= and the closure\n  (0..1).each { i -> // this can be any closure - doesn't matter\n    println \"doesNotWork() in the closure: $myFloat\"\n  }\n}\n{code}\n\nDid not occure with 1.8.3."
    ],
    [
        "GROOVY-4709",
        "GROOVY-4060",
        "@Interrupt AST transformations should not be applied on abstract methods When a class is annotated with @ThreadInterrupt, @ConditionalInterrupt or @TimedInterrupt, a NullPointerException is thrown when visiting an abstract method.\n\n{code}\njava.lang.NullPointerException\n    at org.codehaus.groovy.ast.CodeVisitorSupport.visitBlockStatement(CodeVisitorSupport.java:35)\n    at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitBlockStatement(ClassCodeVisitorSupport.java:165)\n    at org.codehaus.groovy.ast.stmt.BlockStatement.visit(BlockStatement.java:69)\n    at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClassCodeContainer(ClassCodeVisitorSupport.java:101)\n    at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitConstructorOrMethod(ClassCodeVisitorSupport.java:112)\n    at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitMethod(ClassCodeVisitorSupport.java:123)\n    at org.codehaus.groovy.transform.ThreadInterruptibleASTTransformation.super$3$visitMethod(ThreadInterruptibleASTTransformation.groovy)\n    at sun.reflect.GeneratedMethodAccessor184.invoke(Unknown Source)\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n    at java.lang.reflect.Method.invoke(Method.java:597)\n    at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:90)\n    at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:233)\n    at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:1054)\n    at org.codehaus.groovy.runtime.ScriptBytecodeAdapter.invokeMethodOnSuperN(ScriptBytecodeAdapter.java:128)\n    at org.codehaus.groovy.transform.ThreadInterruptibleASTTransformation.visitMethod(ThreadInterruptibleASTTransformation.groovy:73)\n    at org.codehaus.groovy.ast.ClassNode.visitContents(ClassNode.java:1056)\n    at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClass(ClassCodeVisitorSupport.java:50)\n    at org.codehaus.groovy.transform.AbstractInterruptibleASTTransformation.visit(AbstractInterruptibleASTTransformation.java:89)\n    at org.codehaus.groovy.transform.ASTTransformationVisitor.visitClass(ASTTransformationVisitor.java:129)\n    at org.codehaus.groovy.transform.ASTTransformationVisitor$2.call(ASTTransformationVisitor.java:172)\n    at org.codehaus.groovy.control.CompilationUnit.applyToPrimaryClassNodes(CompilationUnit.java:948)\n    at org.codehaus.groovy.control.CompilationUnit.doPhaseOperation(CompilationUnit.java:533)\n    at org.codehaus.groovy.control.CompilationUnit.processPhaseOperations(CompilationUnit.java:511)\n    at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:488)\n    at groovy.lang.GroovyClassLoader.doParseClass(GroovyClassLoader.java:283)\n    at groovy.lang.GroovyClassLoader.parseClass(GroovyClassLoader.java:264)\n{code}\n",
        "import should work with runtime additions to the classpath The import statement should look up dependencies in the runtime classLoader. \n\nE.g If I dynamically add foo.jar to the classloader at runtime, the import statement(s) below it should be able to resolve any class contained in this jar.\n\nIn this way I could do the following:\n\n{code:title=Bar.groovy}\n\ndef url = new URL(\"../lib/foo.jar\")\n\t\t\nclazz.getClass().getClassLoader().getRootLoader().addURL(url)\n\nimport foo.*\n\ndef myFoo = new Foo() // member of foo\n{code}\n\n\n"
    ],
    [
        "GROOVY-3174",
        "GROOVY-7102",
        "Mark generated getters and setters as synthetic I see that most of the methods and apparently all of the fields generated by Groovy are marked as synthetic, with the exception of the generated getters and setters.\n\nIf the principle is that members that are not declared by the user are marked as synthetic, then it seems to me that this should apply to generated getters and setters.\n",
        "Allow static compliation for with-Closure C\u00c3\u00a9dric, congratulations on the closure parameter inference in 2.3. Major effort and very well appreciated!\n\nResolving methods via the closure delegate falls into the domain of runtime metaprogramming, I guess. I've searched the sources for .setDelegate and there are not too many occurences outside typical builder scenarios.\n\nBut for me, coming from a Visual Basic background, the notable exception is the .with { } syntax. Inferring the type of \"delegate\" for that should be trivial. Could it be possible with CompileStatic to make the uploaded script run in a future edition of Groovy?\n\nIt was a bit of a suprise to me that the various with<Something> methods in the GDK do not utilize setDelegate(). Especially on withPrintWriter the output of a simple println() still goes to standard output. But with @CompileStatic that was certainly an advantage and saved you a lot of headache."
    ],
    [
        "GROOVY-187",
        "GROOVY-6396",
        "cleaner alternative to using static void main() Maybe we should auto-create a static main method for any object that has a String[] constructor and implements the Runnable interface?\n\ne.g.\n\npublic class Foo implements Runnable {\n   public Foo(String[] args) {\n    ...\n   }\n\n   public void run() { \n     ....\n   }\n}",
        "same linkedlist code different behavior between groovy and java I am using `linkedlist` as a stack in groovy \n\nas doc says, `pop()` take elm from the first\n\n    Stack Method  Equivalent Deque Method  \n    push(e)       addFirst(e) \n    pop()         removeFirst()\n\n\nso a `linkedlist` [1,2,3] should pop() 1 2 3\n\nand it does in Java, but does NOT in groovy. WHY?\n\ntest below\n\n{code:title=A.java}\nimport java.util.*;\n    \npublic class A{\n    \n    \n    public static void main(String[] args){\n    \n        String[] x = \"1/2/3/\".split(\"/\");\n        LinkedList <String> stack = new LinkedList<String>(Arrays.asList(x));\n        System.out.println(stack.pop());\n    }\n}\n{code}\n\ncompile and run\n{noformat}\n$ javac A.java\n$ java A\n1\n{noformat}\nruning in groovy\n{noformat}    \n$ ln -s A.java A.groovy\n$ groovy A.groovy\n3\n{noformat}\n\nhere is my java and groovy version\n{noformat}\n$ java -version\njava version \"1.6.0_51\"\nJava(TM) SE Runtime Environment (build 1.6.0_51-b11-457-11M4509)\nJava HotSpot(TM) 64-Bit Server VM (build 20.51-b01-457, mixed mode)\n\n$ groovy -version\nGroovy Version: 2.1.5 JVM: 1.6.0_51 Vendor: Apple Inc. OS: Mac OS X\n{noformat}\n"
    ],
    [
        "GROOVY-3982",
        "GROOVY-7282",
        "swingbuilder tabbedpane does not allow bind to selectedindex From Griffon's JIRA http://jira.codehaus.org/browse/GRIFFON-130\n\n{quote}\nWhen trying to bind a integer variable from the model to selectedindex on tabbedpane in view, throws error.\n\nEx:\ntabbedPane(id:'tabs', selectedIndex: bind(value:model.tabSelected)) { ... }\n\nI'm a bit new to griffon so I tried variations to make sure I'm doing this right but saw someone else mention that bindings do not work on selectedIndex on tabbedPane and to file a bug. No bug was filed when I did a search so I wanted to make sure this went in.\n{quote}\n\nselectedIndex receives special treatment in TabbedPaneFactory which may interfere with binding",
        "GroovyScriptEngine does not reload static imports on change if a script loads a class from mypackage using static import and the class is changed, the next run will not recompile the dependent class.\nScript:\n\nimport static mypackage.Test.*;\n\ndoit()\n\nClass:\npackage mypackage; \n\nclass Test {\n\tstatic def doit(){ \n\t\tprintln(\"Hello\")\n\t}\n}\n\nReproducer: run script in GroovyScriptEngine, then update the println in class Test to \"Hello2\", run script again, still Hello is printed.\n\nIt works with normal imports."
    ],
    [
        "GROOVY-6357",
        "GROOVY-7018",
        "Inner classes in Groovy should have the same access modifiers as in Java There are differences in the flags/access modifiers for inner classes between Java and Groovy.\n\nJava code:\n{code}\npublic class Java {\n              class InnerPackage { }\n    public    class InnerPublic { }\n    protected class InnerProtected { }\n    private   class InnerPrivate { }\n}\n{code}\n\nGroovy code:\n{code}\nimport groovy.transform.PackageScope\n\nclass Groovy {\n    @PackageScope class InnerPackage { }\n    public        class InnerPublic { }\n    protected     class InnerProtected { }\n    private       class InnerPrivate { }\n}\n{code}\n\nFlags for inner classes (extracted via javap):\n|| ||package scope ||public scope ||protected scope ||private scope ||\n|Java   |ACC_SUPER |ACC_SUPER, ACC_PUBLIC |ACC_SUPER, ACC_PUBLIC                |ACC_SUPER |\n|Groovy |ACC_SUPER |ACC_SUPER, ACC_PUBLIC |ACC_SUPER, 0x4 (means ACC_PROTECTED) |ACC_SUPER, 0x2 (means ACC_PRIVATE) |\n\nComment from blackdrag:\n{quote}\nI think as Groovy does is correct. But we did learn only recently, that \nthe VMs have trouble doing it like this. AS a result we forbid the \nprivate modifer on classes... but looks like we forgot inner classes.\n{quote}\n\nThese different flags for example result in Cobertura failing to instrument the inner classes because ASM throws this exception:\n{noformat}\nUnable to instrument file build/instrumented_classes/Groovy$InnerPrivate.class\njava.lang.IllegalArgumentException: Invalid access flags: 34\n        at org.objectweb.asm.util.CheckClassAdapter.checkAccess(Unknown Source)\n        at org.objectweb.asm.util.CheckClassAdapter.visit(Unknown Source)\n        at org.objectweb.asm.ClassVisitor.visit(Unknown Source)\n        at net.sourceforge.cobertura.instrument.pass1.DetectDuplicatedCodeClassVisitor.visit(DetectDuplicatedCodeClassVisitor.java:205)\n        at org.objectweb.asm.ClassReader.accept(Unknown Source)\n        at org.objectweb.asm.ClassReader.accept(Unknown Source)\n        at net.sourceforge.cobertura.instrument.CoberturaInstrumenter.instrumentClass(CoberturaInstrumenter.java:153)\n        at net.sourceforge.cobertura.instrument.CoberturaInstrumenter.instrumentClass(CoberturaInstrumenter.java:121)\n        at net.sourceforge.cobertura.instrument.CoberturaInstrumenter.addInstrumentationToSingleClass(CoberturaInstrumenter.java:234)\n        at net.sourceforge.cobertura.instrument.Main.addInstrumentationToSingleClass(Main.java:298)\n        at net.sourceforge.cobertura.instrument.Main.addInstrumentation(Main.java:307)\n        at net.sourceforge.cobertura.instrument.Main.addInstrumentation(Main.java:316)\n        at net.sourceforge.cobertura.instrument.Main.parseArguments(Main.java:399)\n        at net.sourceforge.cobertura.instrument.Main.main(Main.java:421)\n        at net.saliman.gradle.plugin.cobertura.CoberturaRunner.instrument(CoberturaRunner.java:79)\n{noformat}",
        "GroovyClassLoader addClasspath RegexPattern issue When adding Groovy Files from the file system to the GroovyClassLoader's classpath grabbed from a default java properties file (\"/\" instead of \"\\\"))\nThen the addClasspath() method uses a simple URL instead of the File URL\n\nThis is due to a simple mistake in this mentioned method:\n\n{code}\npublic void addClasspath(final String path) {\n....\n     if (!URI_PATTERN.matcher(path).matches()) {\n          newURI = new File(path).toURI();\n     } else {\n          newURI = new URI(path);\n     }\n}\n\nprivate static final Pattern URI_PATTERN = Pattern.compile(\"\\\\p{Alpha}[-+.\\\\p{Alnum}]*:[^\\\\\\\\]*\");\n{code}\n\nThe URI_PATTERN which should match \"URIs but not Windows filenames\" doesn't work as expected.\nIt matches i.e. C:/xxx/file.ext \nThis is related to using forward instead of backslashes - which souldn't matter.\n\nThis was i.e. NOT the case for Groovy 2.1.3"
    ],
    [
        "GROOVY-1371",
        "GROOVY-2289",
        "Add ability to specify parent class loader for InteractiveShell ",
        "Use clause does not work with dinamically created methods When I try to run the following code:\n\n{code:title=UseTest.groovy|borderStyle=solid}\nclass UseTest {\n static main(args) {\n  UseTest.metaClass.'static'.sayHello = {String str ->\n        println \"Hello $str\"\n       }\n       \n       use (UseTest) {\n        \"World\".sayHello()\n       }\n }\n \n/* static void sayHello(String str) {\n  println \"Hi $str\"\n } */\n} \n{code}\n\nI get this error:\n\n{color:red} \nCaused by: groovy.lang.MissingMethodException: No signature of method: java.lang.String.sayHello() is applicable for argument types: () values: {}\n at org.codehaus.groovy.runtime.ScriptBytecodeAdapter.unwrap(ScriptBytecodeAdapter.java:56)\n at org.codehaus.groovy.runtime.ScriptBytecodeAdapter.invokeMethodN(ScriptBytecodeAdapter.java:172)\n at org.codehaus.groovy.runtime.ScriptBytecodeAdapter.invokeMethod0(ScriptBytecodeAdapter.java:213)\n at UseTest$_main_closure2.doCall(UseTest.groovy:8)\n at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)\n at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)\n at java.lang.reflect.Method.invoke(Unknown Source)\n at org.codehaus.groovy.runtime.metaclass.ReflectionMetaMethod.invoke(ReflectionMetaMethod.java:56)\n at org.codehaus.groovy.runtime.MetaClassHelper.doMethodInvoke(MetaClassHelper.java:538)\n at org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:243)\n at org.codehaus.groovy.runtime.ScriptBytecodeAdapter.invokeMethodOnCurrentN(ScriptBytecodeAdapter.java:78)\n at UseTest$_main_closure2.doCall(UseTest.groovy)\n at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)\n at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)\n at java.lang.reflect.Method.invoke(Unknown Source)\n at org.codehaus.groovy.runtime.metaclass.ReflectionMetaMethod.invoke(ReflectionMetaMethod.java:56)\n at org.codehaus.groovy.runtime.MetaClassHelper.doMethodInvoke(MetaClassHelper.java:538)\n at org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:243)\n at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:643)\n at groovy.lang.Closure.call(Closure.java:291)\n at groovy.lang.Closure.call(Closure.java:286)\n at org.codehaus.groovy.runtime.GroovyCategorySupport.use(GroovyCategorySupport.java:135)\n at org.codehaus.groovy.runtime.DefaultGroovyMethods.use(DefaultGroovyMethods.java:277)\n at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)\n at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)\n at java.lang.reflect.Method.invoke(Unknown Source)\n at org.codehaus.groovy.runtime.metaclass.ReflectionMetaMethod.invoke(ReflectionMetaMethod.java:56)\n at org.codehaus.groovy.runtime.metaclass.NewInstanceMetaMethod.invoke(NewInstanceMetaMethod.java:54)\n at org.codehaus.groovy.runtime.MetaClassHelper.doMethodInvoke(MetaClassHelper.java:538)\n at groovy.lang.MetaClassImpl.invokeStaticMethod(MetaClassImpl.java:930)\n at groovy.lang.ExpandoMetaClass.invokeStaticMethod(ExpandoMetaClass.java:959)\n at org.codehaus.groovy.runtime.Invoker.invokeStaticMethod(Invoker.java:121)\n at org.codehaus.groovy.runtime.InvokerHelper.invokeStaticMethod(InvokerHelper.java:84)\n at org.codehaus.groovy.runtime.ScriptBytecodeAdapter.invokeStaticMethodN(ScriptBytecodeAdapter.java:230)\n at UseTest.main(UseTest.groovy:7)\n ... 8 more\n{color}\n\nBut if I uncomment the code, i get a nice:\nHi World\nmessage.\n\nThis indicate that Groovy is ignoring dinamically created methods when using use clause. Can this be fixed?"
    ],
    [
        "GROOVY-4034",
        "GROOVY-3950",
        "Mixin's getClass() method replaces original getClass() implementation {code}\nclass M {\n    def doIt() {\n        assert metaClass.owner.class == M // passes but shouldn't, should be T\n    }\n}\n\nclass T {}\nT.mixin(M)\nnew T().doIt()\n{code}",
        "Groovy 1.8 compiler performance improvements "
    ],
    [
        "GROOVY-3651",
        "GROOVY-1265",
        "Compiler cannot resolve inherited nested types by their simple name JavaInterface.java:\n\n{code}\npublic interface JavaInterface {\n  public enum MyEnum { ONE, TWO }\n\t  \n  public void foo(MyEnum arg);\n}\n{code}\n\nGroovyImplementation.groovy:\n\n{code}\npublic class GroovyImplementation implements JavaInterface {\n  void foo(MyEnum arg)  {} // error: unable to resolve class MyEnum\n}\n{code}\n\nWorkaround is to import JavaInterface.MyEnum or to use a fully qualified name for the parameter type. Problem isn't specific to Enums.",
        "using 'this' in field assignments > ----\n> class Bla {\n>     @Property Bla self = this\n> }\n> println new Bla()\n> ----\n> throws NPE.\n\n\nIt's probably helpful to say that it causes an NPE in the compiler:\n\nCaught: java.lang.NullPointerException\njava.lang.NullPointerException\n\tat org.codehaus.groovy.ast.ClassNode.equals(ClassNode.java:540)\n\tat org.codehaus.groovy.ast.ClassNode.equals(ClassNode.java:538)\n\tat org.codehaus.groovy.classgen.AsmClassGenerator.doConvertAndCast \n(AsmClassGenerator.java:993)\n\tat org.codehaus.groovy.classgen.AsmClassGenerator.visitCastExpression \n(AsmClassGenerator.java:1429)\n\tat org.codehaus.groovy.classgen.AsmClassGenerator.evaluateEqual \n(AsmClassGenerator.java:2812)\n\tat  \norg.codehaus.groovy.classgen.AsmClassGenerator.visitBinaryExpression \n(AsmClassGenerator.java:1055)\n\tat org.codehaus.groovy.ast.expr.BinaryExpression.visit \n(BinaryExpression.java:79)\n\tat  \norg.codehaus.groovy.classgen.AsmClassGenerator.visitAndAutoboxBoolean \n(AsmClassGenerator.java:2876)\n\tat  \norg.codehaus.groovy.classgen.AsmClassGenerator.visitExpressionStatement( \nAsmClassGenerator.java:1021)\n\tat org.codehaus.groovy.ast.stmt.ExpressionStatement.visit \n(ExpressionStatement.java:70)\n\tat org.codehaus.groovy.ast.CodeVisitorSupport.visitBlockStatement \n(CodeVisitorSupport.java:165)\n\tat  \norg.codehaus.groovy.ast.ClassCodeVisitorSupport.visitBlockStatement \n(ClassCodeVisitorSupport.java:93)\n\tat org.codehaus.groovy.classgen.AsmClassGenerator.visitBlockStatement \n(AsmClassGenerator.java:465)\n\tat org.codehaus.groovy.ast.stmt.BlockStatement.visit \n(BlockStatement.java:82)\n\n"
    ],
    [
        "GROOVY-5304",
        "GROOVY-45",
        "groovydoc output html does not specify character encoding ",
        "Referring to a class name in Groovy to another Groovy class thats not yet been turned into bytecode causes a compile error If you do uncomment the 'todo' text in groovy.gdo.Person test so that the Person is used as an expression, then do\n\nmaven clean test\n\nthe test will fail.\n\nThis is due to the Person class not being found at the time the PersonTest is being compiled.\n\nWe need to have an interim step which once we've created the AST will spot class names as variables and expand them as ClassExpressions using the AST as well as the classpath"
    ],
    [
        "GROOVY-6264",
        "GROOVY-6767",
        "static.propertyMissing with name and value doesn't called {code}\nclass Foo{} \n\nFoo.metaClass.static.propertyMissing << {name -> println \"missing static getter $name \"} \nFoo.metaClass.propertyMissing << {name,value -> println \"missing object setter $name $value\"} \nFoo.metaClass.propertyMissing << {name -> println \"missing object getter $name \"} \nFoo.metaClass.static.propertyMissing << {name,value -> println \"missing static setter $name $value\"} \n\nFoo.attr \nnew Foo().attr1 \nnew Foo().attr1 = \"bar\" \nFoo.attr = \"bar\" // exception here \n{code}\n\nAccording to http://groovy.codehaus.org/Using+methodMissing+and+propertyMissing it should.\n\nPlease note, I'm googling deeper and found only unanswered question - http://groovy.329449.n5.nabble.com/static-propertyMissing-with-name-and-value-doesn-t-work-Should-it-td5711002.html which is almost copied here, but no any workaround.",
        "Using @Override to annotate MOP methods results in error (since 2.3.0) The Groovy 2.3.0 compiler, does not like the following code, while 2.2.x was OK with it. \n\n{code}\nclass Entity {\n    @Override\n    boolean isCase(Object val) { return true   }\n\n// Error:(22, 5) Groovyc: Method 'isCase' from class 'Entity' does not override method from its superclass or interfaces but is annotated with @Override.\n\n}\n{code}\n\n\nWhile the 'isCase' is not strictly an override, using @Override annotations to check the implementation of MOP methods was a very useful safety net.\n"
    ],
    [
        "GROOVY-7141",
        "GROOVY-2483",
        "Static type checker does not recognize closure input parameter when implementing an interface with a map Consider the following Groovy class:\n\n{code}\npackage e\nimport groovy.transform.TypeChecked;\n\n@TypeChecked\nclass E {\n\t\n\tinterface MyInt {\n\t\tString doSomething(String text)\n\t}\n\t\n\tstatic void main(String[] args) {\n\t\tMyInt impl = [\n\t\t\tdoSomething: { it.toUpperCase() }\n\t\t\t] as MyInt\n\t\tprintln impl.doSomething('foo')\n\t}\n}\n{code}\n\nThe compiler complains that:\n{noformat}\nGroovy:[Static type checking] - Cannot find matching method java.lang.Object#toUpperCase(). Please check if \n the declared type is right and if the method exists.\n{noformat}\n\nHowever I think Groovy should be smart enough to recognize that {{it}} is of type {{String}} inside the closure.",
        "groovy.bat can not set system property I want to set system property from external, but groovy.bat can not set.\n\n{code:title=test.groovy}\nprintln \"Hello world\"\n{code}\n\nc:\\work\\workspace\\MockOSGi>C:\\Java\\jdk\\groovy-1.5.1\\bin\\groovy -Da=a test.groovy\n{code:none}\nerror: no argument for:D\nusage: groovy [options] [args]\noptions:\n  -D,--define <name=value>         define a system property\n  -a,--autosplit <splitPattern>    automatically split current line (defaults to\n                                   '\\s')\n  -c,--encoding <charset>          specify the encoding of the files\n  -d,--debug                       debug mode will print out full stack traces\n  -e <script>                      specify a command line script\n  -h,--help                        usage information\n  -i <extension>                   modify files in place, create backup if\n                                   extension is given (e.g. '.bak')\n  -l <port>                        listen on a port and process inbound lines\n  -n                               process files line by line\n  -p                               process files line by line and print result\n  -v,--version                     display the Groovy and JVM versions\n{code}\n\nI tried, --defineA=A or --defin A=A  or -D A=A -DA=A  but every trial failed.\n"
    ],
    [
        "GROOVY-5574",
        "GROOVY-945",
        "Log4j annotation causes class generation BUG! Running this script:\n\n{code}\nimport groovy.util.logging.Log4j\n\n@Log4j\nclass Test {\n  void doit() {\n    log.debug( 'woo' )\n  }\n  \n  static main( args ) {\n    new Test().doit()\n  }\n}\n{code}\n\nCauses:\n\n{code}\nBUG! exception in phase 'class generation' in source unit 'log4jannotation.groovy' ClassNode#getTypeClass for org.apache.log4j.Logger is called before the type class is set \n\tat org.codehaus.groovy.ast.ClassNode.getTypeClass(ClassNode.java:1327)\n\tat org.codehaus.groovy.classgen.asm.BytecodeHelper.box(BytecodeHelper.java:596)\n\tat org.codehaus.groovy.classgen.asm.OperandStack.box(OperandStack.java:205)\n\tat org.codehaus.groovy.classgen.asm.CallSiteWriter.prepareSiteAndReceiver(CallSiteWriter.java:233)\n\tat org.codehaus.groovy.classgen.asm.CallSiteWriter.prepareSiteAndReceiver(CallSiteWriter.java:221)\n\tat org.codehaus.groovy.classgen.asm.CallSiteWriter.makeCallSite(CallSiteWriter.java:270)\n\tat org.codehaus.groovy.classgen.asm.InvocationWriter.makeCall(InvocationWriter.java:229)\n\tat org.codehaus.groovy.classgen.asm.InvocationWriter.makeCall(InvocationWriter.java:76)\n\tat org.codehaus.groovy.classgen.asm.InvocationWriter.makeInvokeMethodCall(InvocationWriter.java:60)\n\tat org.codehaus.groovy.classgen.asm.InvocationWriter.writeInvokeMethod(InvocationWriter.java:334)\n\tat org.codehaus.groovy.classgen.AsmClassGenerator.visitMethodCallExpression(AsmClassGenerator.java:649)\n\tat org.codehaus.groovy.ast.expr.MethodCallExpression.visit(MethodCallExpression.java:67)\n\tat org.codehaus.groovy.classgen.asm.StatementWriter.writeExpressionStatement(StatementWriter.java:604)\n\tat org.codehaus.groovy.classgen.asm.OptimizingStatementWriter.writeExpressionStatement(OptimizingStatementWriter.java:354)\n\tat org.codehaus.groovy.classgen.AsmClassGenerator.visitExpressionStatement(AsmClassGenerator.java:510)\n\tat org.codehaus.groovy.ast.stmt.ExpressionStatement.visit(ExpressionStatement.java:40)\n\tat org.codehaus.groovy.classgen.asm.StatementWriter.writeBlockStatement(StatementWriter.java:81)\n\tat org.codehaus.groovy.classgen.asm.OptimizingStatementWriter.writeBlockStatement(OptimizingStatementWriter.java:155)\n\tat org.codehaus.groovy.classgen.AsmClassGenerator.visitBlockStatement(AsmClassGenerator.java:456)\n\tat org.codehaus.groovy.ast.stmt.BlockStatement.visit(BlockStatement.java:69)\n\tat org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClassCodeContainer(ClassCodeVisitorSupport.java:101)\n\tat org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitConstructorOrMethod(ClassCodeVisitorSupport.java:112)\n\tat org.codehaus.groovy.classgen.AsmClassGenerator.visitStdMethod(AsmClassGenerator.java:320)\n\tat org.codehaus.groovy.classgen.AsmClassGenerator.visitConstructorOrMethod(AsmClassGenerator.java:277)\n\tat org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitMethod(ClassCodeVisitorSupport.java:123)\n\tat org.codehaus.groovy.classgen.AsmClassGenerator.visitMethod(AsmClassGenerator.java:397)\n\tat org.codehaus.groovy.ast.ClassNode.visitContents(ClassNode.java:1056)\n\tat org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClass(ClassCodeVisitorSupport.java:50)\n\tat org.codehaus.groovy.classgen.AsmClassGenerator.visitClass(AsmClassGenerator.java:181)\n\tat org.codehaus.groovy.control.CompilationUnit$14.call(CompilationUnit.java:783)\n\tat org.codehaus.groovy.control.CompilationUnit.applyToPrimaryClassNodes(CompilationUnit.java:1024)\n\tat org.codehaus.groovy.control.CompilationUnit.doPhaseOperation(CompilationUnit.java:562)\n\tat org.codehaus.groovy.control.CompilationUnit.processPhaseOperations(CompilationUnit.java:540)\n\tat org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:517)\n\tat groovy.lang.GroovyClassLoader.doParseClass(GroovyClassLoader.java:283)\n\tat groovy.lang.GroovyClassLoader.parseClass(GroovyClassLoader.java:264)\n\tat groovy.lang.GroovyShell.parseClass(GroovyShell.java:613)\n\tat groovy.lang.GroovyShell.run(GroovyShell.java:480)\n\tat groovy.lang.GroovyShell.run(GroovyShell.java:163)\n\tat groovy.lang.GroovyShell$run.call(Unknown Source)\n\tat groovy.ui.Console$_runScriptImpl_closure17.doCall(Console.groovy:931)\n\tat groovy.ui.Console$_runScriptImpl_closure17.doCall(Console.groovy)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n\tat java.lang.reflect.Method.invoke(Method.java:597)\n\tat org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:90)\n\tat groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:233)\n\tat org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:272)\n\tat groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:904)\n\tat groovy.lang.Closure.call(Closure.java:410)\n\tat groovy.lang.Closure.call(Closure.java:404)\n\tat groovy.lang.Closure.run(Closure.java:488)\n\tat java.lang.Thread.run(Thread.java:680)\n{code}",
        "keep StringBuffer << closed under its type and make String << return StringBuffer to change in DefaultGroovyMethods:\n\nchange\nWriter leftShift(String self, Object value)\nto\nStringBuffer leftShift(String self, Object value)\n\nchange\nWriter leftShift(StringBuffer self, Object value)\nto\nStringBuffer leftShift(StringBuffer self, Object value)\n\n"
    ],
    [
        "GROOVY-772",
        "GROOVY-7380",
        "implicit 'it' parameter created wrongly The closures {:: y} and {y} have different semantics, but the present system treats them the same, giving both an implicit parameter list of (it = null).  A closure with an explicit empty parameter list should not get it changed to another parameter list, because the user has explicitly specified one.\n\nSuggested fix:  Move the logic to create the (it = null) list into the Antlr parser plugin, and respect the different between PARAMETERS and IMPLICIT_PARAMETERS at that transformation point.",
        "Using += on a Collection class like java.util.LinkedList now fail in 2.4 with an exception at runtime, but worked fine in 2.3 {noformat}\r\njava.lang.NoSuchMethodError: org.codehaus.groovy.runtime.DefaultGroovyMethods.plus(Ljava/util/List;Ljava/lang/Object;)Ljava/util/List;\r\n\tat se.natusoft.osgi.aps.tcpipsvc.UDPReceiver.addListener(UDPReceiver.groovy:144)\r\n\tat se.natusoft.osgi.aps.tcpipsvc.UPDConProviderTest.testSendAndReceive(UPDConProviderTest.groovy:65)\r\n{noformat}\r\n\t\r\nCode that causes this:\r\n{code}\r\n    public synchronized void addListener(UDPListener listener) {\r\n        this.listeners += listener // <-- Line 144!\r\n        if (this.listeners.size() == 1) {\r\n            connect()\r\n        }\r\n    }\r\n{code}\r\n\r\nUsing += on a java.util.List (LinkedList in this case) works fine in Groovy 2.3.6, and 2.3.11, but not in 2.4.3! The code does compile OK even with @CompileStatic and @TypeChecked, so I take this to be a bug rather than a non backwards compatible feature change.\r\n\r\nDo note that this is in a top level class, not an inner class!\r\n\r\n"
    ],
    [
        "GROOVY-6757",
        "GROOVY-7345",
        "Explicit type hints are not respected {code}\n@groovy.transform.CompileStatic\nclass Example {\n  static void main(String[] args) {\n    Collections.<String>emptyList().get(0).toUpperCase()\n  }\n}\n{code}\n\nThat fails to compile because it doesn't respect the <String> hint.",
        "DefaultGroovyMethods#asArrayType causes calls to deprecated methods Take this very simple code:\n\n{code}\n['1','2'] as Object[]\n{code}\n\nIt will eventually call DefaultGroovyMethods#asType(java.lang.String,java.lang.Class)\n\nbecause of the {{InvokerHelper}} call in asArrayType. \n\nThis should be avoided.\n"
    ],
    [
        "GROOVY-2663",
        "GROOVY-2341",
        "Groovy's annotation support doesn't deal with default values correctly Given a Java annotation like this:\n\n{code}\npublic @interface Foo {\n    String bar() default \"\";\n}\n{code}\n\nWhen used in Groovy on a method:\n\n{code}\nclass Bar {\n     @Foo\n     def myMethod() {}\n}\n{code}\n\nThe value of the \"bar\" attribute does not take into account the default value of a blank string and instead returns null when used via reflection. Hence Java code like this will throw an exception:\n\n{code}\nString foo = ann.bar().length() == 0 ? null : ann.bar();\n{code}\n\nAs the Groovy annotated method returns null. The workaround is to do this:\n\n\n{code}\nclass Bar {\n     @Foo(bar=\"\")\n     def myMethod() {}\n}\n{code}\n\nBut that is nasty",
        "groovy does not build with current radeox Hi,\n\n\nversion 1.0beta3 is the only version that can be downloaded from http://www.radeox.org but groovy fails to build with this version:\n\n    [javac] 426. ERROR in /home/twerner/debian/build-area/groovy-1.0/src/main/org/\ncodehaus/groovy/wiki/TestCaseRenderEngine.java (at line 59)\n    [javac]     public class TestCaseRenderEngine implements RenderEngine {\n    [javac]                  ^^^^^^^^^^^^^^^^^^^^\n    [javac] The type TestCaseRenderEngine must implement the inherited abstract me\nthod RenderEngine.render(Reader, RenderContext)\n    [javac] ----------\n    [javac] 427. ERROR in /home/twerner/debian/build-area/groovy-1.0/src/main/org/\ncodehaus/groovy/wiki/TestCaseR\n    [javac] enderEngine.java (at line 59)\n    [javac]     public class TestCaseRenderEngine implements RenderEngine {\n    [javac]                  ^^^^^^^^^^^^^^^^^^^^\n    [javac] The type TestCaseRenderEngine must implement the inherited abstract me\nthod RenderEngine.getInitialRenderContext()\n\nMay you fix that, please?\n\n\nCheers,\nTorsten\n"
    ],
    [
        "GROOVY-4003",
        "GROOVY-6997",
        "Grammar enhancements to preserve documentation in comments This enhancement is to cover investigating whether to use some of the groovy eclipse grammar extensions to allow groovy itself to preserve comments (javadoc) and include them in any stubs that are output.  I would have liked to spend time extracting them out from the rest of the grammar changes and finishing them off but I don't have time right now.  So this is just to get the discussion going.\n\nAs linked by Guillaume, the grammar we use now is here:\nhttp://fisheye.codehaus.org/browse/groovy/eclipse/trunk/base/org.codehaus.groovy/src/org/codehaus/groovy/internal/antlr/parser/groovy.g#r18665\n\nwhilst a diff from that to the 'normal grammar' is here:\nhttp://fisheye.codehaus.org/browse/groovy/eclipse/trunk/base/org.codehaus.groovy16/src/org/codehaus/groovy/internal/antlr/parser/groovy.g?r1=18665&r2=17587\n\nThere are numerous changes in there to improve parser recovery.  Meaning that when erroneous syntax is encountered, the parser doesn't crash out, it instead recovers as best it can and continues.  Capturing as many errors as possible in a single pass and producing 'correct as we can' output at the end of a parse is important in the IDE.  I have not run the groovy tests against this modified grammar to tell if anything in groovy is adversely affected but the changes are 99% in the error handling so hopefully they make no difference in the normal case. (although there is one place where I use 'mark()' in case I need to recover later, not sure how expensive that is)\n\nHowever, to extract just the portion relating to comments, you need to:\n- pull out the comments property plus accessor\n- pull out the startComment/endComment logic\n- pull out the changes to comment rules (single and multi line) that invoke start/end comment\n- use the ONE_NL_KEEP rule instead of the normal newline processing that discards them\n- oh and pull out the Comment type:\nhttp://fisheye.codehaus.org/browse/groovy/eclipse/trunk/base/org.codehaus.groovy16/src/org/codehaus/groovy/ast/Comment.java?r=HEAD\n(which additionally includes some task tag locator code that may or may not be wanted...)\n\nthat would give you enough to preserve comments.  At the end of the parse of a file they are available through the accessor 'getComments()', with full positional information.\n\nIn an ideal world what would happen is that the parser maintains a 'most recent comment' and on parse processing of any element that could be doc'd, the parse logic would grab that most recent comment and attach it to that element of the ast.  It would then null the most recent comment object.  This ensures all elements get the right documentation.  I didn't have the time to do that and so right now what is available at the end of processing is all the comments and by looking at positions they are associated with the right elements in the Ast (so groovy eclipse can do javadoc hovers).  I didn't make the extra changes I am describing here because I couldn't face writing the antlr and it would make the patch much more complicated as every rule that parsed something that could be documented would be changed. (And I have to maintain/apply this patch each time groovy changes!).\n",
        "old version of jline on -cp breaks shell ksc@ksc-desktop:~$ groovysh -cp jline-0.9.94.jar \n[ERROR] Terminal initialization failed; falling back to unsupported\njava.lang.IncompatibleClassChangeError: Found class jline.Terminal, but interface was expected\n\tat jline.TerminalFactory.create(TerminalFactory.java:101)\n\tat jline.TerminalFactory$create.call(Unknown Source)\n\tat org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:45)\n\tat org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:108)\n\tat org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:112)\n\tat org.codehaus.groovy.tools.shell.Groovysh.run(Groovysh.groovy:516)\n\tat org.codehaus.groovy.tools.shell.Groovysh$run$0.callCurrent(Unknown Source)\n\tat org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCallCurrent(CallSiteArray.java:49)\n\tat org.codehaus.groovy.runtime.callsite.AbstractCallSite.callCurrent(AbstractCallSite.java:133)\n\tat org.codehaus.groovy.runtime.callsite.AbstractCallSite.callCurrent(AbstractCallSite.java:141)\n\tat org.codehaus.groovy.tools.shell.Groovysh.run(Groovysh.groovy:512)\n\tat org.codehaus.groovy.tools.shell.Groovysh$run.call(Unknown Source)\n\tat org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:45)\n\tat org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:108)\n\tat org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:120)\n\tat org.codehaus.groovy.tools.shell.Main.startGroovysh(Main.groovy:180)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:606)\n\tat org.codehaus.groovy.runtime.callsite.PogoMetaMethodSite$PogoCachedMethodSiteNoUnwrapNoCoerce.invoke(PogoMetaMethodSite.java:207)\n\tat org.codehaus.groovy.runtime.callsite.PogoMetaMethodSite.call(PogoMetaMethodSite.java:68)\n\tat org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:45)\n\tat org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:108)\n\tat org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:120)\n\tat org.codehaus.groovy.tools.shell.Main.main(Main.groovy:146)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:606)\n\tat org.codehaus.groovy.tools.GroovyStarter.rootLoader(GroovyStarter.java:106)\n\tat org.codehaus.groovy.tools.GroovyStarter.main(GroovyStarter.java:128)\n\n[ERROR] Terminal initialization failed; falling back to unsupported\njava.lang.IncompatibleClassChangeError: Found class jline.Terminal, but interface was expected\n\tat jline.TerminalFactory.create(TerminalFactory.java:101)\n\tat jline.TerminalFactory.get(TerminalFactory.java:158)\n\tat jline.console.ConsoleReader.<init>(ConsoleReader.java:229)\n\tat jline.console.ConsoleReader.<init>(ConsoleReader.java:221)\n\tat jline.console.ConsoleReader.<init>(ConsoleReader.java:213)\n\tat org.codehaus.groovy.tools.shell.PatchedConsoleReader.<init>(PatchedConsoleReader.groovy:30)\n\tat sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)\n\tat sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:57)\n\tat sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)\n\tat java.lang.reflect.Constructor.newInstance(Constructor.java:526)\n\tat org.codehaus.groovy.reflection.CachedConstructor.invoke(CachedConstructor.java:77)\n\tat org.codehaus.groovy.runtime.callsite.ConstructorSite$ConstructorSiteNoUnwrapNoCoerce.callConstructor(ConstructorSite.java:102)\n\tat org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCallConstructor(CallSiteArray.java:57)\n\tat org.codehaus.groovy.runtime.callsite.AbstractCallSite.callConstructor(AbstractCallSite.java:182)\n\tat org.codehaus.groovy.runtime.callsite.AbstractCallSite.callConstructor(AbstractCallSite.java:194)\n\tat org.codehaus.groovy.tools.shell.InteractiveShellRunner.<init>(InteractiveShellRunner.groovy:49)\n\tat sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)\n\tat sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:57)\n\tat sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)\n\tat java.lang.reflect.Constructor.newInstance(Constructor.java:526)\n\tat org.codehaus.groovy.reflection.CachedConstructor.invoke(CachedConstructor.java:77)\n\tat org.codehaus.groovy.reflection.CachedConstructor.doConstructorInvoke(CachedConstructor.java:71)\n\tat org.codehaus.groovy.runtime.callsite.ConstructorSite.callConstructor(ConstructorSite.java:42)\n\tat org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCallConstructor(CallSiteArray.java:57)\n\tat org.codehaus.groovy.runtime.callsite.AbstractCallSite.callConstructor(AbstractCallSite.java:182)\n\tat org.codehaus.groovy.runtime.callsite.AbstractCallSite.callConstructor(AbstractCallSite.java:194)\n\tat org.codehaus.groovy.tools.shell.Groovysh.run(Groovysh.groovy:538)\n\tat org.codehaus.groovy.tools.shell.Groovysh$run$0.callCurrent(Unknown Source)\n\tat org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCallCurrent(CallSiteArray.java:49)\n\tat org.codehaus.groovy.runtime.callsite.AbstractCallSite.callCurrent(AbstractCallSite.java:133)\n\tat org.codehaus.groovy.runtime.callsite.AbstractCallSite.callCurrent(AbstractCallSite.java:141)\n\tat org.codehaus.groovy.tools.shell.Groovysh.run(Groovysh.groovy:512)\n\tat org.codehaus.groovy.tools.shell.Groovysh$run.call(Unknown Source)\n\tat org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:45)\n\tat org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:108)\n\tat org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:120)\n\tat org.codehaus.groovy.tools.shell.Main.startGroovysh(Main.groovy:180)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:606)\n\tat org.codehaus.groovy.runtime.callsite.PogoMetaMethodSite$PogoCachedMethodSiteNoUnwrapNoCoerce.invoke(PogoMetaMethodSite.java:207)\n\tat org.codehaus.groovy.runtime.callsite.PogoMetaMethodSite.call(PogoMetaMethodSite.java:68)\n\tat org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:45)\n\tat org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:108)\n\tat org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:120)\n\tat org.codehaus.groovy.tools.shell.Main.main(Main.groovy:146)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:606)\n\tat org.codehaus.groovy.tools.GroovyStarter.rootLoader(GroovyStarter.java:106)\n\tat org.codehaus.groovy.tools.GroovyStarter.main(GroovyStarter.java:128)\n\nFATAL: java.lang.IncompatibleClassChangeError: Found class jline.Terminal, but interface was expected\njava.lang.IncompatibleClassChangeError: Found class jline.Terminal, but interface was expected\n\tat jline.console.ConsoleReader.<init>(ConsoleReader.java:230)\n\tat jline.console.ConsoleReader.<init>(ConsoleReader.java:221)\n\tat jline.console.ConsoleReader.<init>(ConsoleReader.java:213)\n\tat org.codehaus.groovy.tools.shell.PatchedConsoleReader.<init>(PatchedConsoleReader.groovy:30)\n\tat sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)\n\tat sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:57)\n\tat sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)\n\tat java.lang.reflect.Constructor.newInstance(Constructor.java:526)\n\tat org.codehaus.groovy.reflection.CachedConstructor.invoke(CachedConstructor.java:77)\n\tat org.codehaus.groovy.runtime.callsite.ConstructorSite$ConstructorSiteNoUnwrapNoCoerce.callConstructor(ConstructorSite.java:102)\n\tat org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCallConstructor(CallSiteArray.java:57)\n\tat org.codehaus.groovy.runtime.callsite.AbstractCallSite.callConstructor(AbstractCallSite.java:182)\n\tat org.codehaus.groovy.runtime.callsite.AbstractCallSite.callConstructor(AbstractCallSite.java:194)\n\tat org.codehaus.groovy.tools.shell.InteractiveShellRunner.<init>(InteractiveShellRunner.groovy:49)\n\tat sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)\n\tat sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:57)\n\tat sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)\n\tat java.lang.reflect.Constructor.newInstance(Constructor.java:526)\n\tat org.codehaus.groovy.reflection.CachedConstructor.invoke(CachedConstructor.java:77)\n\tat org.codehaus.groovy.reflection.CachedConstructor.doConstructorInvoke(CachedConstructor.java:71)\n\tat org.codehaus.groovy.runtime.callsite.ConstructorSite.callConstructor(ConstructorSite.java:42)\n\tat org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCallConstructor(CallSiteArray.java:57)\n\tat org.codehaus.groovy.runtime.callsite.AbstractCallSite.callConstructor(AbstractCallSite.java:182)\n\tat org.codehaus.groovy.runtime.callsite.AbstractCallSite.callConstructor(AbstractCallSite.java:194)\n\tat org.codehaus.groovy.tools.shell.Groovysh.run(Groovysh.groovy:538)\n\tat org.codehaus.groovy.tools.shell.Groovysh$run$0.callCurrent(Unknown Source)\n\tat org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCallCurrent(CallSiteArray.java:49)\n\tat org.codehaus.groovy.runtime.callsite.AbstractCallSite.callCurrent(AbstractCallSite.java:133)\n\tat org.codehaus.groovy.runtime.callsite.AbstractCallSite.callCurrent(AbstractCallSite.java:141)\n\tat org.codehaus.groovy.tools.shell.Groovysh.run(Groovysh.groovy:512)\n\tat org.codehaus.groovy.tools.shell.Groovysh$run.call(Unknown Source)\n\tat org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:45)\n\tat org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:108)\n\tat org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:120)\n\tat org.codehaus.groovy.tools.shell.Main.startGroovysh(Main.groovy:180)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:606)\n\tat org.codehaus.groovy.runtime.callsite.PogoMetaMethodSite$PogoCachedMethodSiteNoUnwrapNoCoerce.invoke(PogoMetaMethodSite.java:207)\n\tat org.codehaus.groovy.runtime.callsite.PogoMetaMethodSite.call(PogoMetaMethodSite.java:68)\n\tat org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:45)\n\tat org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:108)\n\tat org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:120)\n\tat org.codehaus.groovy.tools.shell.Main.main(Main.groovy:146)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:606)\n\tat org.codehaus.groovy.tools.GroovyStarter.rootLoader(GroovyStarter.java:106)\n\tat org.codehaus.groovy.tools.GroovyStarter.main(GroovyStarter.java:128)\n"
    ],
    [
        "GROOVY-1423",
        "GROOVY-7328",
        "Auto close bracket/parenthesis in Groovy editor. When typing a ( or [ a matching ) or ] should be automatically generated. This is a minor feature, however it would make the editing experience when switching between the Java and Groovy consistent.",
        "Base class setter chosen over private variable On Android, the following code crashes with exception:\n\nCaused by: org.codehaus.groovy.runtime.typehandling.GroovyCastException: Cannot cast object 'boom!' with class 'java.lang.String' to class 'int'\n\n{code}\n@CompileStatic\npublic final class HomeActivity extends ActionBarActivity {\n\n  private String result\n\n  @Override\n  protected void onCreate(Bundle savedInstanceState) {\n\n    super.onCreate(savedInstanceState)\n\n    this.result = \"boom!\"\n\n  }\n\n}\n{code}\n\nThe reason is a base class declares `setResult` method: http://developer.android.com/reference/android/app/Activity.html#setResult%28int%29\n\nCrash only happens when using\n{{this.result = \"boom!\"}}\nand not when\n{{result = \"boom!\"}}"
    ],
    [
        "GROOVY-6558",
        "GROOVY-1271",
        "incrementing a Static Compiled Map with default Integer value won't compile The following code:\n\n{code}\nimport groovy.transform.CompileStatic\n\n@CompileStatic\ndef test() {\n    Map<String,Integer> frequencies = [:].withDefault { 0 }\n    frequencies[ 'a' ]++\n    frequencies\n}\n\ntest()\n{code}\n\nCauses a BUG exception:\n\n{code}\nBUG! exception in phase 'class generation' in source unit 'ConsoleScript75' Error while popping argument from operand stack tracker in class ConsoleScript75 method java.lang.Object test().\n\tat org.codehaus.groovy.classgen.asm.OperandStack.popWithMessage(OperandStack.java:74)\n\tat org.codehaus.groovy.classgen.asm.OperandStack.remove(OperandStack.java:215)\n\tat org.codehaus.groovy.classgen.asm.sc.StaticInvocationWriter.writeDirectMethodCall(StaticInvocationWriter.java:187)\n\tat org.codehaus.groovy.classgen.asm.InvocationWriter.makeDirectCall(InvocationWriter.java:243)\n\tat org.codehaus.groovy.classgen.asm.InvocationWriter.makeCall(InvocationWriter.java:342)\n\tat org.codehaus.groovy.classgen.asm.InvocationWriter.makeCall(InvocationWriter.java:89)\n\tat org.codehaus.groovy.classgen.asm.sc.StaticInvocationWriter.makeCall(StaticInvocationWriter.java:498)\n\tat org.codehaus.groovy.classgen.asm.InvocationWriter.makeInvokeMethodCall(InvocationWriter.java:73)\n\tat org.codehaus.groovy.classgen.asm.InvocationWriter.writeInvokeMethod(InvocationWriter.java:412)\n\tat org.codehaus.groovy.classgen.asm.sc.StaticInvocationWriter.writeInvokeMethod(StaticInvocationWriter.java:87)\n\tat org.codehaus.groovy.classgen.AsmClassGenerator.visitMethodCallExpression(AsmClassGenerator.java:686)\n\tat org.codehaus.groovy.ast.expr.MethodCallExpression.visit(MethodCallExpression.java:64)\n\tat org.codehaus.groovy.classgen.asm.BinaryExpressionHelper.loadWithSubscript(BinaryExpressionHelper.java:680)\n\tat org.codehaus.groovy.classgen.asm.BinaryExpressionHelper.evaluatePostfixMethod(BinaryExpressionHelper.java:602)\n\tat org.codehaus.groovy.classgen.asm.BinaryExpressionHelper.evaluatePostfixMethod(BinaryExpressionHelper.java:625)\n\tat org.codehaus.groovy.classgen.AsmClassGenerator.visitPostfixExpression(AsmClassGenerator.java:570)\n\tat org.codehaus.groovy.ast.expr.PostfixExpression.visit(PostfixExpression.java:43)\n\tat org.codehaus.groovy.classgen.asm.StatementWriter.writeExpressionStatement(StatementWriter.java:604)\n\tat org.codehaus.groovy.classgen.AsmClassGenerator.visitExpressionStatement(AsmClassGenerator.java:547)\n\tat org.codehaus.groovy.ast.stmt.ExpressionStatement.visit(ExpressionStatement.java:40)\n\tat org.codehaus.groovy.classgen.asm.StatementWriter.writeBlockStatement(StatementWriter.java:81)\n\tat org.codehaus.groovy.classgen.asm.sc.StaticTypesStatementWriter.writeBlockStatement(StaticTypesStatementWriter.java:49)\n\tat org.codehaus.groovy.classgen.AsmClassGenerator.visitBlockStatement(AsmClassGenerator.java:493)\n\tat org.codehaus.groovy.ast.stmt.BlockStatement.visit(BlockStatement.java:69)\n\tat org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClassCodeContainer(ClassCodeVisitorSupport.java:101)\n\tat org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitConstructorOrMethod(ClassCodeVisitorSupport.java:112)\n\tat org.codehaus.groovy.classgen.AsmClassGenerator.visitStdMethod(AsmClassGenerator.java:357)\n\tat org.codehaus.groovy.classgen.AsmClassGenerator.visitConstructorOrMethod(AsmClassGenerator.java:314)\n\tat org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitMethod(ClassCodeVisitorSupport.java:123)\n\tat org.codehaus.groovy.classgen.AsmClassGenerator.visitMethod(AsmClassGenerator.java:434)\n\tat org.codehaus.groovy.ast.ClassNode.visitContents(ClassNode.java:1055)\n\tat org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClass(ClassCodeVisitorSupport.java:50)\n\tat org.codehaus.groovy.classgen.AsmClassGenerator.visitClass(AsmClassGenerator.java:177)\n\tat org.codehaus.groovy.control.CompilationUnit$15.call(CompilationUnit.java:794)\n\tat org.codehaus.groovy.control.CompilationUnit.applyToPrimaryClassNodes(CompilationUnit.java:1036)\n\tat org.codehaus.groovy.control.CompilationUnit.doPhaseOperation(CompilationUnit.java:572)\n\tat org.codehaus.groovy.control.CompilationUnit.processPhaseOperations(CompilationUnit.java:550)\n\tat org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:527)\n\tat groovy.lang.GroovyClassLoader.doParseClass(GroovyClassLoader.java:279)\n\tat groovy.lang.GroovyClassLoader.parseClass(GroovyClassLoader.java:258)\n\tat groovy.lang.GroovyShell.parseClass(GroovyShell.java:613)\n\tat groovy.lang.GroovyShell.run(GroovyShell.java:480)\n\tat groovy.lang.GroovyShell.run(GroovyShell.java:163)\n\tat groovy.lang.GroovyShell$run$1.call(Unknown Source)\n\tat groovy.ui.Console$_runScriptImpl_closure17.doCall(Console.groovy:977)\n\tat groovy.ui.Console$_runScriptImpl_closure17.doCall(Console.groovy)\n\tat sun.reflect.GeneratedMethodAccessor307.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:606)\n\tat org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:90)\n\tat groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:233)\n\tat org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:272)\n\tat groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:909)\n\tat groovy.lang.Closure.call(Closure.java:423)\n\tat groovy.lang.Closure.call(Closure.java:417)\n\tat groovy.lang.Closure.run(Closure.java:504)\n\tat java.lang.Thread.run(Thread.java:744)\n{code}\n\n(stacktrace from Groovy 2.2.1, but also fails similarly with todays 2.3.0 from the master branch)\n\n{code}\n    frequencies[ 'a' ] += 1\n{code}\n\nAlso fails in a similar fashion\n\nHowever,\n\n{code}\n    frequencies[ 'a' ]  = frequencies[ 'a' ] + 1\n{code}\n\nworks fine",
        "Function names are not properly resoved in Scripts when trying to create a function pointer def f() {1}\nx = f\n\nThrows\n\nCaught: groovy.lang.MissingPropertyException: No such property: f for class: test\ngroovy.lang.MissingPropertyException: No such property: f for class: test\n"
    ],
    [
        "GROOVY-3033",
        "GROOVY-7138",
        "/= assignment operator breaks type system while this works:\ngroovy> long d = 100L\ngroovy> d =  d / 33L\ngroovy> d.class\n\nResult: class java.lang.Long\n\nthe following breaks the type system and produces a Long that is a BigDecimal!\n\ngroovy> long d = 100L\ngroovy> d /= 33L\ngroovy> d.class\n\nResult: class java.math.BigDecimal\n\n",
        "Calling super.foo() from a closure fails if code is statically compiled The following code will fail at runtime with a VerifyError:\n\n{code}\nclass Top {\n   int x() { 1 }\n}\n\n@groovy.transform.CompileStatic\nclass Bottom extends Top {\n   int x() {\n      Thread.start { println(super.x()) }\n      2\n   }\n}\n\nnew Bottom().x()\n{code}\n\nRemoving @CompileStatic fixes the issue. The problem is very likely that the static compiler interprets \"super\" as the super from the closure instead of the super from the owner. Which also means a bridge method might be needed."
    ],
    [
        "GROOVY-5223",
        "GROOVY-7549",
        "Bytecode optimizations: make use of LDC for class literals Class literals are currently loaded using generated {{$get$class$}} methods which increase bytecode size and may prevent some optimizations. In most situations though, we may use the {{LCD}} bytecode instruction to load the class literal.\n",
        "java.lang.IllegalAccessError occurs when attempting to run code built with CompileStatic Given a small code setup such as the following, where there exists a\r\n# A publicly declared interface\r\n# A package private implementation of the interface\r\n# A static factory class that returns an instance of the implementation *as the implementation class*\r\n\r\n{code:title=packa.TheInterface.groovy|borderStyle=solid}\r\npackage packa\r\npublic interface TheInterface {\r\n    public void doStuff()\r\n}\r\n{code}\r\n{code:title=packb.TheImplementation.groovy|borderStyle=solid}\r\npackage packb\r\nimport packa.TheInterface\r\n@groovy.transform.CompileStatic\r\n@groovy.transform.PackageScope\r\nclass TheImplementation implements TheInterface {\r\n    public void doStuff() {\r\n        System.out.println(\"Do some stuff\")\r\n    }\r\n}\r\n{code}\r\n{code:title=packb.TheFactory.groovy|borderStyle=solid}\r\npackage packb\r\npublic class TheFactory {\r\n    static TheImplementation getAnInstance() {\r\n        return new TheImplementation()\r\n    }\r\n}\r\n{code}\r\n\r\nWith CompileStatic, calling the factory method successfully works, but calling any method on the returned object fails with {{java.lang.IllegalAccessError}}.\r\nWhen CompileStatic is removed, the code runs without issue.\r\nSuch as the following.\r\n{code:title=packa.TheMain.groovy|borderStyle=solid}\r\npackage packa\r\nimport packb.TheFactory\r\n@groovy.transform.CompileStatic\r\npublic class TheMain {\r\n    public static void main(String[] args) {\r\n        TheInterface if1 = TheFactory.anInstance\r\n        /* the following only fails when CompileStatic is enabled with the following error:\r\n         * Exception in thread \"main\" java.lang.IllegalAccessError: tried to access class packb.TheImplementation from class packa.TheMain */\r\n        if1.doStuff()\r\n    }\r\n}\r\n{code}\r\n\r\nThere seem to be some interesting factors here, as changing the {{TheFactory}} to return {{TheInterface}} instead of {{TheImplemenation}} also seems to resolve the issue.\r\n\r\nHowever, changing the return of the {{TheFactory}} is not desirable, as in the actual production the above sample was formulated from, there are other classes in the {{packb}} package that utilize {{TheFactory}} and should not require class casts from {{TheInterface}} to {{TheImplementation}}"
    ],
    [
        "GROOVY-659",
        "GROOVY-6212",
        "[PATCH] Fix behavior of scripts when invoked via symlink This patch to the unix shell scripts accomplishes two things:\n\n(1) Fixes their behavior when invoked via a symlink. For instance, if /opt/local/bin/groovy is a symlink to the script in the actual install location, invoking /opt/local/bin/grooy will fail because groovy doesn't properly calculate groovy home in the presense of the symlink.\n\n(2) Improves behavior under Mac OS X. If JAVA_HOME isn't set, the scripts detect this automatically and calculate a reasonable value.\n\n\nThis patch is an update to one submitted as part of an earlier bug (http://jira.codehaus.org/browse/GROOVY-490), which has been ignored for months. This patch supercedes that one.\n\nThis patch is against cvs HEAD.",
        "SpreadExpression BUG! when slicing a List Evaluating\n{code}\n(1..3)[*0..2]\n{code}\nthrows: {{BUG! exception in phase 'class generation' in source unit 'ConsoleScript42' SpreadExpression should not be visited here}}\nIt works fine if I manually call {{getAt}}:\n{code}\n(1..3).getAt([*0..2]) // [1, 2, 3]\n{code}\nIt also works if I add something besides the spread:\n{code}\n(1..3)[*0..2, 2] // [1, 2, 3, 3]\n{code}\nas shown in the Ranges and List-Slicing section of [Getting Started Guide > Collections|http://groovy.codehaus.org/JN1015-Collections].\n\nThere are other SpreadExpression BUG!s, but I'm not sure if this bug is the same:\nhttp://jira.codehaus.org/issues/?jql=text%20%7E%20%22SpreadExpression%22"
    ],
    [
        "GROOVY-2258",
        "GROOVY-7680",
        "AntBuilder broken by a RC-1 -> RC-2 change: Can't find compiler After a clean compile and install of Groovy and a clean compile and install of Gant then when Gant tries to process a javac Ant task, the following output is generated:\n\n|> gant test\n  [groovyc] No sources to compile\n    [mkdir] Created dir: /home/Checkouts/Subversion/Gant/gant/trunk/target/test-classes\n    [javac] Compiling 1 source file to /home/Checkouts/Subversion/Gant/gant/trunk/target/classes\nUnable to find a javac compiler;\ncom.sun.tools.javac.Main is not on the classpath.\nPerhaps JAVA_HOME does not point to the JDK.\nIt is currently set to \"/usr/lib/jvm/java-6-sun-1.6.0.03/jre\"\n|> echo $JAVA_HOME\n/usr/lib/jvm/java-6-sun-1.6.0.03\n|> \n",
        "Bump gradle to version 2.9 "
    ],
    [
        "GROOVY-6729",
        "GROOVY-980",
        "FirstParam.FirstGenericType don't works whe the method returns generic type Following code fails. The method which using FirstParam.FirstGeneics and returns generic type (where List<T>), it have no effect for closure parameter inference. FirstParam.ToString also didn't works.\n\n fails:\n{code}\n    // NG. FirstParams.FirstGenericType looks don't works.\n    static <T> List<T> callee01(List<T>self, @ClosureParams(FirstParam.FirstGenericType) Closure c) {\n        self.each {\n            c.call(it)\n        }\n        return self\n    }\n    // NG\n    @TypeChecked\n    void caller01() {\n        callee01([\"a\",\"b\",\"c\"]) { a ->\n            println(a.toUpperCase()) // [Static type checking] - Cannot find matching method java.lang.Object#toUpperCase(). Please check if the declared type is right and if the method exists.\n        }\n    }\n{code}\n\nif the return type is void, it works.\n{code}\n    // OK\n    static <T> void callee02(List<T>self, @ClosureParams(FirstParam.FirstGenericType) Closure c) {\n        self.each {\n            c.call(it)\n        }\n    }\n    @TypeChecked\n    void caller02() {\n        callee02([\"a\",\"b\",\"c\"]) { a ->\n            println(a.toUpperCase())\n        }\n    }\n    \n{code}\n\nand if the return type is monomorphic type, its also ok(following case, it's String)\n\n{code}\n    static <T> String callee03(List<T>self, @ClosureParams(FirstParam.FirstGenericType) Closure c) {\n        self.each {\n            c.call(it)\n        }\n        return \"foo\"\n    }\n\n    @TypeChecked\n    void caller03() {\n        callee03([\"a\",\"b\",\"c\"]) { a ->\n            println(a.toUpperCase())\n        }\n    }\n{code}\n",
        "SimpleTemplateEngine fails when enclose expression dosn't immediately evaluate to a String     void todo_testWithMarkupBuilder(){\n    def text = '''<%\n        builder = new groovy.xml.MarkupBuilder(out)\n        [1,2,3].each{ count ->\n            out.print(1)\n        }\n    %>'''\n    assertEquals('111', simpleCall(text))\n    }\n\nproduces\n\n<getAt>[1, 2, 3]</getAt>11111\n\nwhile everything was fine in Groovy classic.\n\nI will commit more tests in groovy.text.SimpleTemplateEngineText.groovy"
    ],
    [
        "GROOVY-2669",
        "GROOVY-1597",
        "GString equals and compareTo implementation is inconsistent GString.equals can only be true if the value is also a GString.  GString.compareTo can return zero for any value if it's toString() is compareTo zero of the GString's toString().\n\nThat is inconsistent with j.l.String and also the general requirement that if compareTo is implemented then it must return zero iff equals is true.  This is especially true give that GString is trying to behave stringishly and therefore must follow j.l.String in this regard.\n\nA bit of reference:\n\n[http://java.sun.com/j2se/1.4.2/docs/api/java/lang/String.html#compareTo(java.lang.String)]\n\nbq. The result is zero if the strings are equal; compareTo returns 0 exactly when the equals(Object) method would return true.\n",
        "Error message when trying to execute a directory should be improved When trying to execute a directory, e.g.\ngroovy c:\\temp\n\nthe error message is not very clear:\n\norg.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed, c:\\temp: c:\\temp (Access is denied)\n\n1 error\n\nWhat it actually should say is:\n\nc:\\temp is a directory and can not be executed\n\nNote that if the patch attached to GROOVY-1596 is not applied, the above results in NPE.\n\n\n"
    ],
    [
        "GROOVY-290",
        "GROOVY-2353",
        "Get rid of GROOVY_HOME Hi,\nAs far as I understand Groovy currently requires that the GROOVY Enviromentvariable is set. It would be nice to get rid of this requirement. At least on Windows and Unix it's possible for a script to figure out it's location. From the scripts location the value for GROOVY_HOME  could be derived. The Apache ant project does it this way. \n\nSupporting the GROOVY_HOME enviroment variable would be still a good fall back. \n\n\n\nRegards,\nMarkus",
        "DGMContentAssistProcessor proposals are duplicated in CodeCompletionProcessor (Property Completer) The DGM completer proposes the Default Groovy Methods, but this same set is proposed by the Property Completer.  The Property Completer seems to provide all possible \".\" completions for objects, so DGMs are included as well.  I suggest we remove DGM Completer so there are not duplicate proposals in the proposal list and so we save the processing time.  Note: the DGM processor was already failing to load due to a defect introduced as part of GROOVY-2033.  "
    ],
    [
        "GROOVY-7109",
        "GROOVY-6673",
        "Severe Memory Leak Happens when Script Executes      Recently I found my website creates so many classes in permGen. In dump file I can see so many strange classes such as java_util_List$size, java_util_List$subList.\n\n     I don't know what are these classes, so I just call them \"method classes\". The serious thing is that, each \"method class\" has many \"anonymous classes\", such as java_util_List$size$0, java_util_List$size$1, java_util_List$size$2 ... There are over 1,000 java_util_List$size, and over 60,000 class totally in permGen.\n\n     Then I test the groovy script engine and find that when script is excuting, these strange method is created.\n     Here is my test code.\n\n{code:title=TodoJava.java|borderStyle=solid}\n        ScriptEngineManager m = new ScriptEngineManager();\n        ScriptEngine engine = m.getEngineByName(\"groovy\");\n        CompiledScript script = ((Compilable) engine).compile(new FileReader( \"test-script.groovy\" ));\n{code}\n     The test-script.groovy file:\n{code:title=test-script.groovy|borderStyle=solid}\nimport cn.ming.youxi.TestClazz\n\nRandom random = new Random();\nfor (i in 1 .. 10) {\n    random.nextInt(i);\n}\nTestClazz testClazz = clazz;\nList list = Arrays.asList(\n        testClazz.att,\n        testClazz.att,\n        testClazz.att,\n        testClazz.att,\n        testClazz.att,\n        testClazz.att\n);\n\nreturn list.get(2);\n{code}\n     TestClazz is a simple class with an Integer attribute. When I call this method, the \"method classes\" is created.\n{code:title=TodoJava.java|borderStyle=solid}\n        public void run(CompiledScript script) {\n            TestClazz testClazz = new TestClazz(new Random().nextInt());\n            Map<String, Object> params = new HashMap<String, Object>();\n            params.put(\"clazz\", testClazz);\n            Bindings bindings = engine.createBindings();\n            bindings.putAll(params);\n            try {\n                System.out.println(script.eval(bindings));\n            } catch (ScriptException e) {\n                e.printStackTrace();\n            }\n        }\n{code}\n\n      But there is only one java_util_List$get and java_util_Random$nextInt no matter how many times I call it. Then I try to execute the script in muti-thread. Here's the code:\n{code:title=TodoJava.java|borderStyle=solid}\n    static class MyThread extends Thread {\n        ScriptEngine engine;\n        CompiledScript script;\n        public MyThread(ScriptEngine engine, CompiledScript script) {\n            this.engine = engine;\n            this.script = script;\n        }\n\n        public void run() {\n            TestClazz testClazz = new TestClazz(new Random().nextInt());\n            Map<String, Object> params = new HashMap<String, Object>();\n            params.put(\"clazz\", testClazz);\n            Bindings bindings = engine.createBindings();\n            bindings.putAll(params);\n            try {\n                System.out.println(script.eval(bindings));\n            } catch (ScriptException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n{code}\n\n     And I make 10 thread every 50 ms.\n{code:title=TodoJava.java|borderStyle=solid}\n    public static void main(String[] args) throws Exception {\n        ScriptEngineManager m = new ScriptEngineManager();\n        ScriptEngine engine = m.getEngineByName(\"groovy\");\n        CompiledScript script = ((Compilable) engine).compile(new FileReader( \"test-script.groovy\" ));\n\n        InputStreamReader is_reader = new InputStreamReader(System.in);\n        String str = new BufferedReader(is_reader).readLine();\n\n        while (true) {\n            for (int i = 0; i < 10; ++i) {\n                MyThread myThread = new MyThread(engine, script);\n                myThread.start();\n            }\n            Thread.sleep(50);\n        }\n    }\n\n{code}\n\n     After a while, I see 90 java_util_List$iterator and 140 java_util_Random$nextInt in dump file! There are also 4  java_util_List$get but they are java_util_List$get$89 to java_util_List$get$92. I guess the rest are collected somehow. Although the \"method classes\" won't increase anymore, but those java_util_List$iterator and java_util_Random$nextInt will never be collected!\n\n     I guess the number of those \"method classes\" is related to the number and frequency of threads excuting the groovy script. Then I try to use groovy class loader to compile a class to excute. I write a TestGroovy.groovy:\n{code:title=TestGroovy.groovy|borderStyle=solid}\nimport cn.ming.youxi.Parent\nimport cn.ming.youxi.TestClazz\n\nclass TestGroovy implements Parent {\n    @Override\n    void run() {\n        Random random = new Random();\n        List list = Arrays.asList(\n\n                random.nextInt(),\n                random.nextInt(),\n                random.nextInt(),\n                random.nextInt(),\n        )\n        list.get(2);\n        println(random.nextInt());\n    }\n}\n\n{code}\n\n     And the code to compile and call it:\n{code:title=TodoJava.java|borderStyle=solid}\n    public static void main(String[] args) throws Exception {\n        GroovyClassLoader loader = new GroovyClassLoader();\n        Class clazz = loader.parseClass(new File(\"TestGroovy.groovy\"));\n        Parent parent = (Parent) clazz.newInstance();\n\n        InputStreamReader is_reader = new InputStreamReader(System.in);\n        String str = new BufferedReader(is_reader).readLine();\n\n        while (true){\n            for (int i = 0; i<10; ++i) {\n                MyGroovyClassThread myGroovyClassThread = new MyGroovyClassThread(parent);\n                myGroovyClassThread.run();\n            }\n            Thread.sleep(50);\n        }\n\n    }\n\n    static class MyGroovyClassThread extends Thread {\n        Parent parent;\n        boolean interupt = false;\n        public MyGroovyClassThread(Parent parent) {\n            this.parent = parent;\n        }\n        public MyGroovyClassThread(Parent parent, boolean interupt) {\n            this.parent = parent;\n            this.interupt = interupt;\n        }\n\n        public void run() {\n            parent.run();\n        }\n    }\n{code}\n     There are java_util_Random$nextInt and java_util_List$get all the same. However the number of each \"method class\" is only one.\n\n     I think this is a critical bug in groovy, cause in fact I didn't compile the code many times but the script still creates large number of \"method classes\". If I use groovy script in my server, in order to prevent my website oom, I have to adjust the size of  permgen!\n\n     Here is my all java test code:\n{code:title=TodoJava.java|borderStyle=solid}\npackage cn.ming.youxi;\n\nimport groovy.lang.GroovyClassLoader;\nimport groovy.lang.Script;\n\nimport javax.script.*;\nimport java.io.*;\nimport java.net.URISyntaxException;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Random;\n\npublic class TodoJava {\n\n    public static void main2(String[] args) throws ScriptException, IOException, InterruptedException {\n        ScriptEngineManager m = new ScriptEngineManager();\n        ScriptEngine engine = m.getEngineByName(\"groovy\");\n        CompiledScript script = ((Compilable) engine).compile(new FileReader(\"/Users/liming_liu/Documents/workspace/groovy-demo/test-script.groovy\"));\n\n        InputStreamReader is_reader = new InputStreamReader(System.in);\n        String str = new BufferedReader(is_reader).readLine();\n\n        while (true) {\n            for (int i = 0; i < 10; ++i) {\n                MyThread myThread = new MyThread(engine, script);\n                myThread.start();\n            }\n            Thread.sleep(50);\n        }\n    }\n\n    static class MyThread extends Thread {\n        ScriptEngine engine;\n        CompiledScript script;\n        public MyThread(ScriptEngine engine, CompiledScript script) {\n            this.engine = engine;\n            this.script = script;\n        }\n\n        public void run() {\n            TestClazz testClazz = new TestClazz(new Random().nextInt());\n            Map<String, Object> params = new HashMap<String, Object>();\n            params.put(\"clazz\", testClazz);\n            Bindings bindings = engine.createBindings();\n            bindings.putAll(params);\n            try {\n                System.out.println(script.eval(bindings));\n            } catch (ScriptException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    public static void main1(String[] args) throws ScriptException, IOException, IllegalAccessException, InstantiationException, InterruptedException {\n        GroovyClassLoader loader = new GroovyClassLoader();\n        Class clazz = loader.parseClass(new File(\"/Users/liming_liu/Documents/workspace/groovy-demo/test-script.groovy\"));\n        Random random = new Random();\n        Script groovyClass = (Script) clazz.newInstance();\n\n        InputStreamReader is_reader = new InputStreamReader(System.in);\n        String str = new BufferedReader(is_reader).readLine();\n\n        while (true) {\n            for (int i = 0; i < 10; ++i) {\n                MyScriptClassThread myThread = new MyScriptClassThread(groovyClass);\n                myThread.start();\n            }\n            Thread.sleep(50);\n        }\n    }\n\n    static class MyScriptClassThread extends Thread {\n        Script groovyClass;\n        boolean interupt = false;\n        public MyScriptClassThread(Script groovyClass) {\n            this.groovyClass = groovyClass;\n        }\n        public MyScriptClassThread(Script groovyClass, boolean interupt) {\n            this.groovyClass = groovyClass;\n            this.interupt = interupt;\n        }\n\n        public void run() {\n            TestClazz testClazz = new TestClazz(new Random().nextInt());\n            Map<String, Object> params = new HashMap<String, Object>();\n            params.put(\"clazz\", testClazz);\n            groovyClass.setProperty(\"clazz\", testClazz);\n            System.out.println(groovyClass.run());\n        }\n    }\n\n\n    public static void main(String[] args) throws URISyntaxException, IOException, IllegalAccessException, InstantiationException, InterruptedException {\n        GroovyClassLoader loader = new GroovyClassLoader();\n        Class clazz = loader.parseClass(new File(\"/Users/liming_liu/Documents/workspace/groovy-demo/TestGroovy.groovy\"));\n        Parent parent = (Parent) clazz.newInstance();\n\n        InputStreamReader is_reader = new InputStreamReader(System.in);\n        String str = new BufferedReader(is_reader).readLine();\n\n\n        while (true){\n            for (int i = 0; i<10; ++i) {\n                MyGroovyClassThread myGroovyClassThread = new MyGroovyClassThread(parent);\n                myGroovyClassThread.run();\n            }\n            Thread.sleep(50);\n        }\n\n    }\n\n    static class MyGroovyClassThread extends Thread {\n        Parent parent;\n        boolean interupt = false;\n        public MyGroovyClassThread(Parent parent) {\n            this.parent = parent;\n        }\n        public MyGroovyClassThread(Parent parent, boolean interupt) {\n            this.parent = parent;\n            this.interupt = interupt;\n        }\n\n        public void run() {\n            parent.run();\n        }\n    }\n}\n\n{code}",
        "Reflection API for Traits There needs to be some kind of reflection API for traits, so that programs can reason about traits at runtime. For example, one thing I need to know for Spock is whether a method that, according to Java reflection, is declared in class X, is actually declared in that Groovy class, or inherited from a trait."
    ],
    [
        "GROOVY-5389",
        "GROOVY-2866",
        "Integrate all Groovy API documentation I currently have three links for Groovy-related API documentation: the JDK, the Groovy JDK, and the Groovy API docs. This makes it hard for users that are new to Groovy since they have to look in 3 different locations for docs.\n\nAll three should be integrated together as the Groovy API documentation, with individual entries indicating whether they are part of core Java, methods or properties added to those classes, or Groovy-only classes. This is probably non-trivial but worth the investment in effort.\n\nOne difficulty of course is knowing which Java API docs to integrate with the Groovy docs, but I would recommend whatever is the latest publicly available Java release.",
        "add chaining operator to groovy This was a proposal I brought up on the groovy-dev mailing list.  Link to complete discussion is here:\n\nhttp://www.nabble.com/how-about-a-chain-operator--td16771140.html#a16771140\n\nIn short there are really 2 proposals:  \n\n# have groovy default to converting void return types to  \"this\" instead of null \n# add an operator for forcing the return type to be \"this\" to allow chaining of operations on an object.  \n\nExamples of 1:\n{code}\nuser.setFirstName(\"todd\").setLastName(\"blankenship\").validate()\nmyList.remove(\"item1\").remove(\"item2\").sort()\n{code}\n\nExamples of 2 (assuming -> as operator):\n{code}\nuser->setFirstName(\"todd\")->setLastName(\"blankenship\")->validate()\nmyList->remove(\"item1\")->remove(\"item2\")->sort()\n{code}\n\nExamples of 2 (assuming +. as operator):\n{code}\nuser+.setFirstName(\"todd\")+.setLastName(\"blankenship\")+.validate()\nmyList+.remove(\"item1\")+.remove(\"item2\")+.sort()\n{code}\n"
    ],
    [
        "GROOVY-3076",
        "GROOVY-1197",
        "ConstantExpression line, column data overlap defining scope When this sample grails config is parsed\n{noformat}\ndataSource {\n\tpooled = true\n\tdriverClassName = \"org.hsqldb.jdbcDriver\"\n\tusername = \"sa\"\n\tpassword = \"\"\n}.\nhibernate {\n    cache.use_second_level_cache=true\n    cache.use_query_cache=true\n    cache.provider_class='com.opensymphony.oscache.hibernate.OSCacheProvider'\n}\n// environment specific settings\nenvironments {\n\tdevelopment {\n\t\tdataSource {\n\t\t\tdbCreate = \"create-drop\" // one of 'create', 'create-drop','update'\n\t\t\turl = \"jdbc:hsqldb:mem:devDB\"\n\t\t}\n\t}\n\ttest {\n\t\tdataSource {\n\t\t\tdbCreate = \"update\"\n\t\t\turl = \"jdbc:hsqldb:mem:testDb\"\n\t\t}\n\t}\n\tproduction {\n\t\tdataSource {\n\t\t\tdbCreate = \"update\"\n\t\t\turl = \"jdbc:hsqldb:file:prodDb;shutdown=true\"\n\t\t}\n\t}\n}\n{noformat}\n\nConstantExpression for string at line 5 provides following: lineNumber=5, columnNumber=13, lastLineNumber=7, lastColumnNumber=1. The columnNumber seems to be right (there is a tab at the beginning of the line), however lastLine and lastColumn overlaps the closure definition.",
        "Multi-D arrays don't work with custom classes as base element The multidimensional arrays work perfectly with primitive types and standard classes from the JDK (or from libraries too I guess), but it seems there's a problem if you're using a class defined in the same source unit. So for instance, the following code will fail:\n\ngroovy> class Foo {}\ngroovy> ff = new Foo[3][4]\ngroovy> go\nCaught: java.lang.ClassFormatError: CommandLine (Illegal Class name \"Foo[][]\")"
    ],
    [
        "GROOVY-6108",
        "GROOVY-3472",
        "Null-safe operator on lhs of comparison may lead to NPE with @CompileStatic The following code throws an NPE at runtime if compiled using {{@CompileStatic}}:\n\n{code}\nclass A {\n  int foo() { 123 }\n}\nA a = null\ndef bar = a?.foo() == 123 // will evaluate to false\nassert bar == false\n{code}",
        "Wrong line/column numbers for method and closure blocks Under certain circumstances code blocks (BlockStatement) of MethodNode and ClosureExpression have just [-1,-1,-1,-1] for line and column numbers, while parent (MethodNode, ClosureExpression) is ok. Sometimes even some statements in the block have [-1,-1,-1,-1] coordinates.\n\nSample - method x:\n{noformat}\nclass GroovyClass {\n    def x() {\n        String a\n\n        \n    }\n}\n{noformat}\n\nIn this situation MethodNode [2,5,6,6], code BlockStatement [-1,-1,-1,-1] , ReturnStatement [-1,-1,-1,-1]"
    ],
    [
        "GROOVY-6924",
        "GROOVY-448",
        "Runtime IncompatibleClassChangeError using with() on a JavaBean if @CompileStatic is used Consider the following Java class:\n\n{code:java}\npackage i;\n\npublic class MyJavaBean {\n\tprivate String foo;\n\tprivate String bar;\n\t\n\tpublic String getFoo() {\n\t\treturn foo;\n\t}\n\t\n\tpublic void setFoo(String foo) {\n\t\tthis.foo = foo;\n\t}\n\t\n\tpublic String getBar() {\n\t\treturn bar;\n\t}\n\t\n\tpublic void setBar(String bar) {\n\t\tthis.bar = bar;\n\t}\n}\n{code}\n\nand the following Groovy class:\n\n{code}\npackage i\n\nimport groovy.transform.CompileStatic;\n\n@CompileStatic\nclass I {\n  void doSomething() {\n\t  MyJavaBean bean = new MyJavaBean()\n\t  bean.with {\n\t\t  foo = 'foo'\n\t\t  bar = 'bar'\n\t  }\n\t  println \"$bean.foo and $bean.bar\"\n  }\n  \n  static void main(String[] args) {\n\t  new I().doSomething()\n  }\n}\n{code}\n\nIf you run it as a Groovy script, you get:\n{noformat}\nCaught: java.lang.IncompatibleClassChangeError: Class i.MyJavaBean does not implement the requested interface groovy.lang.GroovyObject\njava.lang.IncompatibleClassChangeError: Class i.MyJavaBean does not implement the requested interface groovy.lang.GroovyObject\n\tat i.I$_doSomething_closure1.doCall(I.groovy:10)\n\tat i.I$_doSomething_closure1.call(I.groovy)\n\tat i.I.doSomething(I.groovy:9)\n\tat i.I.main(I.groovy:17)\n{noformat}\n\nIf you remove the {{@CompileStatic}} annotation from {{I}} class, all works fine.\n\nOn another project (the real one were I caught this), I get the same exception but with a different stack trace/error message:\n{noformat}\njava.lang.IncompatibleClassChangeError\n\tat org.codehaus.groovy.runtime.ScriptBytecodeAdapter.setGroovyObjectProperty(ScriptBytecodeAdapter.java:528)\n\tat com.example.MyClass$_myMethod_closure4.doCall(MyClass.groovy:194)\n{noformat}\n\nThe location is always an assignment within a {{with()}} closure. Again, I can workaround this by removing static compilation from that method.",
        "Improved Groovy Console Apply Danno Ferrin's patches to the default GroovyConsole.\n\n  * New, Open, Save implemented.\n    * New opens an entirely new blank console\n    * Once opened or saved the filename is preserved and\n       contents not cleared from the editing area\n    * save prompts for a filename if absent\n    * and save on close for \"oops, that's not maximize!\"\n  * Added mnemonics\n    * Is there an easy way to get Ints from a char or\n      a string?  Using hex codes seemed easier\n  * Added some more keyboard shortcuts\n  * split bar is in the middelish now"
    ],
    [
        "GROOVY-4946",
        "GROOVY-7613",
        "Groovy getAt cannot be used with lazily initialized lists I'm not sure if this should even be logged as a bug, but here goes:\n\nI was playing around with the Apache Commons {{ListUtils.lazyList}}.  This list will automatically create an item if an index is not yet defined (or is {{null}}).  Example code:\n\n{code:title=Example.groovy}\n@Grab(group='commons-collections', module='commons-collections', version='[1.3,)')\nimport org.apache.commons.collections.ListUtils\nimport org.apache.commons.collections.Factory\nimport groovy.transform.Canonical\n\n@Canonical class Test {\n    String name\n    int amount\n}\n\nList<Test> t = ListUtils.lazyList([], { new Test() } as Factory)\n\n// UNCOMMENT to make the example work:\n// t.get(1)\n\n// Thows NPE here:\nt[1].name = 'Jim'\nt[0].amount = 6\n\nassert t == [new Test(null, 6), new Test('Jim', 0)]\n{code}\n\nHowever, I thought it was broken, because I had been running with without the commented {{t.get(1)}} line.  The {{getAt}} code checks the size of the dynamic list, and since it is smaller, returns {{null}}.  This causes an NPE to be thrown.\n\nI realize that the lazy list breaks the {{List}} contract (by dynamically changing the list size).  However, it seems like a fairly useful feature to have a lazily created list.\n\nI'm not sure there is an acceptable solution, but returning {{null}} hides the problem in a way that is hard to debug!  Maybe it would be better to have a {{withDefault}} method for lists, too, that works like the one for {{Map}}s.  That would provide a usable solution without breaking the current design.  Plus, you no longer have to include the commons library for that use case.  :-)",
        "Grape fails to load Groovy Extensions https://github.com/elastic/elasticsearch-groovy/issues/29\r\n\r\n*The problem is that it has Groovy itself as a dependency, so using GrabExclude avoids the dependency and therefore the issue.*\r\n\r\nA user of mine ran into an issue while trying to use Grape to load a recent version of the elasticsearch-groovy jar. I was able to reproduce in different versions of Groovy.\r\n\r\n{code}\r\n@Grapes(\r\n     @Grab(group='org.elasticsearch', module='elasticsearch-groovy', version='1.7.1')\r\n)\r\nimport java.lang.String\r\n{code}\r\n\r\nLiterally that code when launched via:\r\n\r\n{code}\r\n$ groovy file.groovy\r\nCaught: BUG! exception in phase 'conversion' in source unit '/Users/pickypg/Dev/es/es-groovy/tmp/elasticsearch.groovy' # Licensed to the Apache Software Foundation (ASF) under one or more\r\nBUG! exception in phase 'conversion' in source unit '/Users/pickypg/Dev/es/es-groovy/tmp/elasticsearch.groovy' # Licensed to the Apache Software Foundation (ASF) under one or more\r\nCaused by: java.lang.ClassNotFoundException: # Licensed to the Apache Software Foundation (ASF) under one or more\r\n{code}\r\n\r\nUsing this code:\r\n\r\n{code}\r\nimport groovy.grape.Grape\r\n\r\ntry {\r\n  Grape.grab(group: 'org.elasticsearch', module: 'elasticsearch-groovy', version: '1.7.1')\r\n}\r\ncatch (Throwable t) {\r\n  t.printStackTrace()\r\n}\r\n{code}\r\n\r\nThis creates a surprising stacktrace:\r\n\r\n{code}\r\njava.lang.ClassNotFoundException: # Licensed to the Apache Software Foundation (ASF) under one or more\r\n\tat java.net.URLClassLoader.findClass(URLClassLoader.java:381)\r\n\tat java.lang.ClassLoader.loadClass(ClassLoader.java:424)\r\n\tat groovy.lang.GroovyClassLoader.loadClass(GroovyClassLoader.java:677)\r\n\tat groovy.lang.GroovyClassLoader$InnerLoader.loadClass(GroovyClassLoader.java:425)\r\n\tat groovy.lang.GroovyClassLoader.loadClass(GroovyClassLoader.java:787)\r\n\tat groovy.lang.GroovyClassLoader.loadClass(GroovyClassLoader.java:775)\r\n\tat groovy.lang.GroovyClassLoader$loadClass.call(Unknown Source)\r\n\tat org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:48)\r\n\tat org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:113)\r\n\tat org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:125)\r\n\tat groovy.grape.GrapeIvy$_processRunners_closure4.doCall(GrapeIvy.groovy:340)\r\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\r\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\r\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\r\n\tat java.lang.reflect.Method.invoke(Method.java:497)\r\n\tat org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:93)\r\n\tat groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:325)\r\n\tat org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:294)\r\n\tat groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:1019)\r\n\tat groovy.lang.Closure.call(Closure.java:426)\r\n\tat groovy.lang.Closure.call(Closure.java:442)\r\n\tat org.codehaus.groovy.runtime.DefaultGroovyMethods.each(DefaultGroovyMethods.java:2030)\r\n\tat org.codehaus.groovy.runtime.DefaultGroovyMethods.each(DefaultGroovyMethods.java:2015)\r\n\tat org.codehaus.groovy.runtime.DefaultGroovyMethods.each(DefaultGroovyMethods.java:2056)\r\n\tat org.codehaus.groovy.runtime.dgm$162.invoke(Unknown Source)\r\n\tat org.codehaus.groovy.runtime.callsite.PojoMetaMethodSite$PojoMetaMethodSiteNoUnwrapNoCoerce.invoke(PojoMetaMethodSite.java:274)\r\n\tat org.codehaus.groovy.runtime.callsite.PojoMetaMethodSite.call(PojoMetaMethodSite.java:56)\r\n\tat org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:48)\r\n\tat org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:113)\r\n\tat org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:125)\r\n\tat groovy.grape.GrapeIvy.processRunners(GrapeIvy.groovy:339)\r\n\tat groovy.grape.GrapeIvy$processRunners$3.callCurrent(Unknown Source)\r\n\tat org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCallCurrent(CallSiteArray.java:52)\r\n\tat org.codehaus.groovy.runtime.callsite.AbstractCallSite.callCurrent(AbstractCallSite.java:154)\r\n\tat org.codehaus.groovy.runtime.callsite.AbstractCallSite.callCurrent(AbstractCallSite.java:182)\r\n\tat groovy.grape.GrapeIvy.processOtherServices(GrapeIvy.groovy:324)\r\n\tat groovy.grape.GrapeIvy$processOtherServices$2.callCurrent(Unknown Source)\r\n\tat groovy.grape.GrapeIvy.grab(GrapeIvy.groovy:265)\r\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\r\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\r\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\r\n\tat java.lang.reflect.Method.invoke(Method.java:497)\r\n\tat org.codehaus.groovy.runtime.callsite.PogoMetaMethodSite$PogoCachedMethodSite.invoke(PogoMetaMethodSite.java:169)\r\n\tat org.codehaus.groovy.runtime.callsite.PogoMetaMethodSite.callCurrent(PogoMetaMethodSite.java:59)\r\n\tat org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCallCurrent(CallSiteArray.java:52)\r\n\tat org.codehaus.groovy.runtime.callsite.AbstractCallSite.callCurrent(AbstractCallSite.java:154)\r\n\tat org.codehaus.groovy.runtime.callsite.AbstractCallSite.callCurrent(AbstractCallSite.java:174)\r\n\tat groovy.grape.GrapeIvy.grab(GrapeIvy.groovy:239)\r\n\tat groovy.grape.Grape.grab(Grape.java:151)\r\n\tat groovy.grape.Grape$grab.call(Unknown Source)\r\n\tat org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:48)\r\n\tat org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:113)\r\n\tat org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:125)\r\n\tat elasticsearch.run(elasticsearch.groovy:4)\r\n\tat groovy.lang.GroovyShell.runScriptOrMainOrTestOrRunnable(GroovyShell.java:263)\r\n\tat groovy.lang.GroovyShell.run(GroovyShell.java:524)\r\n\tat groovy.lang.GroovyShell.run(GroovyShell.java:513)\r\n\tat groovy.ui.GroovyMain.processOnce(GroovyMain.java:652)\r\n\tat groovy.ui.GroovyMain.run(GroovyMain.java:384)\r\n\tat groovy.ui.GroovyMain.process(GroovyMain.java:370)\r\n\tat groovy.ui.GroovyMain.processArgs(GroovyMain.java:129)\r\n\tat groovy.ui.GroovyMain.main(GroovyMain.java:109)\r\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\r\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\r\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\r\n\tat java.lang.reflect.Method.invoke(Method.java:497)\r\n\tat org.codehaus.groovy.tools.GroovyStarter.rootLoader(GroovyStarter.java:109)\r\n\tat org.codehaus.groovy.tools.GroovyStarter.main(GroovyStarter.java:131)\r\n{code}"
    ],
    [
        "GROOVY-4662",
        "GROOVY-6429",
        "Closures leak InvokerInvocationException to Java callers GroovyLib.groovy:\n{code}\nclass GroovyLib {\n  void boom() throws IOException { throw new IOException() }\n  void undeclaredBoom() { throw new IOException() }\n  Closure closure = { throw new IOException() }\n  Runnable runnable = { throw new IOException() }\n}\n{code}\n\nGroovyJavaExceptionPropagationTest.java:\n{code}\npublic class GroovyJavaExceptionPropagationTest {\n  @Test(expected = IOException.class)\n  public void callGroovyMethodThatThrowsDeclaredCheckedException() throws Exception {\n    new GroovyLib().boom(); // throws IOException\n  }\n\n  @Test(expected = IOException.class)\n  public void callGroovyMethodThatThrowsUndeclaredCheckedException() throws Exception {\n    new GroovyLib().undeclaredBoom(); // throws IOException\n  }\n\n  @Test(expected = IOException.class)\n  public void callGroovyClosureThatThrowsCheckedException() throws Exception {\n    new GroovyLib().getClosure().call(); // throws InvokerInvocationException\n  }\n\n  @Test(expected = IOException.class)\n  public void callGroovyClosureDisguisedAsRunnableThatThrowsCheckedException() throws Exception {\n    new GroovyLib().getRunnable().run(); // throws InvokerInvocationException\n  }\n}\n{code}\n",
        "flow typing detects unexpected error at if-else flow In groovy 2.2.0-rc-3, this code:\n{code}\nclass A{\n}\nclass B extends A{\n    void foo(){}\n}\n\n@groovy.transform.TypeChecked\nvoid test1(A x) {\n    if (x instanceof B) {\n        x.foo()\n    }\n}\n\n@groovy.transform.TypeChecked\nvoid test2(A x) {\n    if (!(x instanceof B)) {\n        return\n    }\n    x.foo()\n}\n\n@groovy.transform.TypeChecked\nvoid test3(A x) {\n    if (!(x instanceof B)) {\n        return\n    }\n    else {\n        x.foo()\n    }\n}\n@groovy.transform.TypeChecked\nvoid test4(A x) {\n    if (!(x instanceof B)) {\n        return\n    }\n    assert x instanceof B\n    x.foo()\n}\n\ntest1(new B())\ntest2(new B())\ntest3(new B())\ntest4(new B())\n\n{code}\nexpects all OK. but test2 and test3 results in:\n{quote}\n% groovy a.groovy\norg.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed:\n/Users/uehaj/work/201311/comprehension_groovy/a.groovy: 19: [Static type checking] - Cannot find matching method A#foo(). Please check if the declared type is right and if the method exists.\n @ line 19, column 5.\n       x.foo()\n       ^\n\n/Users/uehaj/work/201311/comprehension_groovy/a.groovy: 28: [Static type checking] - Cannot find matching method A#foo(). Please check if the declared type is right and if the method exists.\n @ line 28, column 9.\n           x.foo()\n           ^\n\n2 errors\n{quote}"
    ],
    [
        "GROOVY-2391",
        "GROOVY-4185",
        "ExpandoMetaClass: Unable to override DGM asType method on certain types See: http://www.nabble.com/EMC-Problem-in-Groovy-1.5---Overriding-%22asType%22-method-on-ArrayList-td14298090.html\n\nI've just stumbled upon a problem with Groovy 1.5 which was already solved in some previous betas... It's about overriding the asType method on the ArrayList.\n\nDoing something like this:\n\nArrayList.metaClass.asType = { Class clazz -> /* .... */ }\nArrayList.metaClass.initialize()\n\nthen\n\n[1,2,3] as /* any class here */\nor\n[1,2,3].asType( /* any class here */)\n\ndoes not invoke the closure code...\n\nUsing emc stuff and asType method with other classes works so far as I can say....",
        "groovy.util.GroovyScriptEngine.loadScriptByName does not accept scripts without \".groovy\" extension Hi,\n\nIn version 1.6.5 the API *groovy.util.GroovyScriptEngine.loadScriptByName* used to accept groovy script name with extension.\nNow I have installed 1.7.2 and it is throwing exception for groovy script name without extension.\n\nPlease let me know if this is bug or done purposely, so that I can change my code accordingly\n\nThanks,\nRajendra"
    ],
    [
        "GROOVY-2232",
        "GROOVY-739",
        "VerifyError when using DelegatingMetaClass Hi, I have a problem with DelegatingMetaClass. I am trying to extend groovy.sql.Sql class with a static method similar to newInstance but that takes only one parameter ( a file name that contains all the connection parameters )\n\nSo I have used DelegatingMetaClass conventions and here is my SqlMetaClass.groovy:\n------------------------\npackage groovy.runtime.metaclass.groovy.sql\n\nimport groovy.sql.Sql\n\nclass SqlMetaClass extends groovy.lang.DelegatingMetaClass\n{\n    SqlMetaClass(MetaClassRegistry a_registry, final Class a_class)\n    {\n        super(a_class);\n    }\n\n    public Object invokeStaticMethod(Object a_object, String a_methodName, Object[] a_arguments)\n    {\n        if(a_methodName == 'newInstance'){\n                        if(a_arguments.length == 1) {\n                            //interpret the first argument as a file name\n                Properties props = new Properties()\n                            props.load(new FileInputStream(a_arguments[0]))\n                            return Sql.newInstance(props['db.url'],props['db.user'], props['db.password'], props['db.drivername'])\n                        }\n        }\n        return super.invokeStaticMethod(a_object, a_methodName, a_arguments)        \n    }\n}\n------------------------\n\nAfterwards calling Sql.newInstance('hsql.properties') in some script worked as expected.\nMy problem is that it works only from eclipse, the moment I try to use it standalone I get some errors:\n\n1. Calling the script as groovy -cp ../bin-groovy bug.groovy ( using the compiled class generated by the eclipse plug-in ) I get:\n\nCaught: java.lang.VerifyError: (class: groovy/runtime/metaclass/groovy/sql/SqlMetaClass, method: super$2$invokeMethod signature: (Ljava/lang/Class;Ljava/lang/Object;Ljava/lang/String;[Ljava/lang/Object;ZZ)Ljava/lang/Object;) Illegal use of nonvirtual function call\n        at bug.run(bug.groovy:4)\n        at bug.main(bug.groovy)\n\n2. Calling the script as groovy -cp ../clazzez bug.groovy gives me :\nCaught: java.lang.VerifyError: (class: groovy/runtime/metaclass/groovy/sql/SqlMetaClass, method: super$2$setUseReflection signature: (Z)V) Illegal use of nonvirtual function call\n        at bug.run(bug.groovy:4)\n        at bug.main(bug.groovy)\n\nwhere clazzez is the directory where I compiled the SqlMetaClass.groovy file using groovyc\n\n<?xml version=\"1.0\"?>\n\n<project name=\"Compile a groovy class\" default=\"compile\" basedir=\".\">\n        <target name=\"compile\">\n                <taskdef name=\"groovyc\" classname=\"org.codehaus.groovy.ant.Groovyc\" />\n\n                <groovyc srcdir=\"scripts/groovy\" destdir=\"clazzez\">\n                       \n                </groovyc>\n\n        </target>\n</project>\n\nEnvironment WinXP SP2\nThe eclipse plugin is V 1.0.1 installed on Eclipse 3.3.0\nWhen trying to run the script standalone I use Groovy Version: 1.1-rc-1 JVM: 1.6.0_03-b05 ",
        "Handling the Meta Character \\b in String or GString Lets get Groovy!\n================\nVersion: 1.0-beta-10-SNAPSHOT JVM: 1.4.2_06-b03\nType 'exit' to terminate the shell\nType 'help' for command help\nType 'go' to execute the statements\n\ngroovy> println \"ABCD\\bEF\"\ngroovy> go\nABCD\\bEF\n\n\n// Expected: ABCEF"
    ],
    [
        "GROOVY-4499",
        "GROOVY-7048",
        "External command execution ignores pipes and redirects Pipes and redirects are ignored when calling external command from groovy.\n\nE.g. this:\n\n\"\"\"ls -al /tmp\"\"\".execute().text\n\nworks as expected, listing all entries in /tmp.\n\nNow let's assume that \n\nls -al /tmp/ | grep ssh\n\non my local machine yields one file.\n\nExecuting the above from groovy like that:\n\n\"\"\"ls -al /tmp/ | grep ssh\"\"\".execute().text\n\nreturns everything in /tmp, because apparently the \"|\" and everything after it is ignored.\n\nThe same goes \"<>\".",
        "Groovysh: Missing completion for optional_dot ?. and spread-dot *. Currently no completion is considered for x?.| and x*.|\n\nI suggest that for x*., completion will assume that the element found by x.find() will represent all elements in the 'collection' type. Alternatives would be to try and complete using the intersection of candidates members within the 'collection', but that may be much more complicated code to be worth the effort, IMO."
    ],
    [
        "GROOVY-90",
        "GROOVY-7667",
        "variables are not preserved across commands in the shell variable bindings are not preserved across statements in the shell...\n\n\ngroovy> list = [1, 2, 'hello', new java.util.Date()]\ngroovy>\n[1, 2, \"hello\", Tue Dec 23 11:31:41 CST 2003]\ngroovy> list.size()\ngroovy>\nCaught: java.lang.NullPointerException: Cannot invoke method: size on null object",
        "AnnotationCollector should disregard @Target and @Retention I attempted to set up an annotation-inheritance situation using {{@AnnotationCollector}}, and I wrote the intermediate collector in Java. Since the intermediate collector was applied to my leaf collector, I put {{@Target(ElementType.ANNOTATION_TYPE)}} on the intermediate collector, but it appears that Groovy copied that annotation to the final target class, where it wasn't allowed and produced a compiler error.\r\n\r\nI suggest that {{@Target}} and {{@Retention}} should be specifically ignored when added to a collector annotation."
    ],
    [
        "GROOVY-2366",
        "GROOVY-6889",
        "A integer precision error (2147483647 + 2 == -2147483647 is true?) Just run the following statement, groovy will produces error results:\n\na = 123456\nb = 234567\nprintln a * b\n\nprintln 123456 * 234567\n\nx = 2147483647\ny = 2\nprintln x + y\n\nprintln 2147483647 + 2 == -2147483647\n\nprintln 2147483647 * 2\n",
        "clean up generated code when using @AutoExternalize with @CompileStatic When using @AutoExternalize with @CompileStatic the code in readExternal has some missing casts. These errors are currently ignored by @CS and the generated code is currently OK for the happy path but we might as well add in the missing casts to minimize the risk of any future adverse interactions."
    ],
    [
        "GROOVY-6816",
        "GROOVY-3191",
        "Star imports fail to evaluate I notice this on master:\ngroovy:000> import java.lang.*\n===> java.lang.*\ngroovy:000> println 'hello'\nERROR org.codehaus.groovy.control.MultipleCompilationErrorsException:\nstartup failed:\ngroovysh_evaluate: 1: unexpected token: * @ line 1, column 11.\n   java.lang.*\n             ^\n\nI reduced the imports to just the packagename in an earlier commit. I think probably a merge failed and so no the import keyword does not get appended. Probably I messed up the merge myself. Will work on it now. Not sure if 2_3_X branch is affected.",
        "Groovysh cannot be extended We currently have a problem with lazy load exceptions happening in Grails within the Groovysh command line shell. I tried to extend the shell so that we could fix the problem, however when I extend it the whole thing breaks because some of the commands access private fields of Groovysh which are not available when you subclass. For example I get an exception like this:\n\n{code}\ngroovy.lang.MissingPropertyException: No such property: interp for class: org.codehaus.groovy.grails.cli.TransactionAwareGroovysh\n\tat org.codehaus.groovy.runtime.ScriptBytecodeAdapter.unwrap(ScriptBytecodeAdapter.java:49)\n\tat org.codehaus.groovy.runtime.callsite.PogoMetaClassGetPropertySite.getProperty(PogoMetaClassGetPropertySite.java:50)\n\tat org.codehaus.groovy.runtime.callsite.AbstractCallSite.callGroovyObjectGetProperty(AbstractCallSite.java:240)\n\tat org.codehaus.groovy.tools.shell.commands.ImportCommand.createCompletors(ImportCommand.groovy:44)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n{code}\n\nThis is because ImportCommand tries to access the \"interop\" property in this method:\n\n{code}\n    protected List createCompletors() {\n        return [\n            new ImportCommandCompletor(shell.interp.classLoader),\n            null\n        ]\n    }\n{code}\n\nHowever said property is private, and when you subclass it is not longer visible. Can you please add getters for the following private fields so that Groovysh can be subclassed:\n\n* buffers\n* parser\n* interop\n* imports\n* runner\n* history\n\nThanks!"
    ],
    [
        "GROOVY-6246",
        "GROOVY-7416",
        "ResourceBundle.getBundle() freezes on openjdk 1.7.0_25 The following line freezes Groovy on openjdk 1.7.0_25, causing 100% CPU load:\n\n{code:java}\nResourceBundle foo = ResourceBundle.getBundle('foo');\n{code}\n\nIt is working fine with openjdk 1.7.0_9. I could reproduce this bug with various Groovy versions from 1.8 up to 2.1.6, and on two different Fedora 18 machines.\n\nA java dump delivered this thread stack trace:\n\n{code}\n\"main\" prio=10 tid=0x00007f1014008000 nid=0xd74 runnable [0x00007f101a0cf000]\n   java.lang.Thread.State: RUNNABLE\n\tat sun.reflect.Reflection.getCallerClass0(Native Method)\n\tat sun.reflect.Reflection.getCallerClass(Reflection.java:68)\n\tat sun.reflect.GeneratedMethodAccessor1.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:606)\n\tat org.codehaus.groovy.reflection.ReflectionUtils.getCallingClass(ReflectionUtils.java:117)\n\tat org.codehaus.groovy.reflection.ReflectionUtils.getCallingClass(ReflectionUtils.java:91)\n\tat org.codehaus.groovy.reflection.ReflectionUtils.getCallingClass(ReflectionUtils.java:78)\n\tat org.codehaus.groovy.runtime.DefaultGroovyStaticMethods.getBundle(DefaultGroovyStaticMethods.java:231)\n\tat org.codehaus.groovy.runtime.DefaultGroovyStaticMethods.getBundle(DefaultGroovyStaticMethods.java:215)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:606)\n\tat org.codehaus.groovy.runtime.metaclass.ReflectionMetaMethod.invoke(ReflectionMetaMethod.java:51)\n\tat org.codehaus.groovy.runtime.metaclass.NewStaticMetaMethod.invoke(NewStaticMetaMethod.java:51)\n\tat org.codehaus.groovy.runtime.callsite.StaticMetaMethodSite$StaticMetaMethodSiteNoUnwrapNoCoerce.invoke(StaticMetaMethodSite.java:148)\n\tat org.codehaus.groovy.runtime.callsite.StaticMetaMethodSite.call(StaticMetaMethodSite.java:88)\n\tat org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:45)\n\tat org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:108)\n\tat org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:116)\n\tat Test.run(Test.groovy:1)\n\tat groovy.lang.GroovyShell.runScriptOrMainOrTestOrRunnable(GroovyShell.java:257)\n\tat groovy.lang.GroovyShell.run(GroovyShell.java:220)\n\tat groovy.lang.GroovyShell.run(GroovyShell.java:150)\n\tat groovy.ui.GroovyMain.processOnce(GroovyMain.java:588)\n\tat groovy.ui.GroovyMain.run(GroovyMain.java:375)\n\tat groovy.ui.GroovyMain.process(GroovyMain.java:361)\n\tat groovy.ui.GroovyMain.processArgs(GroovyMain.java:120)\n\tat groovy.ui.GroovyMain.main(GroovyMain.java:100)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:606)\n\tat org.codehaus.groovy.tools.GroovyStarter.rootLoader(GroovyStarter.java:106)\n\tat org.codehaus.groovy.tools.GroovyStarter.main(GroovyStarter.java:128)\n{code}\n\nMajor priority because this bug potentially affects any multilingual Groovy project.",
        "Problem With CompileStatic And Interface Methods In Abstract Subclass The attached abstractcompilestatic.zip contains the following:\r\n\r\n{code:borderStyle=solid|title=src/main/groovy/demo/SomeInterface.groovy}\r\npackage demo\r\n\r\ninterface SomeInterface {\r\n    void someInterfaceMethod()\r\n}\r\n{code}\r\n\r\n{code:borderStyle=solid|title=src/main/groovy/demo/AbstractSuperClass.groovy}\r\npackage demo\r\n\r\nabstract class AbstractSuperClass implements SomeInterface {}\r\n{code}\r\n\r\n{code:borderStyle=solid|title=src/main/groovy/demo/AbstractSubClass.groovy}\r\npackage demo\r\n\r\nimport groovy.transform.CompileStatic\r\n\r\n@CompileStatic\r\nabstract class AbstractSubClass extends AbstractSuperClass {\r\n\r\n    void someMethod() {\r\n        someInterfaceMethod()\r\n    }\r\n}\r\n{code}\r\n\r\nThe code will not compile.\r\n\r\n{noformat}\r\n $ ./gradlew clean compileGroovy\r\n:clean\r\n:compileJava UP-TO-DATE\r\n:compileGroovy\r\nstartup failed:\r\n/Users/jeff/abstractcompilestatic/src/main/groovy/demo/AbstractSubClass.groovy: 9: [Static type checking] - Cannot find matching method demo.AbstractSubClass#someInterfaceMethod(). Please check if the declared type is right and if the method exists.\r\n @ line 9, column 9.\r\n           someInterfaceMethod()\r\n           ^\r\n\r\n1 error\r\n\r\n:compileGroovy FAILED\r\n\r\nFAILURE: Build failed with an exception.\r\n\r\n* What went wrong:\r\nExecution failed for task ':compileGroovy'.\r\n> Compilation failed; see the compiler error output for details.\r\n\r\n* Try:\r\nRun with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output.\r\n\r\nBUILD FAILED\r\n\r\nTotal time: 4.045 secs\r\n{noformat}\r\n\r\nIf the AbstractSubClass is modified to implement the interface as shown below the code will compile:\r\n\r\n\r\n{code:borderStyle=solid|title=src/main/groovy/demo/AbstractSubClass.groovy}\r\npackage demo\r\n\r\nimport groovy.transform.CompileStatic\r\n\r\n@CompileStatic\r\nabstract class AbstractSubClass extends AbstractSuperClass implements SomeInterface {\r\n\r\n    void someMethod() {\r\n        someInterfaceMethod()\r\n    }\r\n}\r\n{code}\r\n"
    ],
    [
        "GROOVY-6311",
        "GROOVY-3970",
        "Using @CompileStatic on code that uses spread operator on a Set results in compilation error The two attached files (bad.groovy & good.groovy) demonstrate the problem.  In bad.groovy, a class with the @CompileStatic annotation attempts to collect the objects from a Set<> using the spread operator and fails with the compilation error:\n\norg.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed:\nbad.groovy: 17: [Static type checking] - No such property: strings for class: java.util.Set <Inner>\n @ line 17, column 13.\n       println outer.inners*.strings\n               ^\n\n1 error\n\nIn good.groovy, the equivalent .collect{} is used for the spread operator and it compiles and runs as expected.",
        "Problems using method variables/parameters in Anonymous inner classes which are created inside a closure While trying out the new Groovy 1.7 together with Vaadin 6.2.0 it stumpled upon a problem using anonymous inner classes.\n\nInside my UiBuilder class I have this method, which basically iterates over a list of ViewBuilders:\n{code}\n    private void setupRootLayout(Window window) {\n\t\tHorizontalLayout main = new HorizontalLayout();\n\t\twindow.setContent(main);\n\t\t\n\t\tGridLayout grid = new GridLayout(1, 1);\n\n\t\tviewFactory.rootLevelViews.each { \n\t\t\tButton viewLabel = new Button(\"${it.viewName}\");\n                        // Window x = window;    <--- uncomment to make the sample work\n\t\t\tviewLabel.addListener(new ClickListener() {\n\t\t\t\tpublic void buttonClick(ClickEvent event) {\n                                        // x.showNotification(\"Clicked \" + event.getButton().getCaption());  <-- Uncomment to make the sample work\n\t\t\t\t\twindow.showNotification(\"Clicked \" + event.getButton().getCaption());\n\t\t\t\t}\n\t\t\t});\n\t\t\tgrid.addComponent(viewLabel);\n\t\t}\n{code}\nWhen I run this code (both with and without the window parameter defined as final) I get a runtime exception.\nI've also tried to create a method variable \"Window x = window;\" without success.\nThe only solution that worked was to uncomment the comment \"Window x = window;\" just before \"viewLabel.addListener(new ClickListener() {\" and then use \"x\" instead of \"window\" inside the \"buttonClick\" method.\n\nHere's the runtime exception I get:\n{code}\ngroovy.lang.GroovyRuntimeException: groovy.lang.GroovyRuntimeException: Could not find matching constructor for: dk.cramon.vaadintest.ui.UiBuilder$1(dk.cramon.vaadintest.ui.UiBuilder, com.vaadin.ui.Window)\n\tgroovy.lang.MetaClassImpl.invokeConstructor(MetaClassImpl.java:1484)\n\tgroovy.lang.MetaClassImpl.invokeConstructor(MetaClassImpl.java:1400)\n\torg.codehaus.groovy.runtime.callsite.MetaClassConstructorSite.callConstructor(MetaClassConstructorSite.java:46)\n\torg.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCallConstructor(CallSiteArray.java:52)\n\torg.codehaus.groovy.runtime.callsite.AbstractCallSite.callConstructor(AbstractCallSite.java:192)\n\torg.codehaus.groovy.runtime.callsite.AbstractCallSite.callConstructor(AbstractCallSite.java:204)\n\tdk.cramon.vaadintest.ui.UiBuilder$_setupRootLayout_closure1.doCall(UiBuilder.groovy:56)\n\tsun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tsun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n\tsun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n\tjava.lang.reflect.Method.invoke(Method.java:597)\n\torg.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:88)\n\tgroovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:233)\n\torg.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:272)\n\tgroovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:886)\n\tgroovy.lang.Closure.call(Closure.java:276)\n\tgroovy.lang.Closure.call(Closure.java:289)\n\torg.codehaus.groovy.runtime.DefaultGroovyMethods.each(DefaultGroovyMethods.java:1167)\n\torg.codehaus.groovy.runtime.DefaultGroovyMethods.each(DefaultGroovyMethods.java:1143)\n\torg.codehaus.groovy.runtime.dgm$108.invoke(Unknown Source)\n\torg.codehaus.groovy.runtime.callsite.PojoMetaMethodSite$PojoMetaMethodSiteNoUnwrapNoCoerce.invoke(PojoMetaMethodSite.java:270)\n\torg.codehaus.groovy.runtime.callsite.PojoMetaMethodSite.call(PojoMetaMethodSite.java:52)\n\torg.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:40)\n\torg.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:117)\n\torg.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:125)\n\tdk.cramon.vaadintest.ui.UiBuilder.setupRootLayout(UiBuilder.groovy:49)\n\tdk.cramon.vaadintest.ui.UiBuilder.this$2$setupRootLayout(UiBuilder.groovy)\n\tdk.cramon.vaadintest.ui.UiBuilder$this$2$setupRootLayout.callCurrent(Unknown Source)\n\torg.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCallCurrent(CallSiteArray.java:44)\n\torg.codehaus.groovy.runtime.callsite.AbstractCallSite.callCurrent(AbstractCallSite.java:143)\n\torg.codehaus.groovy.runtime.callsite.AbstractCallSite.callCurrent(AbstractCallSite.java:151)\n\tdk.cramon.vaadintest.ui.UiBuilder.setupWindow(UiBuilder.groovy:38)\n\tdk.cramon.vaadintest.ui.UiBuilder$setupWindow.call(Unknown Source)\n\torg.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:40)\n\torg.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:117)\n\torg.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:125)\n\tdk.cramon.vaadintest.ui.vaadintest.init(DynApp.groovy:11)\n\tcom.vaadin.Application.start(Application.java:545)\n\tcom.vaadin.terminal.gwt.server.AbstractApplicationServlet.startApplication(AbstractApplicationServlet.java:1032)\n\tcom.vaadin.terminal.gwt.server.AbstractApplicationServlet.service(AbstractApplicationServlet.java:423)\n\tjavax.servlet.http.HttpServlet.service(HttpServlet.java:717)\n\tat groovy.lang.MetaClassImpl.setProperty(MetaClassImpl.java:2402)\n\tat groovy.lang.MetaClassImpl.setProperty(MetaClassImpl.java:3299)\n\tat org.codehaus.groovy.runtime.InvokerHelper.setProperty(InvokerHelper.java:183)\n\tat org.codehaus.groovy.runtime.ScriptBytecodeAdapter.setProperty(ScriptBytecodeAdapter.java:483)\n\tat Script1.run(Script1.groovy:1)\n\tat groovy.lang.GroovyShell.evaluate(GroovyShell.java:527)\n\tat groovy.lang.GroovyShell.evaluate(GroovyShell.java:565)\n\tat groovy.lang.GroovyShell.evaluate(GroovyShell.java:536)\n\tat com.vaadin.ui.EventSetDescriptorTest.groovyClosureTest(EventSetDescriptorTest.java:155)\n\tat com.vaadin.ui.EventSetDescriptorTest.assertValidEventSetDescriptors(EventSetDescriptorTest.java:113)\n\tat com.vaadin.ui.EventSetDescriptorTest.assertValidEventSetDescriptors(EventSetDescriptorTest.java:86)\n\tat com.vaadin.ui.EventSetDescriptorTest.testEventSetDescriptors(EventSetDescriptorTest.java:39)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n\tat java.lang.reflect.Method.invoke(Method.java:597)\n\tat org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:44)\n\tat org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:15)\n\tat org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:41)\n\tat org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:20)\n\tat org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:28)\n\tat org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:76)\n\tat org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:50)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:193)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:52)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:191)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:42)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:184)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:236)\n\tat org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:46)\n\tat org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:467)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:683)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:390)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:197)\n{code}\n"
    ],
    [
        "GROOVY-3546",
        "GROOVY-2085",
        "variable 'this'  in GString with 'if' not resolved correctly when used in @Category method  The following code does not behave correctly :\n\n/////////////////////////////////////////////////////////////////////\n@Category(Tet)\nclass TestCategory {\n\tString getSuperName() {\n\"\"\"\\\nsuper ${if(true) this.getName()}\n\"\"\"\n\t}\n}\n\ninterface Tet {\n\tString getName()\n}\n\nclass MyTest implements Tet {\n\tString getName() {return \"hello\"}\n}\n\ndef onetest = new MyTest()\n\nassert onetest.getName() == 'hello'\n\nuse(TestCategory) {\n\tassert onetest.getSuperName() == 'super hello'\n}\n\n/////////////////////////////////////////////////////////////////////\n\nThe result is 'super TestCategory' and should be 'super hello'\nIn this case, 'this' inside the 'if' resolve to the owner of the closure.",
        "SwingBuilder muddles up column values in tableModel() When I create a tableModel using propertyColumn() or closureColumn() the data is not taken from the correct part of the model. Instead, when starting, only the first model column is accessed for all view columns. When I change the order manually (i.e. by moving the column with the mouse) all shown data is switched to the model data associated with the now first column.\n\nThe test script shows the problem.\n\nIt worked in 1.0."
    ],
    [
        "GROOVY-3476",
        "GROOVY-6891",
        "groovy -l constantly loads classes and leaks memory The classes loaded by a -l script keep increasing until the JVM runs out of memory.  I saw this with a script file, but it also can be demonstrated with two command lines:\n\n{code}\nJAVA_OPTS=\"-Xmx5m\" groovy -l 5000 -e \"System.err.println java.lang.management.ManagementFactory.classLoadingMXBean.loadedClassCount\" &\n\ngroovy -e \"while (true) { new Socket('localhost',5000).outputStream << '\\n'}\"\n{code}\n\nAs a work-around, I used a ServerSocket instead of groovy -l.",
        "Inconsistent setter selection dynamic and static Groovy Tested in JDK 7, GroovyConsole 2.3.3:\n\n{code}\nclass X {\n  void setValue(String v) { println \"String $v\" }\n  void setValue(float f) { println \"float $f\" }\n}\n\nnew X().value = 12.3f //Outputs \"float 12.3\"\n//new X().value = \"123\" //would fail with Cannot cast object '123' with class 'java.lang.String' to class 'float'\n\n@groovy.transform.CompileStatic\nvoid doIt() {\nnew X().value = 12.3f //Outputs \"String 12.3\"\nnew X().value = \"123\" //Outputs \"String 123\"\n}\n\ndoIt()\n{code}\n\nIn real code, some developers report code always working/compiling, others report that it fails 25% of the time.\n\nI expected dynamic Groovy to select method at runtime based on type, and static Groovy to select method at compile time based on inferred type.\n\nI think this is a bug in Groovy, if for no other reason than dynamic Groovy ought to issue an ambiguous call and static Groovy should at a minimum issue compile error, if Groovy doesn't support multiple setX methods when using property notation. Or maybe at least Groovy should be consistently selecting a set method. Based on the other developer's experience, it seems that the setter selection could differ on each execution. In any case I'sd expect a compile/runtime error or consistent behavior."
    ],
    [
        "GROOVY-5415",
        "GROOVY-4502",
        "Static Type checker reporting invalid error {code:title=ClassA.java}\n\npublic class ClassA<T> {\n    <X> Class<X> foo(Class<X> classType){\n        return classType;\n    }\n}\n{code}\n\n{code:title=ClassB.groovy}\n\nimport groovy.transform.CompileStatic\n\n@CompileStatic\nclass ClassB {\n    void bar() {\n        def ClassA<Long> a = new ClassA<Long>();\n        a.foo(this.getClass());\n    }\n}\n{code}\n\n  ClassB.groovy: 13: [Static type checking] - Cannot find matching method ClassA#foo(java.lang.Class <java.lang.Object extends java.lang.Object>)\n @ line 13, column 9.\n             a.foo(this.getClass());\n             ^\n\n\n\n\n\n\n\n\n\n\n",
        "Move Closure Class generation logic into a much earlier phase ClosureExpression should get a new field storing the class that will be used for this expression, and also provide a static method for the class name generation. the field should be set in APP already and the ClassNode added as primary ClassNode to the compile unit. Possible problem here, VariableScopeVisitor and maybe the StaticImoprtVisitor should skip the class and instead still work on the expression contents. Here is potential for breaking existing user code. The static method can be used by people adding closures themselfes and wanting to keep the naming scheme. Since that usually works using an count, a possible other place is in ClassNode as instance method"
    ],
    [
        "GROOVY-6976",
        "GROOVY-7238",
        "after upgrading to 2.3.5 CliBuilder doesn't work. After upgrading to 2.3.5 code depending on CliBuilder doesn't compile. It fails with \"unable to resolve class CliBuilder\".\n\nAm attaching an example gradle project. To reproduce error, just bump groovy version in the build.gradle. The same code works just fine for 2.3.4.",
        "invalid BigDecimal to Double conversion The expression \"0.1d==0.1\" as well as the other around returns true, but should be false. This returning true means the BigDecimal is converted to a double, since 0.1d is never exactly 0.1G."
    ],
    [
        "GROOVY-944",
        "GROOVY-7637",
        "NullPointerException casting an integer The cast \n(int)1\nresults in a null pointer exception when the result is used.\nHowever (int)1 == null is false.\nLook at the shell output below.\n\n$ groovysh\nLets get Groovy!\n================\nVersion: 1.0-jsr-02 JVM: 1.5.0_03-b07\nType 'exit' to terminate the shell\nType 'help' for command help\nType 'go' to execute the statements\n\ngroovy> println 1/2\ngroovy> go\n0.5\n\ngroovy> println ((int)1)/2\ngroovy> go\n1\nCaught: java.lang.NullPointerException: Cannot invoke method div() on null object\n        at CommandLine.run(Unknown Source)\n\ngroovy> println (int)1\ngroovy> go\nint\nCaught: java.lang.NullPointerException: Cannot invoke method call() on null object\n        at CommandLine.run(Unknown Source)\n\ngroovy> println null == ((int)1)\ngroovy> go\nfalse\n\n",
        "DefaultTypeTransformation.compareTo not symmetrical DefaultTypeTransformation.compareTo(Object left, Object right) is being used in plenty of places in Groovy.\r\n\r\nHowever, for several corner cases, it does not provide symmetry, that is: when compareTo(a, b) returns a value (does not fail), then:\r\n\r\nsignum(compareTo(a, b)) == - signum(compareTo(b, a))\r\n\r\nTo reproduce:\r\n{code}\r\n  static class MyNumber extends Number {\r\n        def n\r\n\r\n        MyNumber(n) {\r\n            this.n = n\r\n        }\r\n\r\n        int intValue(){n}\r\n        long longValue(){n}\r\n        float floatValue(){n}\r\n        double doubleValue(){n}\r\n        int hashCode(){-n}\r\n        boolean equals(other) {\r\n            if (other instanceof MyNumber) { return n==other.n}\r\n            return false\r\n        }\r\n        String toString() {n.toString()}\r\n    }\r\n\r\n    static class MyNumberCompareTo extends MyNumber {\r\n\r\n        MyNumberCompareTo(Object n) {\r\n            super(n)\r\n        }\r\n\r\n        int compareTo(MyNumber other) {\r\n            return n <=> other.n\r\n        }\r\n    }\r\n\r\n    static class MyNumberComparable extends MyNumberCompareTo implements Comparable<MyNumber> {\r\n        MyNumberComparable(Object n) {\r\n            super(n)\r\n        }\r\n\r\n        int compareTo(Object other) {\r\n            return n <=>  (MyNumber) other;\r\n        }\r\n    }\r\n\r\n    void testCompareTo() {\r\n        def object1 = new Object()\r\n        def object2 = new Object()\r\n        // objects\r\n        assert compareTo(null, null) == 0\r\n        assert compareTo(object1, null) == 1\r\n        assert compareTo(null, object1) == -1\r\n        assert compareTo(1, 1) == 0\r\n\r\n        shouldFail(GroovyRuntimeException) {\r\n            compareTo(object1, object2)\r\n        }\r\n\r\n        // chars, int values 49 and 50\r\n        Character char1 = '1' as Character\r\n        Character char2 = '2' as Character\r\n        checkCompareToSymmetricSmallerThan(char1, char2)\r\n\r\n        MyNumber number1 = new MyNumber(49)\r\n        MyNumber number2 = new MyNumber(50)\r\n\r\n        MyNumberCompareTo numCompTo1 = new MyNumberCompareTo(49)\r\n        MyNumberCompareTo numCompTo2 = new MyNumberCompareTo(50)\r\n\r\n        MyNumberComparable numComp1 = new MyNumberComparable(49)\r\n        MyNumberComparable numComp2 = new MyNumberComparable(50)\r\n\r\n        List lowers = [49, 49L, 49.0, 49.0G, 49.00G, char1, '1', number1, numCompTo1, numComp1]\r\n        List highers = [50, 50L, 50.0, 50.0G, 50.00G, char2, '2', number2, numCompTo2, numComp2]\r\n\r\n        lowers.each { def lower ->\r\n            assert compareTo(lower, lower) == 0\r\n            highers.each { def higher ->\r\n                checkCompareToSymmetricSmallerThan(lower, higher)\r\n            }\r\n        }\r\n\r\n        // glitch, failing with ClassCastException\r\n        shouldFail(GroovyRuntimeException) {\r\n            compareTo(1, \"22\")\r\n        }\r\n        shouldFail(GroovyRuntimeException) {\r\n            compareTo(\"22\", 1)\r\n        }\r\n\r\n        // strings and chars\r\n\r\n\r\n        assert compareTo('aa1', '2' as Character) > 0\r\n        // bug, classCast exception\r\n        assert compareTo('2' as Character, 'aa1') < 0\r\n\r\n        assert compareTo(\"aa${1}\", '2' as Character) > 0\r\n        // bug, classCast exception\r\n        assert compareTo('2' as Character, \"aa${1}\") < 0\r\n\r\n        // Strings and GStrings\r\n        List lowers2 = ['aa1', \"aa${1}\"]\r\n        List highers2 = ['bb2', \"b${2}\"]\r\n        lowers2.each { def lower ->\r\n            assert compareTo(lower, lower) == 0\r\n            highers2.each { def higher ->\r\n                checkCompareToSymmetricSmallerThan(lower, higher)\r\n            }\r\n        }\r\n    }\r\n\r\n    static void checkCompareToSymmetricSmallerThan(a, b) {\r\n        try {\r\n            assert compareTo(a, b) < 0\r\n            assert compareTo(b, a) > 0\r\n        } catch (AssertionError e) {\r\n            System.err.print(a.class.toString() + ' compared to ' + b.class.toString() )\r\n            throw e\r\n        }\r\n    }\r\n{code}"
    ],
    [
        "GROOVY-2018",
        "GROOVY-1976",
        "Need way to make a PropertyColumn non-editable There is no elegant way to make a non-editale table with the built in PropertyColum in SwingBuilder.  i.e.\n\ndef swing = new SwingBuilder()\ndef changes = []\ndef changeTable = swing.table() {\n       tableModel(id: 'tableModel', list: changes) {\n               propertyColumn(header: 'Filename', propertyName: 'name')\n       }\n}\n\nwill allow for changes to the objects in the backing data by the user.  The ways to turn that off aren't very groovy.\n\nI'm adding a new editable property in propertyColumn to turn it off.",
        "\"Run As | JUnit Test\" of a .groovy file does not work in the 1.0.1.20070706 release of the groovy eclipse-plugin. The \"Run As | JUnit Test\" (Alt-Shift X, Z) of a .groovy file does not work in the 1.0.1.20070706 release of the groovy eclipse-plugin.  This is a regression from the 1.0 release of the plugin.  \"Run As | Groovy\" (Alt-Shift X, G) of a .groovy file does work.\n\nAn error dialog appears with the message:\n     Unable to use launch shortcut\n\n     Reason:\n     Plug-in org.codehaus.groovy.eclipse.ui was unable to load class org.codehaus.groovy.eclipse.launchers.GroovyTestLaunchShortcut.\n\n     Details:\n     org/eclipse/jdt/internal/junit/launcher/JUnitLaunchShortcut\n"
    ],
    [
        "GROOVY-6722",
        "GROOVY-1451",
        "Compiler doesn't recognize covariant array of generics The following code fails to compile:\n\n{code}\nabstract class Top<Elem,Result> {\n    abstract Result exec(Elem... elems)\n}\n\nclass Bottom extends Top<Integer, String> {\n    @Override\n    String exec(Integer... elems) {\n        \"$elems\"\n    }\n}\n{code}\n\nUnder 2.3.0-rc-1, it produces:\n\n{noformat}\n2 compilation errors:\n\nCan't have an abstract method in a non-abstract class. The class 'Bottom' must be declared abstract or the method 'java.lang.Object exec(java.lang.Object[])' must be implemented.\n at line: 5, column: 1\n\nMethod 'exec' from class 'Bottom' does not override method from its superclass or interfaces but is annotated with @Override.\n at line: 6, column: 5\n{noformat}\n\nUnder 2.2.2:\n\n{noformat}\n1 compilation error:\n\nCan't have an abstract method in a non-abstract class. The class 'Bottom' must be declared abstract or the method 'java.lang.Object exec(java.lang.Object[])' must be implemented.\n at line: 5, column: 1\n{noformat}",
        "Right click to Add Groovy Nature to a Java project from Package Explorer fails The Add Groovy Nature menu action fails when selected from the Package Explorer.  This is because in the Package Explorer the item selected is an instance of IJavaProject, which does not extend IProject ( why oh why did the Eclipse ppl do that?).  So I am repairing the AddGroovyNatureAction to deal with this possiblity. "
    ],
    [
        "GROOVY-5149",
        "GROOVY-2154",
        "Groovy should default to LinkedHashSet when using 'as Set' to make default sets deterministic When creating sets using e.g. {{[] as Set}} Groovy should default to a {{LinkedHashSet}}. Users can still do 'as HashSet' to obtain the slightly more efficient but less deterministic {{HashSet}}.",
        "properties of Node obscure xml elements with GPath after using XmlParser def xml=\"\"\"\n<doc>\n    <name>My Doc Name</name>\n    <description>this is my doc</description>\n</doc>\n\"\"\"\n\ndef p = new XmlParser()\ndef doc = p.parseText(xml)\n\ndef desc = doc.description[0].text()\ndef name = doc.name[0].text() //exception\n\ngroovy.lang.MissingMethodException: No signature of method: java.lang.String.text() is applicable for argument types: () values: {}\n\nObviously the groovy.util.Node class' 'name' property is obscuring the element.\n\nI had to resort to this to get the value for the name element:\n\ndef names = doc.directChildren.grep { node-> node.name==\"name\" }\ndef name=nms[0].text()\n\nIt seems like this conflict would happen for any elements with the same name as properties of the Node class. \n"
    ],
    [
        "GROOVY-5678",
        "GROOVY-93",
        "(primopts) increment on array not done as primopt be x a primtive array and i an int, then x[i]++ should be completely done in primopts, if in a primopts block. This is not the case, only the final set is done like that. The initial get and the increment are still dynamic method calls. ",
        "Class type not honored In the following code\n\nByte b = 3\nprintln(b.class)\n\nb is an instanceof java.lang.Integer instead of java.lang.Byte\n\nThe type defined is not honored.\nCurrently the workaround is to define b as follows\n\nByte b = new Byte(\"3\") // constructor with a String"
    ],
    [
        "GROOVY-3798",
        "GROOVY-2623",
        "Incorrect generated bytecode (duplicate field and method) on service with multiple methods returning array of same type Grails 1.1.1, Groovy 1.6.3\n\nTo reproduce:\n\n1. Create a new empty project \n2.  Create the following class in src/java:\n\npackage a;\npublic class A {\n\n}\n\n3.  Create the following service in grails-app/services:\n\npackage b;\nimport a.A;\npublic class BService {\n   public A[] m1() {\n      return null;\n   }\n\n  public A[] m2() {\n       return null;\n   }\n}\n\n4.  Run grails run-app\nThe following exception will be thrown on startup:\njava.lang.ClassFormatError: Duplicate field name&signature in class file b/BService\n        at java.lang.ClassLoader.defineClass1(Native Method)                       \n        at java.lang.ClassLoader.defineClass(ClassLoader.java:621)                 \n        at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:124) \n        at java.net.URLClassLoader.defineClass(URLClassLoader.java:260)            \n        at java.net.URLClassLoader.access$000(URLClassLoader.java:56)              \n        at java.net.URLClassLoader$1.run(URLClassLoader.java:195)                  \n        at java.security.AccessController.doPrivileged(Native Method)              \n        at java.net.URLClassLoader.findClass(URLClassLoader.java:188)              \n        at java.lang.ClassLoader.loadClass(ClassLoader.java:307)                   \n        at java.lang.ClassLoader.loadClass(ClassLoader.java:300)                   \n        at java.lang.ClassLoader.loadClass(ClassLoader.java:252)                   \n        at java.security.AccessController.doPrivileged(Native Method)              \n        at grails.web.container.EmbeddableServer$start.call(Unknown Source)        \n        at _GrailsRun_groovy$_run_closure5_closure11.doCall(_GrailsRun_groovy:145) \n        at _GrailsRun_groovy$_run_closure5_closure11.doCall(_GrailsRun_groovy)     \n        at _GrailsSettings_groovy$_run_closure10.doCall(_GrailsSettings_groovy:274)\n        at _GrailsSettings_groovy$_run_closure10.call(_GrailsSettings_groovy)      \n        at _GrailsRun_groovy$_run_closure5.doCall(_GrailsRun_groovy:137)           \n        at _GrailsRun_groovy$_run_closure5.call(_GrailsRun_groovy)                 \n        at _GrailsRun_groovy.runInline(_GrailsRun_groovy:104)                      \n        at _GrailsRun_groovy.this$4$runInline(_GrailsRun_groovy)                   \n        at _GrailsRun_groovy$_run_closure1.doCall(_GrailsRun_groovy:58)            \n        at RunApp$_run_closure1.doCall(RunApp:33)                                  \n        at gant.Gant$_dispatch_closure4.doCall(Gant.groovy:324)                    \n        at gant.Gant$_dispatch_closure6.doCall(Gant.groovy:334)                    \n        at gant.Gant$_dispatch_closure6.doCall(Gant.groovy)                 \n        at gant.Gant.withBuildListeners(Gant.groovy:344)                    \n        at gant.Gant.this$2$withBuildListeners(Gant.groovy)                 \n        at gant.Gant$this$2$withBuildListeners.callCurrent(Unknown Source)  \n        at gant.Gant.dispatch(Gant.groovy:334)                              \n        at gant.Gant.this$2$dispatch(Gant.groovy)                           \n        at gant.Gant.invokeMethod(Gant.groovy)                              \n        at gant.Gant.processTargets(Gant.groovy:495)                        \n        at gant.Gant.processTargets(Gant.groovy:480)                        \n\nWhen inspecting the bytecode of B/BService.class with javap -private, you'll notice the following lines:\n    private static java.lang.Class array$$class$a$A;    \n    private static java.lang.Class array$$class$a$A;    \n...\n    private static java.lang.Class $get$array$$class$a$A();\n    private static java.lang.Class $get$array$$class$a$A();\n\nNote, when BService is manually compiled with groovyc, the generated bytecode is okay (only one field and method entry). ",
        "Range selection The folowing exclusive range is possible:\n\ndef letters = 'a'..<'d'\nprintln(letters)\n\nbut cannot be exclusive for mininum range, like this:\n\ndef letters = 'a'<..'d'\nprintln(letters)\n\nor\n\ndef letters = 'a'<..<'d'\nprintln(letters)\n\nThe following error is generated:\n\nException thrown: org.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed, Script171: 9: unexpected token: < @ line 9, column 18.\n"
    ],
    [
        "GROOVY-2560",
        "GROOVY-6326",
        "sum, min and friends should work on the same types that collect, each and their friends work on. [1,2,3].sum() works nicely.\n\nBut [1,2,3].iterator().sum() fails.\n\nIn contrast, this code\n\n[1,2,3].iterator().each {\n  println it\n}\n\nworks just fine.\n\nOn aesthetic grounds, there shouldn't be any difference in what works and what doesn't.  More importantly, there are situations where an iterator is available (due to pre-existing API's) but a collection is not.\n\n",
        "Nonsensical error message when trying to call instance method from closure enclosed in static method {code}\nimport groovy.transform.CompileStatic\n\n@CompileStatic\nclass MyCar {}\n\n@CompileStatic\nclass MyCarMain {\n    static void main(String[] args) {\n        def main = new MyCarMain()\n        main.configureCar {\n            doit()\n        }\n    }\n\n    MyCar configureCar(@DelegatesTo(MyCar) Closure closure) {\n        def car = new MyCar()\n        closure.delegate = car\n        closure.resolveStrategy = Closure.DELEGATE_FIRST\n        closure.call()\n        car\n    }\n\n    void doit() {\n        println \"doit\"\n    }\n}\n{code}\n\nHere I inadvertently used {{doit()}} instead of {{main.doit()}}. However the error message didn't help:\n\n{code}\nGroovyc: Access to java.lang.Object#owner is forbidden\n{code}"
    ],
    [
        "GROOVY-1414",
        "GROOVY-3342",
        "RuntimeParserException makes AddErrorMarker#run throw a NPE The given patch fixes the problem. It also includes the patch in\nhttp://jira.codehaus.org/browse/GROOVY-1405\nwhich has not yet been applied.\n\nA Groovy class can cause a NullPointerException in Eclipse, but the reason disappears into the void.\n\nAddErrorMarker#run expects a SyntaxException, however sometimes a RuntimeParserException is collected in the MultipleCompilerErrorsException.\n\nThe result is a NullPointerException and a message in the Eclipse error view. The message does not give any indication as to what went wrong. For example:\nclass Thing {\n  void doit() { return true }\n}\ngroovyConsole says: Cannot use return statement with an expression on a method that returns void\nIn Eclipse a NullPointerException is logged but it contains nothing to discover the real error.",
        "Optimization done by groovy compiler by caching number constants does not cover closure classes From version 1.6.x onwards, groovy compiler caches the number constants to optimize the runtime performance. Currently it is done only for top-level classes and not for classes that get generated for closures.\n\nSo, If I say\n{code}\ndef cl = {\n               1000.times{\n                       def i = 10\n                       println i\n               }\n}\ncl()\n{code}\n\nConstants 10 and 1000 are not cached and Integer object for value 10 gets created 1000 times. Optimization done for top-level classes is needed even for inner classes that get generated for closures."
    ],
    [
        "GROOVY-4806",
        "GROOVY-3818",
        "Sql.eachRow documentation: actual GroovyResultSet vs. documentation GroovyRowResult Sql.eachRow actually passes objects of type \"GroovyResultSet\" to the closure. Documentation says \"The row will be a GroovyRowResult\" (wrong).\n\nThe documentation example(s) are actually correct. They use \"row.toRowResult()\" to get to the desired \"GroovyRowResult\"\n\nhttp://groovy.codehaus.org/api/groovy/sql/Sql.html#eachRow(java.lang.String, groovy.lang.Closure, groovy.lang.Closure)\n\nIn all, six occurences of eachRow() variants show that \"The row will be a GroovyRowResult\" line.",
        "grep or findAll results in ClassCastException (Comparaple) on TreeSet, TreeMap with custom comparator Given:\n- a TreeSet or TreeMap with a custom comparator\n- elements in the set/map that do *not* implement Comparable (for example, map literals, which are LinkedHashMap instances)\n\nCalling coll.grep or coll.findAll can raise ClassCastException (really, raised from TreeSet.add).\nNote that the exception only arises if grep/findAll matches two or more entries.\n\nI have attached a sample script that meets these criteria and demonstrates the issue.\n\n$ groovy -v\nGroovy Version: 1.6.4 JVM: 1.6.0_16\n\n$ java -version\njava version \"1.6.0_16\"\nJava(TM) SE Runtime Environment (build 1.6.0_16-b01)\nJava HotSpot(TM) 64-Bit Server VM (build 14.2-b01, mixed mode)\n\n$ groovy test.groovy\nCaught: java.lang.ClassCastException: java.util.LinkedHashMap cannot be cast to java.lang.Comparable\n\tat test.run(test.groovy:9)\n\nAnalysis:\nGrep lives at:\nhttp://svn.codehaus.org/groovy/branches/GROOVY_1_6_X/src/main/org/codehaus/groovy/runtime/DefaultGroovyMethods.java\nWhich calls createSimilarOrDefaultCollection in:\nhttp://svn.codehaus.org/groovy/branches/GROOVY_1_6_X/src/main/org/codehaus/groovy/runtime/DefaultGroovyMethodsSupport.java\nWhich calls createSimilarCollection and then createSimilarSet in the same file.\n\nThe createSimilarSet method does not copy over the comparator from the original SortedSet. Further, createSimilarMap suffers the same limitation.\n\nWorkaround:\nThe issue can be avoided by converting the original collection to a list using toList() before grepping."
    ],
    [
        "GROOVY-5603",
        "GROOVY-1075",
        "Remove call site array creation and other generated methods when static compilation is used GROOVY-5564 was fixed by letting the compiler continue to generate the callsite array creation methods, and we also have some generated methods that might be of no use in the case of static compilation. At some point, it'd be good to cleanly remove such bytecode that's not used when static compilation is used.",
        "splitEachLine() wraps the result of the split in a (useless) single element list splitEachLine() wraps the result of the split in a (useless) single element list. Instead it should work like this:\n\n    void testSplitEachLine() {\n        String s = \"\"\"A B C D\nE F G H\n\"\"\"\n        Reader reader = new StringReader(s)\n        reader.splitEachLine(\" \") { list ->\n            println list\n        }\n    }\n\n"
    ],
    [
        "GROOVY-6268",
        "GROOVY-6980",
        "New documentation We are completely overhauling the documentation of the Groovy project.\nWe'll be using Asciidoc for our markup format, and include tests so that the documentation is always in sync, as much as possible, with the reference implementation.\nThe documentation will be displayed online in the future reworked Groovy website, as well as bundled in the Groovy documentation bundle artifact.",
        "Normal Groovy jar shouldn't include openbeans The normal Groovy jar includes openbeans, whether it should only be packaged with the {{grooid}} version.\n"
    ],
    [
        "GROOVY-5447",
        "GROOVY-4250",
        "Dead links for 2.0.0-beta-3 release The following URLs are dead :\nhttp://dist.groovy.codehaus.org/distributions/groovy-src-2.0.0-beta-3.zip\nhttp://dist.groovy.codehaus.org/distributions/groovy-docs-2.0.0-beta-3.zip\n\nConsequently, one has to check out the repo to get them.",
        "Power assert doesn't pretty-print empty String expected:\n{code}\n$ groovy -e 'assert new String() == \"xxx\";'\nCaught: Assertion failed: \n\nassert new String() == \"xxx\"\n       |            |\n       |            false\n       \"\"\n{code}\n\nbut actual:\n{code}\n$ groovy -e 'assert new String() == \"xxx\";'\nCaught: Assertion failed: \n\nassert new String() == \"xxx\"\n       |            |\n       |            false\n       java.lang.String@45c3987\n{code}"
    ],
    [
        "GROOVY-6255",
        "GROOVY-4736",
        "XMLSlurper accessing xml:id I believe I have found a regression introduced by GROOVY-4637 The issue is most easily demonstrated through the following tests:\n\n{code}\nimport spock.lang.*\n\nclass XmlSlurperPasivityTest extends Specification {\n  def theInputData = '''<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n            <appendix version=\"5.0\" xmlns=\"http://docbook.org/ns/docbook\" xmlns:xml=\"http://www.w3.org/XML/1998/namespace\"> \n              <section xml:id=\"a\"/> \n            </appendix>'''\n\n  def theXml = new XmlSlurper().parseText(theInputData)\n      .declareNamespace(xml:'http://www.w3.org/XML/1998/namespace', docbook: 'http://docbook.org/ns/docbook')\n\n  def 'attributes().get(\"id\")'() {\n    when:\n      def id = theXml.section[0].attributes().get('id')\n    then: 'failure with >= groovy 1.6 and success with < groovy 1.6'\n      id == 'a'\n  }\n\n  def '.@id'() {\n    when:\n      def id = theXml.section[0].@'id'\n    then: 'failure with >= groovy 1.6 and success with < groovy 1.6'\n      id == 'a'\n  }\n\n  def '.@\"xml:id\"'() {\n    when:\n      def id = theXml.section[0].@'xml:id'\n    then: 'failure with >= groovy 1.6 and success with < groovy 1.6'\n      id == 'a'\n  }\n  \n  def 'attributes().get()'() {\n    when:\n      def id = theXml.section[0].attributes().get('{http://www.w3.org/XML/1998/namespace}id')\n    then: 'success with >= groovy-1.6'\n      id == 'a'\n  }\n\n  def 'attributes().get(\"xml:id\")'() {\n    when:\n      def id = theXml.section[0].attributes().get('xml:id')\n    then: 'failure with all'\n      id == 'a'\n  }\n}\n{code}",
        "Deadlock when GroovyClassLoader is used in multi-threaded environment When multiple threads uses GroovyClassLoader to get Groovy classes or just work with them (instantiation, etc.) and an other(s) threads change the sources (followed by clearCache call), then deadlock can happen related to synchronizations on InnerLoader and HashMap (GroovyClassLoader.sourceCache)\n\nI attached simple test scenation when 3 threads load Groovy classes and instantiate them and 3 other threads replace sources and call GroocyClassLoader.clearCache(). There is a synchronization on writeToFile to be ensure that the same file is not being written at the same time but this synchronization does not take part in a deadlock.\n\nPlease just run the test and wait a moment. Deadlock happens usually in 1 second at this test scenario. I hope this test will be also useful in Your future development as a standard test case."
    ],
    [
        "GROOVY-330",
        "GROOVY-7334",
        "broken classpath in builder while using jars from workspace It seems that groovy builder uses wrong classpath since it cant' find any jars that are in the workspace.\nIt works fine if you use envirovment variables instead.\n\nI checked the code and here is the place in GroovyProject.java that I think needs fix...\n\n\tprivate void setClassPath(IJavaProject javaProject) throws JavaModelException, Exception {\n\t\tIWorkspaceRoot root = javaProject.getProject().getWorkspace().getRoot();\n\t\tIClasspathEntry[] cpEntries = javaProject.getResolvedClasspath(false);\n\t\tStringBuffer classPath = new StringBuffer();\n\t\tfor (int i = 0; i < cpEntries.length; i++) {\n\t\t    IClasspathEntry entry = cpEntries[i];\n\t\t\tif (entry.getEntryKind() == IClasspathEntry.CPE_LIBRARY) {\n\t\t\t    if(entry.getPath().getDevice()==null) {\n\t\t\t        IResource resource = root.findMember(entry.getPath());\n\t\t\t        if(resource != null)\n\t\t\t            classPath.append(resource.getLocation().toString() + \";\");\n\t\t\t    } else {\n\t\t\t        classPath.append(entry.getPath().toString() + \";\");\n\t\t\t    }\n\t\t\t}\n\t\t}\n\n\t\tclassPath.append(getOutputPath(javaProject) + \";\");\n\t\tGroovyPlugin.trace(\"groovy cp = \" + classPath.toString());\n\t\tcompiler.setClasspath(classPath.toString());\n\t}\n\n\nwhat do you think?",
        "update spock to 1.0 "
    ],
    [
        "GROOVY-6279",
        "GROOVY-3008",
        "getCallerClass will be removed from JDK There are three things:\n1. a bug in JDK 7u25, that's http://bugs.sun.com/view_bug.do?bug_id=8016814\n2. the fact that starting from 7u40, getCallerClass(int) throws an exception unless you run with a special JVM flag (that's http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=8014925)\n3. the fact that getCallerClass(int) will be definitely removed in JDK8 and no suitable long term replacement exists (that's http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=8020785)\n\nSo starting from Java 7u40, Grapes will be broken for people not using the new JVM flag (everybody).",
        "Superclass can access field declared in subclass Why does something like that work?\n{code:Java}\nclass Base {\n  String test() {\n     return subClassField   // subClassField is unknown in class Base!!\n  }\n}\n\nclass Sub extends Base {\n  \n  private subClassField = \"foo\"\n  \n  static main(args) {\n     println new Sub().test() // -> \"foo\"\n  }\n}\n{code}"
    ],
    [
        "GROOVY-5914",
        "GROOVY-168",
        "@InheritConstructors fails when super class has raw constructor parameters Inspired by http://youtrack.jetbrains.com/issue/IDEA-98494\n\nCreate a Java class:\n\n{code}\nimport java.util.Map;\n\npublic class Super {\n    public Super(Map m) {\n    }\n}\n{code}\n\nCompile it. After that create a Groovy class:\n\n{code}\nimport groovy.transform.InheritConstructors\n\n@InheritConstructors\nclass SubClass extends Super {\n\n}\n{code}\n\nCompile it so that Super.class is in the classpath. The compilation will fail:\n{noformat}\nA transform used a generics containing ClassNode java.util.Map <K extends java.lang.Object -> java.lang.Object, V extends java.lang.Object -> java.lang.Object> for the constructor public void <init>(java.util.Map param0)  { ... } directly. You are not suppposed to do this. Please create a new ClassNode refering to the old ClassNode and use the new ClassNode instead of the old one. Otherwise the compiler will create wrong descriptors and a potential NullPointerException in TypeResolver in the OpenJDK. If this is not your own doing, please report this bug to the writer of the transform.\n{noformat}\n",
        "for loop variable is not correctly passed into inner closure The following fails, as the variable declared by a for loop isn't passed into a closure\n\n\nlist = ['a']\nfor (x in [0, 1]) { \n    list.each { assert x != null }\n}"
    ],
    [
        "GROOVY-6308",
        "GROOVY-2573",
        "Timestamps in bytecode prevents baselining of code The Groovy compiler generates timestamps in the byte code such as:\n// Field __timeStamp__239_neverHappen1376222554342:J\n\nBecause of this, every build will produce different class files. \n\nWe are moving towards baselining of jars using bnd (https://github.com/bndtools/bnd/wiki/Baselining-%5Bbeta%5D). Baselining helps versioning exported packages and bundles (jar files) correctly using the semantic versioning scheme. When class files change between builds the baseline diff will always notice a change, even when the code was actually not changed.\n\nBesides the baselining issue I think builds should produce the exact same byte code on successive runs when there are no changes.\n\nThis issue is related to GROOVY-4102.",
        "ConfigSlurper does not process property files with nested properties correctly # I created the following Groovy test:\n{code}\nimport java.io.IOException;\n\npublic class PropertyParsingTest extends GroovyTestCase {\n    public void test() throws IOException{\n        ConfigSlurper configSlurper = new ConfigSlurper()\n        Properties props = new Properties()\n        props.load(PropertyParsingTest.class.getResourceAsStream(\"system.properties\"))\n        ConfigObject newConfig = configSlurper.parse(props)\n        props = newConfig.toProperties()\n\n        assertEquals(\"false\", props.get(\"catalog.prov\"))\n        assertEquals(\"sa\", props.get(\"catalog.prov.db.user\"))\n    }\n}\n{code}\n# I created system.properties file and put it to into classpath:\n{code}\ncatalog.prov = false\ncatalog.prov.db.user = sa\n{code}\n\nI got the following exception:\n{code}\nThere was 1 failure:\n1) test(PropertyParsingTest)junit.framework.ComparisonFailure: expected:<sa> but was:<null>\n        at groovy.util.GroovyTestCase.assertEquals(GroovyTestCase.java:393)\n        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n        at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:86)\n        at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:226)\n        at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:899)\n        at org.codehaus.groovy.runtime.ScriptBytecodeAdapter.invokeMethodOnCurrentN(ScriptBytecodeAdapter.java:77)\n        at PropertyParsingTest.test(PropertyParsingTest.groovy:13)\n{code}"
    ],
    [
        "GROOVY-6998",
        "GROOVY-5056",
        "groovysh breaks terminal after exit (no chars rendered anymore) After exiting groovysh, the terminal doesn't work anymore. Typed characters don't show up. Hitting enter does not give new command prompt.\nTyping \"reset\" (without seeing it) fixes problem.\n\nSteps to reproduce\n1) install groovy 2.4.0-beta-2 on ubuntu 14.04, open default terminal\n2) type groovysh\n3) hit Ctrl+D (or Ctrl+C)\n\n",
        "?TreeSet? Comparators not correctly comparing everything - Compares only a subset Hi everyone\n\nThis fails with the latest 1.8.3 snapshot - But works in 1.7.10\n\n{code}\nimport java.util.logging.Logger;\nimport org.junit.*;\n\nclass Breaker {\n   static Logger log = Logger.getLogger(getName())\n   \n   @Test\n   void testBreaking() {\n      def comparator = [compare:\n         {a,b-> \n            def retVal = a.x.compareTo(b.x)\n            log.info(\"Comparing ${a.x} to ${b.x} and returning ${retVal}\")\n            return retVal }\n      ] as Comparator\n   \n      def ts1 = new TreeSet(comparator)\n      ts1.addAll([\n         new ToCompare(x:\"1\"),\n         new ToCompare(x:\"2\"),\n         new ToCompare(x:\"3\")\n      ])\n       \n      def ts2 = new TreeSet(comparator)\n      ts2.addAll([\n         new ToCompare(x:\"1\"),\n         new ToCompare(x:\"2\"),\n         new ToCompare(x:\"3\")\n      ])\n      \n      def difference = ts1 - ts2\n      assert difference.size() == 0\n   }\n}\n\nclass ToCompare {\n   String x\n}\n{code}\n\nThe test works if you pass the same list of the same objects to ts1 and ts2.  Passing in different objects with the same content fails.\n\nFor 1.8.x, the logs spit out:\n{code}\nSep 29, 2011 9:03:57 PM sun.reflect.NativeMethodAccessorImpl invoke0\nINFO: Comparing 2 to 1 and returning 1\nSep 29, 2011 9:03:57 PM sun.reflect.NativeMethodAccessorImpl invoke0\nINFO: Comparing 3 to 1 and returning 2\nSep 29, 2011 9:03:57 PM sun.reflect.NativeMethodAccessorImpl invoke0\nINFO: Comparing 3 to 2 and returning 1\nSep 29, 2011 9:03:57 PM sun.reflect.NativeMethodAccessorImpl invoke0\nINFO: Comparing 2 to 1 and returning 1\nSep 29, 2011 9:03:57 PM sun.reflect.NativeMethodAccessorImpl invoke0\nINFO: Comparing 3 to 1 and returning 2\nSep 29, 2011 9:03:57 PM sun.reflect.NativeMethodAccessorImpl invoke0\nINFO: Comparing 3 to 2 and returning 1\n{code}\n\nFor 1.7.10, the logs spit out:\n{code}\n\nSep 29, 2011 9:07:09 PM sun.reflect.NativeMethodAccessorImpl invoke0\nINFO: Comparing 2 to 1 and returning 1\nSep 29, 2011 9:07:09 PM sun.reflect.NativeMethodAccessorImpl invoke0\nINFO: Comparing 3 to 1 and returning 2\nSep 29, 2011 9:07:09 PM sun.reflect.NativeMethodAccessorImpl invoke0\nINFO: Comparing 3 to 2 and returning 1\nSep 29, 2011 9:07:09 PM sun.reflect.NativeMethodAccessorImpl invoke0\nINFO: Comparing 2 to 1 and returning 1\nSep 29, 2011 9:07:09 PM sun.reflect.NativeMethodAccessorImpl invoke0\nINFO: Comparing 3 to 1 and returning 2\nSep 29, 2011 9:07:09 PM sun.reflect.NativeMethodAccessorImpl invoke0\nINFO: Comparing 3 to 2 and returning 1\nSep 29, 2011 9:07:09 PM sun.reflect.NativeMethodAccessorImpl invoke0\nINFO: Comparing 1 to 2 and returning -1\nSep 29, 2011 9:07:09 PM sun.reflect.NativeMethodAccessorImpl invoke0\nINFO: Comparing 1 to 1 and returning 0\nSep 29, 2011 9:07:09 PM sun.reflect.NativeMethodAccessorImpl invoke0\nINFO: Comparing 2 to 2 and returning 0\nSep 29, 2011 9:07:09 PM sun.reflect.NativeMethodAccessorImpl invoke0\nINFO: Comparing 3 to 2 and returning 1\nSep 29, 2011 9:07:09 PM sun.reflect.NativeMethodAccessorImpl invoke0\nINFO: Comparing 3 to 3 and returning 0\n{code}\n\nPlease let me know if there's anything else ya'll need!\n\nCheers\nJason Griffith"
    ],
    [
        "GROOVY-5520",
        "GROOVY-2048",
        "Static Type Checker: Cannot check for null against a Java interface  Following code:\n\n{code}\n@GrabResolver('http://repo.grails.org/grails/core')\n@Grab(group='org.grails', module='grails-bootstrap', version='2.0.4')\nimport org.codehaus.groovy.grails.plugins.*\nimport groovy.transform.CompileStatic\n\n@CompileStatic\ndef foo() {\n   GrailsPluginInfo gpi = null\n   \n   if(gpi != null) {\n       println \"good\"\n   }\n}\n{code}\n\nResults in \n\n{code}\n\n[Static type checking] - Cannot find matching method org.codehaus.groovy.grails.plugins.GrailsPluginInfo#equals(<unknown parameter type>)\n at line: 10, column: 7\n{code}",
        "VerifyError  Running the attached test case causes a VerifyError: Inconsistent stack height 1 != 0"
    ],
    [
        "GROOVY-7594",
        "GROOVY-2495",
        "XmlUtil.serialize is not processing whole message Consider following code snippet:\r\n\r\ndef writer = new FileWriter(some_file_path)\r\ndef xmll = new StreamingMarkupBuilder().bind {\r\n     root {\r\n          //datarows = quite large chunk of data that I have, structured in rows\r\n          datarows.each { row ->\r\n               datarow() {\r\n                    //6 fields definitions here\r\n               }\r\n          }\r\n     }\r\nwriter << XmlUtil.serialize(xmll)\r\n\r\nwhen printing xmll (as in: log.info ... ), the message is correct (i.e. I have loooooong xml string with proper data); however, when I check the output file of the writer, it is missing a significant part of data (I have, like, around first 40% of the datarows, or first <8k characters out of 20k total), and it looks as if the buffer ended (but no exception was thrown nor warning) because the last record/line looks like this:\r\n<datarowhere>\r\n  <somefield>SOME_DATA_INSIDE</somef\r\n",
        "MissingMethodExceptions in highly concurrent environments I believe I have uncovered a threading bug with Groovy 1.5.1 which I can reproduce.  This bug is consistently reproducible under 1.5.1, however I cannot get it to happen under 1.0.  I have also tried the 1.6 trunk builds and the bug happens there as well.   \n\nWe recently starting getting groovy.lang.MissingMethodException at various times in our development code.  Our code runs 100's of thousands of groovy expressions in a highly concurrent environment.  It wasn't happening at the exact same point each time, but it started when we updated our development hardware (much faster and more cores than before).  I've managed to reproduce the bug in a simple class (see below), but even in this class the number of failures varies greatly between runs.  For every run, I will get some number of exceptions that look like this:\n\nException in thread \"Thread-27\" groovy.lang.MissingMethodException: No signature of method: Util.between() is applicable for argument types: (null, java.lang.Integer, java.lang.Integer) values: {null, 3, 11}\n        at org.codehaus.groovy.runtime.ScriptBytecodeAdapter.unwrap(ScriptBytecodeAdapter.java:54)\n        at org.codehaus.groovy.runtime.ScriptBytecodeAdapter.invokeMethodN(ScriptBytecodeAdapter.java:169)\n        at Script1.run(Script1.groovy:1)\n        at RunnableTest.run(RunnableTest.java:17)\n        at java.lang.Thread.run(Thread.java:619)\n\nAlthough the types in the parameter list will vary.\n\nI'm pretty sure this indicates a threading issue.  While groovy script is run 5 million times, it only will fail a small handful of times.  One thing that is interesting is that I can consistently get the exceptions when running under Linux (which is our production environment), but I never get them running under Windows.  On both platforms I am using the latest version of Java6.\n\nAny help would be much appreciated.  Thanks again,\n\nChuck\n\n{code:java}import groovy.lang.Binding;\nimport groovy.lang.GroovyShell;\nimport groovy.lang.Script;\n\npublic class BugTest {\n\n    public static void main(String[] args) {\n        for (int i = 0; i < 10; i++) {\n            new Thread(new RunnableTest(\"return util.between(new Short((short)4), new Integer(3), new Integer(11))\")).start();\n            new Thread(new RunnableTest(\"return util.between(new Integer(4), new Integer(3), new Integer(11))\")).start();\n            new Thread(new RunnableTest(\"return util.between(null, new Integer(3), new Integer(11))\")).start();\n            new Thread(new RunnableTest(\"return util.between('1', '3', '11')\")).start();\n        }\n    }\n\n    public static class RunnableTest implements Runnable {\n        private Script _script;\n           \n        public RunnableTest(String expression) {\n            _script = new GroovyShell().parse(expression);\n            Binding b = new Binding();\n            b.setVariable(\"util\", Util.getInstance());\n            _script.setBinding(b);\n        }\n           \n        public void run() {\n            for (int i = 0; i < 500000; i++)\n                _script.run();\n        }\n    }\n\n    public static class Util {\n        private static Util _INSTANCE = new Util();\n         \n        public static Util getInstance() {\n            return _INSTANCE;\n        }\n   \n        public boolean between(Object value, Object low, Object high) {\n            if (value == null || low == null || high == null)\n                return false;\n   \n            if (value instanceof String) {\n                String val = (String)value;\n                return val.compareTo(low.toString()) >= 0 && val.compareTo(high.toString()) <= 0;\n            }\n   \n            if (value instanceof Number && low instanceof Number && high instanceof Number) {\n                double val = ((Number)value).doubleValue();\n                double l = ((Number)low).doubleValue();\n                double h = ((Number)high).doubleValue();\n   \n                return val >= l && val <= h;\n            }\n   \n            return false;\n        }\n    }\n}{code}\n\nHere is the output from the last time I ran it:\n\nException in thread \"Thread-7\" groovy.lang.MissingMethodException: No signature of method: BugTest$Util.between() is applicable for argument types: (null, java.lang.Integer, java.lang.Integer) values: {null, 3, 11}\n        at org.codehaus.groovy.runtime.ScriptBytecodeAdapter.unwrap(ScriptBytecodeAdapter.java:54)\n        at org.codehaus.groovy.runtime.ScriptBytecodeAdapter.invokeMethodN(ScriptBytecodeAdapter.java:169)\n        at Script1.run(Script1.groovy:1)\n        at BugTest$RunnableTest.run(BugTest.java:28)\n        at java.lang.Thread.run(Thread.java:619)\nException in thread \"Thread-11\" groovy.lang.MissingMethodException: No signature of method: BugTest$Util.between() is applicable for argument types: (null, java.lang.Integer, java.lang.Integer) values: {null, 3, 11}\n        at org.codehaus.groovy.runtime.ScriptBytecodeAdapter.unwrap(ScriptBytecodeAdapter.java:54)\n        at org.codehaus.groovy.runtime.ScriptBytecodeAdapter.invokeMethodN(ScriptBytecodeAdapter.java:169)\n        at Script1.run(Script1.groovy:1)\n        at BugTest$RunnableTest.run(BugTest.java:28)\n        at java.lang.Thread.run(Thread.java:619)\nException in thread \"Thread-15\" groovy.lang.MissingMethodException: No signature of method: BugTest$Util.between() is applicable for argument types: (null, java.lang.Integer, java.lang.Integer) values: {null, 3, 11}\n        at org.codehaus.groovy.runtime.ScriptBytecodeAdapter.unwrap(ScriptBytecodeAdapter.java:54)\n        at org.codehaus.groovy.runtime.ScriptBytecodeAdapter.invokeMethodN(ScriptBytecodeAdapter.java:169)\n        at Script1.run(Script1.groovy:1)\n        at BugTest$RunnableTest.run(BugTest.java:28)\n        at java.lang.Thread.run(Thread.java:619)\nException in thread \"Thread-2\" groovy.lang.MissingMethodException: No signature of method: BugTest$Util.between() is applicable for argument types: (java.lang.Integer, java.lang.Integer, java.lang.Integer) values: {4, 3, 11}\n        at org.codehaus.groovy.runtime.ScriptBytecodeAdapter.unwrap(ScriptBytecodeAdapter.java:54)\n        at org.codehaus.groovy.runtime.ScriptBytecodeAdapter.invokeMethodN(ScriptBytecodeAdapter.java:169)\n        at Script1.run(Script1.groovy:1)\n        at BugTest$RunnableTest.run(BugTest.java:28)\n        at java.lang.Thread.run(Thread.java:619)\nException in thread \"Thread-19\" groovy.lang.MissingMethodException: No signature of method: BugTest$Util.between() is applicable for argument types: (null, java.lang.Integer, java.lang.Integer) values: {null, 3, 11}\n        at org.codehaus.groovy.runtime.ScriptBytecodeAdapter.unwrap(ScriptBytecodeAdapter.java:54)\n        at org.codehaus.groovy.runtime.ScriptBytecodeAdapter.invokeMethodN(ScriptBytecodeAdapter.java:169)\n        at Script1.run(Script1.groovy:1)\n        at BugTest$RunnableTest.run(BugTest.java:28)\n        at java.lang.Thread.run(Thread.java:619)\nException in thread \"Thread-18\" groovy.lang.MissingMethodException: No signature of method: BugTest$Util.between() is applicable for argument types: (java.lang.Integer, java.lang.Integer, java.lang.Integer) values: {4, 3, 11}\n        at org.codehaus.groovy.runtime.ScriptBytecodeAdapter.unwrap(ScriptBytecodeAdapter.java:54)\n        at org.codehaus.groovy.runtime.ScriptBytecodeAdapter.invokeMethodN(ScriptBytecodeAdapter.java:169)\n        at Script1.run(Script1.groovy:1)\n        at BugTest$RunnableTest.run(BugTest.java:28)\n        at java.lang.Thread.run(Thread.java:619)\nException in thread \"Thread-1\" groovy.lang.MissingMethodException: No signature of method: BugTest$Util.between() is applicable for argument types: (java.lang.Short, java.lang.Integer, java.lang.Integer) values: {4, 3, 11}\n        at org.codehaus.groovy.runtime.ScriptBytecodeAdapter.unwrap(ScriptBytecodeAdapter.java:54)\n        at org.codehaus.groovy.runtime.ScriptBytecodeAdapter.invokeMethodN(ScriptBytecodeAdapter.java:169)\n        at Script1.run(Script1.groovy:1)\n        at BugTest$RunnableTest.run(BugTest.java:28)\n        at java.lang.Thread.run(Thread.java:619)\nException in thread \"Thread-39\" groovy.lang.MissingMethodException: No signature of method: BugTest$Util.between() is applicable for argument types: (null, java.lang.Integer, java.lang.Integer) values: {null, 3, 11}\n        at org.codehaus.groovy.runtime.ScriptBytecodeAdapter.unwrap(ScriptBytecodeAdapter.java:54)\n        at org.codehaus.groovy.runtime.ScriptBytecodeAdapter.invokeMethodN(ScriptBytecodeAdapter.java:169)\n        at Script1.run(Script1.groovy:1)\n        at BugTest$RunnableTest.run(BugTest.java:28)\n        at java.lang.Thread.run(Thread.java:619) "
    ],
    [
        "GROOVY-1515",
        "GROOVY-3113",
        "Node.breadthFirst() Ordering problem Node.breadthFirst() displays the wrong order after the first two levels.\nPatch and Test attached.\nThe test relies on the XmlTraversalTestUtil.groovy file attached to GROOVY-1514.",
        "Surprising behaviour of evaluate // I think I know why the three different pieces of code work differently, but I'm not sure that they should.\n{code:Java}\nfun1 = { msg -> println msg }\nfun1(\"Calling fun1\")\ntry{\n    // Only this one works\n    evaluate('fun1(\"Calling fun1\")')\n} catch (Exception e) {\n    println e\n}\n\ndef fun2 = { msg -> println msg }\nfun2(\"Calling fun2\")\ntry{\n    // MissingMethodException\n    evaluate('fun2(\"Calling fun2\")')\n} catch (Exception e) {\n    println e\n}\n\ndef fun3 (msg) { println msg }\nfun3(\"Calling fun3\")\ntry{\n    // MissingMethodException\n    evaluate('fun3(\"Calling fun3\")')\n} catch (Exception e) {\n    println e\n}\n{code}\n"
    ],
    [
        "GROOVY-1541",
        "GROOVY-5190",
        "Missing of directory apidocs with API documentation in java format Need an apidocs  documentation. I know that there are xref doc but NetBean5.5 do not understand this directory as api documentation (some files missing)\nIn jsr-05 such directory presents",
        "groovy -version could show more information about the JVM Occasionally, bugs or peculiarities only show themselves on certain JVMs (OpenJDK, etc)\n\nIt's often hard to find out exactly which JVM someone is running on their OS\n\nAdding this information into the {{groovy -version}} string would be really useful\n\nSomething like:\n\n{code}\nGroovy Version: 1.8.4 JVM: 1.6.0_29 Vendor: Apple Inc. OS: Mac OS X\n{code}\n"
    ],
    [
        "GROOVY-2153",
        "GROOVY-4075",
        "BUG! exception in phase 'semantic analysis'  This happens only on Mac OS & Apple Java, not on Win32 (Sun or JRockit), not on Suse Linux (Sun JDK). We use Groovy embedded into a large J2EE-app, so I cannot provide a meaningful test case (loads of dependencies in the script on the environment classes).\n\n\nCaused by: BUG! exception in phase 'semantic analysis' in source unit 'com/pvs/pmm/domainmodel/services/XlsImport.groovy' null\n        at org.codehaus.groovy.control.CompilationUnit.applyToSourceUnits(CompilationUnit.java:789)\n        at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:448)\n        at groovy.lang.GroovyClassLoader.parseClass(GroovyClassLoader.java:290)\n        at groovy.lang.GroovyClassLoader.parseClass(GroovyClassLoader.java:260)\n        at groovy.lang.GroovyClassLoader.parseClass(GroovyClassLoader.java:255)\n        at groovy.util.GroovyScriptEngine.updateCacheEntry(GroovyScriptEngine.java:355)\n        at groovy.util.GroovyScriptEngine.run(GroovyScriptEngine.java:404)\n        at com.pvs.groovy.GroovyEngine.runScript(GroovyEngine.java:61)\n",
        "shouldFailWithCause no longer works for unchecked exceptions So we upgraded from 1.6.3 to Groovy 1.7.0 and realized that one of our tests started failing... it seems that in 1.7.0 unchecked exceptions are simply rethrown (groovy.lang.Closure#throwRuntimeException(Throwable) called from #call(Object[])). Which in groovy.util.GroovyTestCase#shouldFailWithCause(Class,Closure), the exception falls to the catch Throwable branch and the cause is not attempted to be determined beyond that, which causes the test to fail.\n\nExample test showing a successful checked and unsuccessful unchecked exception:\n{code}\npackage dummy;\n\nimport groovy.util.GroovyTestCase;\n\nimport java.io.IOException;\n\nimport org.junit.Test;\n\n/**\n * Demonstrates cases of should fail with cause.\n * @author Charlie Huggard-Lee \n */\nclass DummyTest extends GroovyTestCase {\n    \n    public static void failChecked() throws Exception {\n        throw new Exception(new IOException());\n    }\n    \n    public static void failUnchecked() {\n        throw new RuntimeException(new IOException());\n    }\n    \n    \n    @Test\n    public void testcheckedFailure() {\n        //Hurray!\n        shouldFailWithCause(IOException.class, {DummyTest.failChecked()})    \n    }\n    \n    @Test\n    public void testuncheckedFailure() {\n        //BOO!!!\n        shouldFailWithCause(IOException.class, {DummyTest.failUnchecked()})    \n    }\n    \n}\n{code}"
    ],
    [
        "GROOVY-5666",
        "GROOVY-928",
        "Incorrectly finding \"where\" in query string groovy.sql.Sql.findWhereKeyword returns the index once all the characters in [w,h,e,r,e] are found but not necessarily adjacently.\n\nThis causes invalid sql to be generated - null values become conditions.\n\nexample of invalid generated sql:\nupdate tbl set wh=null, ere=null, anotherfield is null where id=1",
        "No line numbers/source file for exceptions The following groovy file:\n\npublic class bug8 {\n   bug8() {\n      def x = null\n      x + 3\n   }\n   \n   static void main(String[] args) {\n      def b = new bug8()\n   }\n}\n\nProduces:\n\nCaught: java.lang.NullPointerException: Cannot invoke method plus() on null object\n\nWithout a line number for the exception, it's hard to pinpoint it.  When called from Java, I get the following error message:\n\nException in thread \"main\" java.lang.NullPointerException: Cannot invoke method plus() on null object\n        at org.codehaus.groovy.runtime.Invoker.invokeMethod(Invoker.java:130)\n        at org.codehaus.groovy.runtime.InvokerHelper.invokeMethod(InvokerHelper.java:104)\n        at org.codehaus.groovy.runtime.ScriptBytecodeAdapter.invokeMethod(ScriptBytecodeAdapter.java:85)\n        at bug8.<init>(Unknown Source)\n        at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)\n        at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:39)\n        at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:27)\n        at java.lang.reflect.Constructor.newInstance(Constructor.java:494)\n        at java.lang.Class.newInstance0(Class.java:350)\n        at java.lang.Class.newInstance(Class.java:303)\n        at bug8j.main(bug8j.java:16)\n\nThe \"Unknown Source\" is the issue here."
    ],
    [
        "GROOVY-2833",
        "GROOVY-1545",
        "Improve GDK Reference File.eachLine and File.eachFile It would be helpful if the parameters that are passed to the closures for the different each* methods would be better documented, maybe in a semi.formal way. In the case of Reader.eachLine and File.eachLine it looks like not only the line itself is passed to the closure but also the line number(oddly the line number seems to be one-based and not zero-based like everything else in Groovy/Java/Computer Science).\nTo get this information right now someone needs to look at:\nhttp://svn.groovy.codehaus.org/browse/~raw,r=12115/groovy/trunk/groovy/groovy-core/src/main/org/codehaus/groovy/runtime/DefaultGroovyMethods.java\n\nSimilarly the documentation for File.eachFileResurse and others could be improved by stating if both (real) files and directories or only one of those two are passed to the closure.\n\nMaybe a general convention for documenting closure parameters could be setup.",
        "startGroovy script uses Bash extensions The UNIX-style startup scripts for Groovy, use Bash-specific features, but the scripts state they are /bin/sh scripts.\n\nCygwin uses Bash as ./usr/bin but Ubuntu and Solaris (also other UNIX-style systems?) do not."
    ],
    [
        "GROOVY-691",
        "GROOVY-1522",
        "Duplicate class error with listen mode GroovyShell created Script objects now seem to insist on a unique name, need to rework GroovyMain and GroovySocketServer to use a generated name each time instead.\n\njava.lang.LinkageError: duplicate class definition: main\n        at java.lang.ClassLoader.defineClass0(Native Method)\n        at java.lang.ClassLoader.defineClass(ClassLoader.java:539)\n        at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:123)\n        at groovy.lang.GroovyClassLoader.access$100(GroovyClassLoader.java:70)\n        at groovy.lang.GroovyClassLoader$ClassCollector.onClassNode(GroovyClassLoader.java:478)\n        at groovy.lang.GroovyClassLoader$ClassCollector.call(GroovyClassLoader.java:488)\n        at org.codehaus.groovy.control.CompilationUnit$5.call(CompilationUnit.java:587)\n        at org.codehaus.groovy.control.CompilationUnit.applyToPrimaryClassNodes(CompilationUnit.java:822)\n        at org.codehaus.groovy.control.CompilationUnit.classgen(CompilationUnit.java:525)\n        at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:432)\n        at groovy.lang.GroovyClassLoader.parseClass(GroovyClassLoader.java:234)\n        at groovy.lang.GroovyShell.parseClass(GroovyShell.java:485)\n        at groovy.lang.GroovyShell.parse(GroovyShell.java:497)\n        at groovy.lang.GroovyShell.parse(GroovyShell.java:477)\n        at groovy.lang.GroovyShell.parse(GroovyShell.java:519)\n        at groovy.ui.GroovySocketServer.run(GroovySocketServer.java:41)\n        at java.lang.Thread.run(Thread.java:552)",
        "catch block without explicit exception type results in VerifyError When I tried the following script:\n\ntry {\n  throw new Exception();\n} catch(e) {\n  e.printStackTrace();\n}\n\nI got the following VerifyError:\n\nException in thread \"main\" java.lang.VerifyError: (class: Script1, method: run s\nignature: ()Ljava/lang/Object;) catch_type not a subclass of Throwable\n        at java.lang.Class.getDeclaredConstructors0(Native Method)\n        at java.lang.Class.privateGetDeclaredConstructors(Class.java:2388)\n        at java.lang.Class.getConstructor0(Class.java:2698)\n        at java.lang.Class.newInstance0(Class.java:326)\n        at java.lang.Class.newInstance(Class.java:308)\n        at org.codehaus.groovy.runtime.InvokerHelper.createScript(InvokerHelper.java:529)\n        at com.sun.script.groovy.GroovyScriptEngine.eval(GroovyScriptEngine.java:190)\n        at com.sun.script.groovy.GroovyScriptEngine.eval(GroovyScriptEngine.java:82)\n        at com.sun.script.groovy.GroovyScriptEngine.eval(GroovyScriptEngine.java:76)\n        at javax.script.AbstractScriptEngine.eval(AbstractScriptEngine.java:232)\n        at com.sun.tools.script.shell.Main.evaluateReader(Main.java:314)\n        at com.sun.tools.script.shell.Main.evaluateStream(Main.java:350)\n        at com.sun.tools.script.shell.Main.processSource(Main.java:267)\n        at com.sun.tools.script.shell.Main.access$100(Main.java:19)\n        at com.sun.tools.script.shell.Main$2.run(Main.java:182)\n        at com.sun.tools.script.shell.Main.main(Main.java:30)\n\nI suspect that for variable \"e\" in the catch clause above,  \"java.lang.Object\" type is inferred. Either there should be error that says \"use Throwable or subtype in catch clauses\" or infer \"java.lang.Throwable\" as type when type is not specified. The VerifyError would be confusing to developers."
    ],
    [
        "GROOVY-107",
        "GROOVY-7308",
        "Constructor returns class instead of instance in groovlet This exception occurs in the groovlet that follows:\n\ngroovy.lang.MissingMethodException: No such method: queryEach for class: sql\nat groovy.lang.MetaClass.invokeStaticMethod(MetaClass.java:285)\nat org.codehaus.groovy.runtime.Invoker.invokeMethod(Invoker.java:120)\nat org.codehaus.groovy.runtime.InvokerHelper.invokeMethod(InvokerHelper.java:92)\nat sql.run(sql.groovy:10)\nat groovy.servlet.GroovyServlet.service(GroovyServlet.java:233)\n\n---------- sql.groovy -----------------\nimport javax.naming.InitialContext\nimport javax.sql.DataSource\nimport groovy.sql.Sql\n\nContext ctx = new InitialContext();\nDataSource dataSource = ctx.lookup(\"java:comp/env/jdbc/kolc\")\n\nsql = new Sql(dataSource)\nSystem.out.println(\"Sql instance: ${sql}\")\nsql.queryEach(\"select * from WebContentPageType\")\n{ \n  out.println(\"key: ${it.pageNameKey}<BR>\")\n}",
        "Change In MetaClass Behavior The attached propertyaccess.zip contains the following:\n\n{code:borderStyle=solid|title=src/main/groovy/Widget.groovy}\npackage demo\n\nclass Widget {\n\n    static Integer someNumber = 42\n}\n{code}\n\n{code:borderStyle=solid|title=src/test/groovy/WidgetSpec.groovy}\npackage demo\n\nclass WidgetSpec extends spock.lang.Specification {\n\n    void 'test property access'() {\n        given:\n        Widget.metaClass.getSomeNumber = {\n            2112\n        }\n\n        when:\n        def widget = new Widget()\n\n        then:\n        widget.someNumber == 2112\n    }\n}\n{code}\n\nThat test fails because widget.someNumber is 42.  If I edit build.gradle and use Groovy 2.3.9 instead of 2.3.10, the test passes.  Is this change in behavior intentional?\n\nLari thinks that maybe https://github.com/groovy/groovy-core/commit/5e446eca2bae406619d8a6b115af6e4521bed2e4 is relevant."
    ],
    [
        "GROOVY-2341",
        "GROOVY-7092",
        "groovy does not build with current radeox Hi,\n\n\nversion 1.0beta3 is the only version that can be downloaded from http://www.radeox.org but groovy fails to build with this version:\n\n    [javac] 426. ERROR in /home/twerner/debian/build-area/groovy-1.0/src/main/org/\ncodehaus/groovy/wiki/TestCaseRenderEngine.java (at line 59)\n    [javac]     public class TestCaseRenderEngine implements RenderEngine {\n    [javac]                  ^^^^^^^^^^^^^^^^^^^^\n    [javac] The type TestCaseRenderEngine must implement the inherited abstract me\nthod RenderEngine.render(Reader, RenderContext)\n    [javac] ----------\n    [javac] 427. ERROR in /home/twerner/debian/build-area/groovy-1.0/src/main/org/\ncodehaus/groovy/wiki/TestCaseR\n    [javac] enderEngine.java (at line 59)\n    [javac]     public class TestCaseRenderEngine implements RenderEngine {\n    [javac]                  ^^^^^^^^^^^^^^^^^^^^\n    [javac] The type TestCaseRenderEngine must implement the inherited abstract me\nthod RenderEngine.getInitialRenderContext()\n\nMay you fix that, please?\n\n\nCheers,\nTorsten\n",
        "Strange behavior of GString lazy evaluation *Repro steps:*\n\n1. Create the file X.groovy with the following content:\n\n{code:title=X.groovy|borderStyle=solid}\ndef a = \"Hello universe!\"\ndef x = \"Greetings: ${ -> a}\"\nprintln x\n{code}\n\n2. Run the script:\n\n{code:borderStyle=solid}\ngroovy X.groovy\n{code}\n\nResult:\n{code:borderStyle=solid}\nGreetings: Hello universe!\n{code}\n\n3. Modify the file X.groovy as follows:\n\n{code:title=X.groovy|borderStyle=solid}\ndef x = \"Greetings: ${ -> a}\"\ndef a = \"Hello universe!\"\nprintln x\n{code}\n\n4. Run the script:\n\n{code:borderStyle=solid}\ngroovy X.groovy\n{code}\n\n*Result:*\n\n{code:borderStyle=solid}\nCaught: groovy.lang.MissingPropertyException: No such property: a for class: x\ngroovy.lang.MissingPropertyException: No such property: a for class: x\n\tat x$_run_closure1.doCall(x.groovy:1)\n\tat x.run(x.groovy:3)\n{code}\n\nIt does not look like the real \"lazy\" evaluation as it directly depends on the scope where such a GString has been created (the current context at the moment of its creation). And if some of the fields/variables that participate in the lazy evaluation did not exist when the GString object was created, it fails when the evaluation process is expected even if all the variables required exist at that point.\n\nI would consider this issue as pretty critical as it makes the behavior of GString usage inconsistent overall."
    ],
    [
        "GROOVY-3604",
        "GROOVY-3454",
        "Groovy Console applet only works under Windows For a little while now I've been running a Groovy Console in an applet as a way of letting people try a 'live demo' of my Open Source project (before they go to the trouble of downloading it). The demo is here: \n\nhttp://metawidget.org/live-demo \n\nIt uses a (slightly modified) Groovy Console in an applet. You can see the slight modifications here:\n\nhttp://metawidget.svn.sourceforge.net/viewvc/metawidget/trunk/examples/src/java/org/metawidget/example/swing/console/GroovyConsoleApplet.java?revision=371&view=markup\n\nBy all accounts this demo works well on Windows. It takes a little while to download but other than that it's great.\n\nHowever I have received multiple complaints about its performance on Ubuntu and Fedora. Using the Sun JVM plugin it runs extremely slowly ('laggy', as \nin menus slow to open), takes a long time to execute the Groovy script, and is generally unusable. Other applets on the same platform work okay. Similarly, I have received complaints on Mac OS. See this thread...\n\nhttp://groups.google.com/group/groovy-user/browse_thread/thread/fa1b9762bc41755c/715bb641e721c5aa?hl=en&ie=UTF-8&oe=UTF-8&q=metawidget\n\nCould these issues be resolved, or is it not advisable to try and run the Groovy Console in an applet? The 'user experience' needs to be better before this JIRA...\n\nhttp://jira.codehaus.org/browse/GROOVY-3096\n\n...can become a reality.\n\nRegards, \n\nRichard.",
        "Compiler should enforce that annotation value w/o default is provided {code}\nimport java.lang.annotation.Retention\nimport java.lang.annotation.RetentionPolicy\n\n@Retention(RetentionPolicy.RUNTIME)\n@interface Foo {\n  String x()\n}\n\n@Foo // compiler should not allow this, because there is no default value for x\nclass Bar {}\n\ndef anno = Bar.class.getAnnotation(Foo)\nanno.x() // java.lang.annotation.IncompleteAnnotationException: Foo missing element x\n{code}"
    ],
    [
        "GROOVY-313",
        "GROOVY-2630",
        "'package' accessible methods not handled correctly Calling a 'package' accessible method (in a Java class) from a groovy script in a different package results in a java.lang.IllegalAccessError, but calling a private method is ok. Since setAccessible is used to gain access to all methods, I assume that package private methods should be callable as well.\n\nSteps to reproduce:\n1) Compile the Java class included at the end\n2) Add it to the classpath\n3) Start the groovy shell and type:\n   1> f = new bar.Foo()\n   2> f.priv()\n   3> f.pack()\n   4> go\n4) You should see this:\n-----------------------------------------------------------\n[]\nI am private\n>>> a serious error occurred: tried to access method bar.Foo.pack()V from class\ngjdk.bar.Foo_GroovyReflector\n>>> stacktrace:\njava.lang.IllegalAccessError: tried to access method bar.Foo.pack()V from class\ngjdk.bar.Foo_GroovyReflector\n-----------------------------------------------------------\n\nNotice that it was ok to call the private method, but not ok to call the package accessible method.\n\n\npackage bar;\npublic class Foo\n{\n   public void pub() {\n      System.out.println(\"I am public\");\n   }\n   protected void prot() {\n      System.out.println(\"I am protected\");\n   }\n   void pack() {\n      System.out.println(\"I am package\");\n   }\n   private void priv() {\n      System.out.println(\"I am private\");\n   }\n}",
        "Support Half-Mocks Half-Mocks are mocks for classes with dynamic methods or properties. One example are Grails domain objects where you would use the implemented domain specific methods but want to mock the GORM methods.\n"
    ],
    [
        "GROOVY-5442",
        "GROOVY-7357",
        "Groovy SQL issue with numeric data in queries I have a query that I'm running in GSQL that is behaving badly. The query returns a number of\nrows, and then compares one of the values to a list (to exclude them), sort of an everything-but\nlist. The query was working fine straight against the database, but I never got any exclusions in\nmy Groovy script. It doesn't seem to be able to compare a numeric column in the database\nagainst a list of numbers.\n\n\nFirst query:\n{code}\ndef userId = 'A12345'\ndef pstatus = 'ACTIVE'\ndef queryOne = \"\"\"\n\tselect h.thingy_name, h.thingy_environment\n\tpa.thingy_id, pa.thingy_status,\n\th.thingy_number\n\tfrom table1 pa\n\t\tjoin table2 p on PA.P_ID = p.id\n\t\t\tand p.id in (\n\t\t\t\tselect pav.p_id from table3 pav\n\t\t\t\twhere pav.dude = ${userId})\n\t\tjoin table4 h on h.id = pa.h_id\n\t\twhere pa.dude = ${userId}\n\t\tand pa.status = ${pstatus}\n\t\"\"\"\ndef excludeThings = [12345,23456]\ndef i=0\nsql.eachRow (queryTwo) { row ->\n\tif (excludeThings.contains (row?.thingy_number)) {\n\t\ti++\n\t\tprintln row\n\t} \n}\nprintln \"Found ${i} rows for excluding thingnumber ${excludeCostCenters} \"\n{code}\n\nAnd the response is: \n{code}\n  Found 0 rows for excluding thingnumber [12345, 23456]\n{code}\n\nThis is incorrect. In my case, there are 44 rows returned from that query that do not match \nthose two numbers. \n\nNot sure why the returned data type for thingy_number does not compare favorably to the numbers\nin my compare list, but what the heck: let's just make it a string, convert my result to character, \nand all will be well!\n\n{code}\ndef queryOne = \"\"\"\n\tselect h.thingy_name, h.thingy_environment\n\tpa.thingy_id, pa.thingy_status,\n\tto_char(h.thingy_number) thing_no\n\tfrom table1 pa\n\t\tjoin table2 p on PA.P_ID = p.id\n\t\tand p.id in (\n\t\tselect pav.p_id from table3 pav\n\t\twhere pav.dude = ${userId})\n\t\tjoin table4 h on h.id = pa.h_id\n\t\twhere pa.dude = ${userId}\n\t\tand pa.status = ${pstatus}\n\t\"\"\"\ndef excludeThings = ['12345','23456']\ndef i=0\nsql.eachRow (queryTwo) { row ->\n\tif (excludeThings.contains (row?.thing_no)) {\n\t\ti++\n\t\tprintln row\n\t} \n}\n{code}\n\nThis works, and returns the right result. I don't think I should have to call a database\nfunction to do this...\n\nUsing Groovy 1.8.1\nJVM 1.6.0_25\nOracle 11g\n",
        "Optimized foreach loops should perform a null check The following code is a regression, because previously the code used an iterator, which in case of {{null}} returned an empty iterator. With the optimized path, the loop will fail.\n\n{code}\n@CompileStatic\nprivate void foo(String[] arr) {\n   for (String s in arr) {\n      println(s)\n   }\n}\n\nfoo(null)\n{code}"
    ],
    [
        "GROOVY-4214",
        "GROOVY-7080",
        "StackOverflowError tyring to mixin loaded script In groovyConsole I have this:\n\n{code}\nimport groovy.util.*\nimport org.codehaus.groovy.runtime.*\n\ndef gse = new GroovyScriptEngine(\"c:\\\\temp\")\n\ndef script = gse.loadScriptByName(\"say.groovy\")\n\nthis.metaClass.mixin script\n\nsay(\"bye\")\n{code}\nsay.groovy contains\n{code}\ndef say(String msg) {\n  println(msg)\n}\n{code}\n\nI get:\n{noformat}\njava.lang.StackOverflowError\n\tat sun.reflect.GeneratedMethodAccessor548.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n\tat java.lang.reflect.Method.invoke(Method.java:597)\n\tat org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:88)\n\tat org.codehaus.groovy.runtime.metaclass.MixinInstanceMetaMethod.invoke(MixinInstanceMetaMethod.java:38)\n\tat groovy.lang.ExpandoMetaClass.invokeMethod(ExpandoMetaClass.java:913)\n\tat groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:886)\n\tat groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:706)\n\tat org.codehaus.groovy.runtime.metaclass.OwnedMetaClass.invokeMethod(OwnedMetaClass.java:97)\n\tat groovy.lang.GroovyObjectSupport.invokeMethod(GroovyObjectSupport.java:44)\n\tat groovy.lang.Script.invokeMethod(Script.java:78)\n\tat sun.reflect.GeneratedMethodAccessor548.invoke(Unknown Source)\n        ...\n{noformat}\n",
        "Cycle in Eclipse Try to follow guide from https://github.com/groovy/groovy-core#building\nImporting groovy-core and groovy-test gives the error\nA cycle was detected in the build path of project 'groovy'. The cycle consists \nof projects {groovy, groovy-test}\n\nWhy not just merge groovy-test in groovy-core? The subprojects of Groovy depend on both anyway, and groovy-test is small."
    ],
    [
        "GROOVY-2006",
        "GROOVY-925",
        "JDK Dynamic Proxies Broken Groovy beans wrapped in JDK style proxies throw an \"IllegalArgumentException: object is not an instance of declaring class\" when a method is called on them from a Groovy object.\n\nThread on subject from the dev list: http://www.nabble.com/JDK-Style-Proxy-Issue-tf4137792.html\n\nDiagnosis from Jochen Theodorou: http://www.nabble.com/Re%3A-JDK-Style-Proxy-Issue-p11815320.html",
        "map.findAll() should return a subMap rather than a list of HashMap Entries goal: keep map closed under the operation of findAll()\n\nmap = [a:1, b:2, c:3]\n\nsubmap = map.subMap(['a','b'])\n\nfound = map.findAll{['a','b'].contains(it.key)}\n\n// throws java.lang.AssertionError: Expression: (submap == found). \n// Values: submap = {a=1,b=2}, found = [b=2, a=1]\n\nassert submap == found"
    ],
    [
        "GROOVY-2790",
        "GROOVY-7336",
        "Groovy Console load is broken. Loading of certain groovy files results in a scrambled version of the file, i.e. there's additional code added to the end of the file.\nI included a file that shows the error in my app.\n\nI hope this isn't a duplicate. I couldn't find a matching bug report.",
        "Not so helpful error message shown by ClassNodeResolver, after eating up the real exception Attaching a zip that contains the example to reproduce the issue.\n\nThe scenario is this: From my Ant script, I am executing a groovy script (One.groovy), which depends on another script, Two.groovy (which has a compilation error - it refers to a non-existing class FFile).\n\nThe problem is that instead of telling me anything about FFile class's non-existence, the groovy compiler gives a not-so-useful error message that looks like below:\n\n{code}\n...\\bug_report\\build.xml:11: \n\nBUG! exception in phase 'semantic analysis' in source unit '...\\bug_report\\src\\One.groovy' \n\nThe lookup for Two caused a failed compilaton. There should not have been any compilation from this call.\n\n        at org.codehaus.groovy.control.ClassNodeResolver.tryAsLoaderClassOrScript(ClassNodeResolver.java:188)\n        at org.codehaus.groovy.control.ClassNodeResolver.findClassNode(ClassNodeResolver.java:168)\n        at org.codehaus.groovy.control.ClassNodeResolver.resolveName(ClassNodeResolver.java:124)\n        at org.codehaus.groovy.control.ResolveVisitor.resolveToOuter(ResolveVisitor.java:617)\n        at org.codehaus.groovy.control.ResolveVisitor.resolve(ResolveVisitor.java:269)\n        at org.codehaus.groovy.control.ResolveVisitor.resolve(ResolveVisitor.java:237)\n        at org.codehaus.groovy.control.ResolveVisitor.resolveOrFail(ResolveVisitor.java:221)\n        at org.codehaus.groovy.control.ResolveVisitor.resolveOrFail(ResolveVisitor.java:233)\n        at org.codehaus.groovy.control.ResolveVisitor.transformConstructorCallExpression(ResolveVisitor.java:988)\n...\n...\n{code}\n\nIt'll do better to include some information about the underlying exception.\n\n\"BUG! exception in phase 'semantic analysis' in source unit '...\\One.groovy'\" is not much use."
    ],
    [
        "GROOVY-1055",
        "GROOVY-266",
        "MissingPropertyException: No such property: println // demo.groovy\nprintln [1,2].collect{it + 1}\n\nrun the file and below exception is thrown\nCaught: groovy.lang.MissingPropertyException: No such property: println for class: demo\n\tat demo.run(e:\\groovy\\demo.groovy:2)\n\tat demo.main(e:\\groovy\\demo.groovy)\n\n\nbut for file \n//demo2.groovy\nprintln ([1,2].collect{it + 1})\n\nIt works well.",
        "an inner closure doesn't use the outer closures delegate to resolve names class Test {\n\tstatic main(args) {\n\t\tc = {\n\t\t\t\tprintln \"outer x:${x}\"\n\t\t\t\t\n\t\t\t\tc1 = {\n\t\t\t\t \t\tprintln \"inner x:${x}\"\n\t\t\t\t }\n\t\t\t\t \n\t\t\t\t c1()\n\t\t\t}\n\n\t\tc.setDelegate(x:'hello')\n\t\t\n\t\tc()\n\t}\n}\n\nprints outer x:hello\nbut throws groovy.lang.MissingPropertyException: No such property: x for class: Test$3 when trying to print x from the inner closure\n\n\nI think that this may be the cause of a great deal of the weird behaviour I'm seeing in markup generation"
    ]
]